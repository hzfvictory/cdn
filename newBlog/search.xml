<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test</title>
    <url>/2020/01/16/test/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">abbrlink: ee34d04d</span><br><span class="line">categories: TypeScript</span><br><span class="line">tags: JS Notes</span><br><span class="line">title:  MAC 整理</span><br><span class="line">hidden: <span class="literal">true</span></span><br><span class="line">date: <span class="number">2019</span><span class="number">-05</span><span class="number">-16</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">abbrlink: <span class="string">'214639e1'</span></span><br><span class="line">categories: </span><br><span class="line">- TypeScript</span><br><span class="line">title: TypeScript</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">abbrlink: <span class="number">1301e6</span>de</span><br><span class="line">categories: </span><br><span class="line">- TypeScript</span><br><span class="line">title: 推荐库</span><br><span class="line">top: <span class="literal">true</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">abbrlink: <span class="number">2</span>b423c9</span><br><span class="line">categories: </span><br><span class="line">- TypeScript</span><br><span class="line">- jest</span><br><span class="line">title: TypeScript</span><br><span class="line">sticky: <span class="number">10086</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<div class="note default">
            <p>default提示块标签</p>
          </div>

<div class="note primary no-icon">
            <p>primary提示块标签</p>
          </div>

<div class="note success">
            <p>success提示块标签</p>
          </div>

<div class="note info">
            <p>info提示块标签</p>
          </div>

<div class="note warning">
            <p>warning提示块标签</p>
          </div>

<div class="note danger">
            <p>danger提示块标签</p>
          </div>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
  </entry>
  <entry>
    <title>配置WS</title>
    <url>/2020/01/16/other/ws-configure/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>配置WS</strong></p>
<p>[[toc]]</p>
<h3 id="webstorm-代码格式化设置与eslint-standard一致"><a href="#webstorm-代码格式化设置与eslint-standard一致" class="headerlink" title="webstorm 代码格式化设置与eslint standard一致"></a>webstorm 代码格式化设置与eslint standard一致</h3><p>新弄了个vue项目，使用的eslint是standard规范。</p>
<p>新建项目，用webstorm打开项目，顺利开搞，结果一到vue组件里，就报黄色叹号警告⚠️了。</p>
<p>这里就需要配置一下webstorm里的 <code>code style</code></p>
<p><code>command + &#39;,&#39;</code>打开设置 -&gt; <code>Editor</code></p>
<h4 id="配置js格式化规范"><a href="#配置js格式化规范" class="headerlink" title="配置js格式化规范"></a>配置js格式化规范</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H86506f0d0b25471d9826e543af0bc40cz.jpg" alt=""><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hbf762eeef1074a3aa8d614167de006355.jpg" alt=""><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hf694848fcefb4849a3171f607dec5c99W.jpg" alt=""><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Ha4e8713c7aeb4dc19bfddb5df4e67146l.jpg" alt=""></p>
<h4 id="配置html-vue组件"><a href="#配置html-vue组件" class="headerlink" title="配置html/vue组件"></a>配置html/vue组件</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H0e31c6cdba2e4cf5b1430509f83ad1bcF.jpg" alt=""></p>
<p>在do not indent children of里加入script标签</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Ha11bf52407204bc496b2b54e4ba314eeM.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Other</category>
        <category>配置WS</category>
      </categories>
      <tags>
        <tag>WebStorm</tag>
      </tags>
  </entry>
  <entry>
    <title>网站大全</title>
    <url>/2019/03/16/tools/page/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>网站大全</strong></p>
<p>[[toc]]</p>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><h3 id="常看的网站"><a href="#常看的网站" class="headerlink" title="常看的网站"></a>常看的网站</h3><ul>
<li><a href="https://github.com/sorrycc/awesome-f2e-libs" target="_blank" rel="noopener">awesome-f2e-libs</a> sorrycc 整理的个人关注使用的前端库</li>
<li><a href="https://overreacted.io/" target="_blank" rel="noopener">overreacted</a> react Dan 的个人博客，更新频率很高</li>
<li><a href="https://medium.com/dailyjs" target="_blank" rel="noopener">DailyJS</a></li>
<li><a href="https://codeburst.io/" target="_blank" rel="noopener">codeburst</a></li>
</ul>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><ul>
<li><a href="https://git.io" target="_blank" rel="noopener">github 短域名服务</a></li>
<li><a href="https://shields.io/" target="_blank" rel="noopener">shields</a> Github README 里面的装逼小图标</li>
<li><a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">Emoji</a> 方便平时写查找 emoji</li>
<li><a href="http://emoji.muan.co/#" target="_blank" rel="noopener">emoji.muan</a> 同上 而且更全</li>
<li><a href="http://git-awards.com/users/search?login=panjiachen" target="_blank" rel="noopener">git-awards</a> github ranking 没事可以查着玩玩</li>
<li><a href="http://githubrank.com/" target="_blank" rel="noopener">http://githubrank.com/</a> github 按照 followers 排名</li>
<li><a href="https://wangchujiang.com/github-rank/" target="_blank" rel="noopener">github-rank</a>同上，githubrank 基本算挂了已经，只能用这个新的</li>
<li><a href="https://www.timqian.com/star-history/#PanJiaChen/vue-element-admin" target="_blank" rel="noopener">star-history</a> 展示一个项目 Stars 增长规矩曲线</li>
<li><a href="https://github.com/probot/probot" target="_blank" rel="noopener">probot</a> 基于 github 做一个小机器人。可以做很多 workflow 的事情</li>
</ul>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ul>
<li><a href="https://caniuse.com/" target="_blank" rel="noopener">can i use</a> 前端常用网站了 查看不同属性和方法的兼容性</li>
<li><a href="https://squoosh.app/" target="_blank" rel="noopener">Squoosh</a> 谷歌出品在线免费图片压缩工具 神器</li>
<li><a href="https://github.com/CompuIves/codesandbox-client" target="_blank" rel="noopener">codesandbox-client</a> - 在线 web 开发容器</li>
<li><a href="https://github.com/fkling/astexplorer" target="_blank" rel="noopener">astexplorer</a> - 一个在线 ast 生成器</li>
<li><a href="https://30secondsofcode.org/" target="_blank" rel="noopener">30 seconds of code</a> 收集了许多有用的代码小片段</li>
<li><a href="https://app.zeplin.io/" target="_blank" rel="noopener">zeplin</a> 前端和设计师神器，有标注、Style Guide、版本管理、简单的团队协作，重点是前端不用写 css 了，复制就可以了。</li>
<li><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a> 阿里出的图标库，非常实用，支持 svg、font、png 多种格式，基本现在所有图标都在上面找。</li>
<li><a href="http://cssicon.space/#/" target="_blank" rel="noopener">cssicon</a> 所有的 icon 都是纯 css 画的 缺点：icon 不够多</li>
<li><a href="http://zhitu.isux.us/" target="_blank" rel="noopener">智图</a> 腾讯出品 在线图片压缩 支持转成 webP 处理静态图片时候很好用</li>
<li><a href="https://www.picdiet.com/zh-cn" target="_blank" rel="noopener">picdiet</a> 另一个图片压缩网站</li>
<li><a href="http://apps.eky.hk/css-triangle-generator/" target="_blank" rel="noopener">CSS triangle generator</a> 帮你快速用 css 做出三角形</li>
<li><a href="http://www.cssarrowplease.com/" target="_blank" rel="noopener">cssarrowplease</a> 帮你做对话框三角的</li>
<li><a href="http://bennettfeely.com/clippy/" target="_blank" rel="noopener">clippy</a> 在线帮你使用 css clip-path 做出各种形状的图形</li>
<li><a href="https://regex101.com/" target="_blank" rel="noopener">Regular Expressions</a> 在线正则网站</li>
<li><a href="https://jex.im/regulex/" target="_blank" rel="noopener">jex</a> 正则可视化网站，配合上面的 Regular Expressions，写正则方便很多</li>
<li><a href="https://jsfiddle.net/" target="_blank" rel="noopener">jsfiddle</a> 在线运行代码网站 很不错，可惜要翻墙</li>
<li><a href="https://codepan.net/" target="_blank" rel="noopener">codepan</a> 在线运行代码网站 不用翻墙，可以自己部署</li>
<li><a href="https://fiddle.md/" target="_blank" rel="noopener">fiddle.md</a> 一个方便的在线共享 markdown 在线笔试题一般都用这个</li>
<li><a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsdelivr</a> cdn 服务</li>
<li><a href="https://unpkg.com" target="_blank" rel="noopener">unpkg</a> cdn 服务</li>
<li><a href="https://coderpad.io/" target="_blank" rel="noopener">coderpad</a> 远程面试的神器，可以让面试者远程写代码 不过需要翻墙</li>
<li><a href="http://www.icode.live/" target="_blank" rel="noopener">icode</a> 有赞团队出品的 coderpad 可以互补，它不需要翻墙</li>
<li><a href="https://www.codeadvice.io" target="_blank" rel="noopener">codeadvice</a> 又一个让面试者远程写代码的网址</li>
<li><a href="https://snipper.io" target="_blank" rel="noopener">snipper</a> 一个代码协同的网站。你新建一个代码片段，然后把网址分享给其他人，就可以看到他们的实时编辑。</li>
<li><a href="https://codesandbox.io/" target="_blank" rel="noopener">codesandbox</a> 一个可以在线编辑且提供在线 demo 的网站 支持 vue react angular 多种框架 神器</li>
<li><a href="https://tympanus.net/codrops/" target="_blank" rel="noopener">codrops</a> 上面的交互都非常酷炫</li>
<li><a href="http://www.aigei.com/bgremover" target="_blank" rel="noopener">bgremover</a> 在线图片去底工具</li>
<li><a href="https://www.photopea.com/" target="_blank" rel="noopener">photopea</a> 一个网页端 Photoshop 很变态</li>
<li><a href="https://bestofjs.org/" target="_blank" rel="noopener">bestofjs</a> 查看一个项目增长经历，Star 数变化的网站，辅助你判断这个库的质量</li>
<li><a href="https://stackblitz.com/" target="_blank" rel="noopener">stackblitz</a> 一款在线 IDE,主要面向 Web 开发者,移植了很多 VS Code 的特性与功能</li>
<li><a href="http://app.programmingfonts.org" target="_blank" rel="noopener">programmingfonts.org </a> 一个专门介绍编程字体的网站</li>
<li><a href="https://wubaiqing.github.io/zaobao/" target="_blank" rel="noopener">早报</a> 一个个人开发者的前端开发的分享日报</li>
<li><a href="https://emoji.muan.co/#" target="_blank" rel="noopener">emoji-search</a> 帮你快速找到能表达你情感的 emoji</li>
<li><a href="https://github.com/carloscuesta/gitmoji" target="_blank" rel="noopener">gitmoji</a> 通过 emoji 表达 git 的操作内容</li>
<li><a href="https://starcharts.herokuapp.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">starcharts</a> 可以把你一个项目的 stars 增长轨迹当做 svg 放在 readme 中</li>
<li><a href="https://www.mockapi.io/" target="_blank" rel="noopener">mockapi</a> 一个还不错的在线 mock 服务（可在线可视化编辑），可以满足大部分简单需求了</li>
<li><a href="coder.com">coder</a> 在线版 VS Code</li>
<li><a href="https://www.browserstack.com/" target="_blank" rel="noopener">browserstack</a> 远程调整各种版本浏览器 兼容性问题</li>
<li><a href="https://carbon.now.sh/" target="_blank" rel="noopener">carbon</a> 根据源码生成图片 主要作用是让你打代表片段分享的时候更好看一点</li>
<li><a href="https://euangoddard.github.io/clipboard2markdown/" target="_blank" rel="noopener">clipboard2markdown</a> 将你所有复制进去的内容都转化为 markdown</li>
<li><a href="https://www.grammarly.com/" target="_blank" rel="noopener">grammarly</a> 英语写作检查工具</li>
<li><a href="https://quickchart.io/" target="_blank" rel="noopener">quickchart</a> 通过 URL 生成图表的开源服务</li>
<li><a href="https://www.hipdf.cn/" target="_blank" rel="noopener">hipdf</a> 一站式在线 PDF 解决方案</li>
<li><a href="https://whimsical.com" target="_blank" rel="noopener">whimsical</a> 画路程图</li>
<li><a href="https://picsum.photos/" target="_blank" rel="noopener">Lorem Picsum</a> 提供免费的占位图</li>
<li><a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a> 免费图床</li>
</ul>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><ul>
<li><a href="https://uimovement.com/" target="_blank" rel="noopener">uimovement</a> 能从这个网站找到不少动画交互的灵感</li>
<li><a href="https://www.awwwards.com/" target="_blank" rel="noopener">awwwards</a>是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站</li>
<li><a href="https://dribbble.com/" target="_blank" rel="noopener">dribbble</a> 经常能在上面找到很多有创意好看的 gif 或者图片，基本上我所有的图都是上面找的</li>
<li><a href="https://www.behance.net/" target="_blank" rel="noopener">Bēhance</a> dribbble 是设计师的微博，Bēhance 是设计师的博客</li>
<li><a href="https://logojoy.com/" target="_blank" rel="noopener">Logojoy</a> 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。</li>
<li><a href="http://brandmark.io/" target="_blank" rel="noopener">brandmark</a> 另一个在线制作 logo 网站</li>
<li><a href="https://instantlogodesign.com/" target="_blank" rel="noopener">instant</a> 又一个 logo 制作网站</li>
<li><a href="https://www.designevo.com/logo-maker/" target="_blank" rel="noopener">logo-maker</a> 又一个 logo 制作网站 这个更简单点 就是选模板之后微调</li>
<li><a href="https://coolors.co/" target="_blank" rel="noopener">coolors</a> 帮你在线配色的网站 你能找到不少配色灵感</li>
<li><a href="http://colorhunt.co/" target="_blank" rel="noopener">colorhunt</a> 另一个配色网站</li>
<li><a href="https://uigradients.com/#SummerDog" target="_blank" rel="noopener">uigradients</a> 渐变色网站</li>
<li><a href="https://www.designcap.com" target="_blank" rel="noopener">designcap</a> 在线海报设计</li>
<li><a href="https://flatuicolors.com/" target="_blank" rel="noopener">Flat UI 色表</a> Flat UI 色表</li>
<li><a href="https://www.0to255.com/" target="_blank" rel="noopener">0to255</a> 颜色梯度</li>
<li><a href="https://github.com/mikolajdobrucki/ikonate" target="_blank" rel="noopener">Ikonate</a> 提供免费的图标 icons</li>
<li><a href="https://remixicon.com/" target="_blank" rel="noopener">remixicon</a> 又一个提供免费图标 icons</li>
<li><a href="https://github.com/feathericons/feather" target="_blank" rel="noopener">feather</a> 免费的 icons</li>
<li><a href="https://github.com/arcticicestudio/nord" target="_blank" rel="noopener">nord </a> 北欧性冷淡风主题配色</li>
<li><a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a> 提供免费的高清图片</li>
<li><a href="https://colorkitty.com/" target="_blank" rel="noopener">colorkitty</a> 从你的图片中提取配色</li>
</ul>
<h3 id="有趣"><a href="#有趣" class="headerlink" title="有趣"></a>有趣</h3><ul>
<li><a href="http://www.baidu-x.com/" target="_blank" rel="noopener">帮你百度一下</a> 可以 <a href="http://www.baidu-x.com/?q=%E5%92%8C%E8%B0%90%E6%9C%89%E7%88%B1%E5%AF%8C%E5%BC%BA" target="_blank" rel="noopener">点我测试一下</a>-</li>
<li><a href="http://lmgtfy.com/" target="_blank" rel="noopener">国际版</a> 同<code>帮我百度一下</code>-<a href="http://lmgtfy.com/?q=a" target="_blank" rel="noopener">点我测试一下</a>-</li>
<li><a href="https://alpha.wallhaven.cc/" target="_blank" rel="noopener">wallhaven</a> 壁纸网站-</li>
<li><a href="http://matthewrayfield.com/articles/animating-urls-with-javascript-and-emojis/#%F0%9F%8C%96" target="_blank" rel="noopener">URL 地址播放 Emojis 动画</a> 在地址栏里面播放 emoji</li>
<li><a href="https://cantunsee.space/" target="_blank" rel="noopener">Can’t Unsee</a> 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样</li>
<li><a href="https://talk.swift.gg/" target="_blank" rel="noopener">ggtalk</a> 平时一直在听的一个技术博客</li>
<li><a href="https://github.com/Blankj/awesome-comment" target="_blank" rel="noopener">awesome-comment</a> 里面收集了很多有趣的代码注释</li>
<li><a href="https://www.text-image.com/index.html" target="_blank" rel="noopener">text-img</a> 都将图片转化为 ascii 用来写注释</li>
<li><a href="https://github.com/beizhedenglong/weird-fonts" target="_blank" rel="noopener">weird-fonts</a> 将普通字母转化为 特殊 unicode</li>
<li><a href="https://github.com/epidemian/snake" target="_blank" rel="noopener">snake</a> 在地址栏里面玩贪吃蛇</li>
</ul>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><ul>
<li><a href="http://aliscued.lofter.com/" target="_blank" rel="noopener">微交互</a> 里面收集了市面上很多很好的微交互例子 值得学习</li>
<li><a href="http://littlebigdetails.com/" target="_blank" rel="noopener">Little Big Details</a> 同上，一个国外微交互汇集网站</li>
<li><a href="https://cruip.com/" target="_blank" rel="noopener">cruip</a> 登录页的各种页面设计，可以免费下载模板</li>
<li><a href="https://comixify.ii.pw.edu.pl/" target="_blank" rel="noopener">Comixify</a> 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。</li>
<li><a href="https://github.com/bui/taiko-web" target="_blank" rel="noopener">taiko-web</a> 太鼓达人网页版 只能说很 6</li>
</ul>
<h3 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h3><ul>
<li><a href="https://css-tricks.com/" target="_blank" rel="noopener">css-tricks</a> 一个学习 css 不错的网站 有很多有意思的 demo</li>
</ul>
<h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><ul>
<li><p><a href="https://egghead.io/courses/execute-npm-package-binaries-with-the-npx-package-runner" target="_blank" rel="noopener">npx</a> 教你怎么合理的使用 npx</p>
</li>
<li><p><a href="https://www.hacksplaining.com/lessons" target="_blank" rel="noopener">hacksplaining</a> 网络安全学习网站</p>
</li>
</ul>
<h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><ul>
<li><p><a href="http://www.pmdaniu.com/" target="_blank" rel="noopener">产品大牛</a> 什么有很多完整的产品原型可以借鉴</p>
</li>
<li><p><a href="https://modao.cc/pricing" target="_blank" rel="noopener">磨刀</a> 快速出 ui 原型</p>
</li>
</ul>
<h3 id="实用"><a href="#实用" class="headerlink" title="实用"></a>实用</h3><p><a href="https://admin.typeform.com/signup" target="_blank" rel="noopener">typeform</a> 一个国外的在线调查问卷网站</p>
<h3 id="Talk"><a href="#Talk" class="headerlink" title="Talk"></a>Talk</h3><p><a href="https://github.com/peerigon/talks" target="_blank" rel="noopener">peerigon-talks</a> 收集了不少有意思的 talks</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">leetcode</a> 用 js 刷 leetcode</p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>实用网站</tag>
      </tags>
  </entry>
  <entry>
    <title>开发工具</title>
    <url>/2019/03/16/tools/store/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>开发工具</strong></p>
<p>[[toc]]</p>
<h3 id="推荐库"><a href="#推荐库" class="headerlink" title="推荐库"></a>推荐库</h3><p><strong>太常用的一些库，比如 <code>lodash</code>、<code>axios</code>、<code>echarts</code>、<code>normalize.css</code>等就不再下面推荐了。这里主要推荐一下自己平时常用，提高效率的，但大家可能又不知道的一些库。</strong></p>
<h3 id="前端常用"><a href="#前端常用" class="headerlink" title="前端常用"></a>前端常用</h3><ul>
<li><a href="https://github.com/sweetalert2/sweetalert2" target="_blank" rel="noopener">sweetalert2</a> 一个自适应，且自定义性强的弹出框（零依赖）</li>
<li><a href="https://github.com/atomiks/tippyjs" target="_blank" rel="noopener">tippy.js </a> 最著名的 tooltip/popover library</li>
<li><a href="https://github.com/text-mask/text-mask" target="_blank" rel="noopener">text-mask</a> 可以让 input 按照规则输入(如电话,email,日期,信用卡等)，特殊格式 input</li>
<li><a href="https://github.com/sarahdayan/dinero.js" target="_blank" rel="noopener">dinero.js</a> 用来创建、计算和格式化货币价值的不可变的框架，支持国际化</li>
<li><a href="https://github.com/lerna/lerna" target="_blank" rel="noopener">lerna</a> 大项目版本控制工具，项目中可以有多个 package.json 文件</li>
<li><a href="https://github.com/RevillWeb/img-2" target="_blank" rel="noopener">img-2</a> 一个提高图片加载性能和体验的库，懒加载使用 web worker 模糊预览</li>
<li><a href="https://github.com/Valve/fingerprintjs2" target="_blank" rel="noopener">fingerprintjs</a> 是一个快速的浏览器指纹库，通浏览环境的一系列配置生成 id</li>
<li><a href="https://github.com/epoberezkin/ajv" target="_blank" rel="noopener">ajv</a> 一个 json schema 验证的库</li>
<li><a href="https://github.com/xx45/dayjs" target="_blank" rel="noopener">dayjs</a> 一个轻量级类 moment.js API 时间库</li>
<li><a href="https://github.com/PrismJS/prism" target="_blank" rel="noopener">primjs</a> 让页面支持代码高亮</li>
<li><a href="https://github.com/RelaxedJS/ReLaXed" target="_blank" rel="noopener">ReLaXed</a> 一个将 document html 转成 PDF 的工具</li>
<li><a href="https://github.com/transloadit/uppy" target="_blank" rel="noopener">uppy</a> 一个很好看的也很好用的 前端上传库</li>
<li><a href="https://github.com/pqina/filepond" target="_blank" rel="noopener">Filepond</a> 一个小巧的文件上传库</li>
<li><a href="http://ui.toast.com/tui-calendar/" target="_blank" rel="noopener">tui-calendar</a> 功能全面的日程安排日历控件，还支持拖拽</li>
<li><a href="https://github.com/nhnent/tui.editor" target="_blank" rel="noopener">tui.editor</a> markdown 所见即所得编辑器</li>
<li><a href="https://github.com/tabler/tabler" target="_blank" rel="noopener">tabler</a> - 基于 Bootstrap 4 的 Dashboard UI Kit 和美观 高颜值 ui 模板</li>
<li><a href="https://github.com/BoxFactura/pulltorefresh.js" target="_blank" rel="noopener">pulltorefresh.js</a> - 下个下拉刷新插件</li>
<li><a href="https://github.com/yued-fe/lulu" target="_blank" rel="noopener">lulu</a> - 腾讯阅文基于 jQuery，针对 PC 网站 IE8+（peak 主题）的前端 UI 框架</li>
<li><a href="https://github.com/chancejs/chancejs" target="_blank" rel="noopener">chancejs</a> - 生成随机数据的库</li>
<li><a href="https://github.com/spritejs/spritejs" target="_blank" rel="noopener">spritejs</a> - 360 奇舞团出的跨平台绘图对象模型</li>
<li><a href="https://github.com/googlechrome/workbox" target="_blank" rel="noopener">workbox</a> - 让你的网站更方便的变成 pwa</li>
<li><a href="https://github.com/nhnent/tui.image-editor" target="_blank" rel="noopener">tui.image-editor</a> - 一个功能齐全的在线图片编辑，基于 canvas</li>
<li><a href="https://github.com/ai/nanoid" target="_blank" rel="noopener">nanoid</a> - 前端轻量 unique string ID 生成库</li>
<li><a href="https://github.com/pubkey/rxdb" target="_blank" rel="noopener">rxdb</a> - 一款开源的快速、灵活的客户端数据库，支持各种浏览器以及 NodeJS，Electron、React 等等，是 PouthDB 之上的一个封装库</li>
<li><a href="https://github.com/danburzo/percollate" target="_blank" rel="noopener">percollate</a> - 命令行工具 能将网页转换成 pdf</li>
<li><a href="https://github.com/sokra/rawact" target="_blank" rel="noopener">rawact</a> - 一个 babel 插件，把 react 组件转为原生 dom</li>
<li><a href="https://github.com/gruns/irondb" target="_blank" rel="noopener">irondb</a> - 是一个浏览器 key-value 储存的封装库，把 Cookies、IndexedDB、LocalStorage、SessionStorage 统一成一个接口。它的最大特色就是数据冗余机制，即使某种底层储存机制失效，它可以从其他机制恢复数据。</li>
<li><a href="https://github.com/MikeMcl/big.js" target="_blank" rel="noopener">big.js</a> 解决 js 浮点数问题。 主要就是 Big Number 或者小数点温柔</li>
<li><a href="https://github.com/MikeMcl/bignumber.js" target="_blank" rel="noopener">bignumber.js</a> - 同上</li>
<li><a href="https://github.com/dollarshaveclub/stickybits" target="_blank" rel="noopener">stickybits</a> - CSS 的 position: sticky 是一个很有用的设置，但是老的浏览器不支持。这个 JS 库是该功能的垫片库。</li>
<li><a href="https://github.com/mozilla-services/react-jsonschema-form" target="_blank" rel="noopener">react-jsonschema-form</a> - Mozilla service 开源了一个通过 JSON 直接生成表单的 React 组件</li>
<li><a href="https://github.com/nosir/cleave.js" target="_blank" rel="noopener">cleave.js</a> - 用于在输入时格式化输入内容（信用卡格式、日期等）</li>
<li><a href="https://github.com/rikschennink/shiny" target="_blank" rel="noopener">shiny</a> - 在手机设备上模拟光的反射效果。 支持 DeviceMotion 事件</li>
<li><a href="https://github.com/cloudfetch/cloudquery" target="_blank" rel="noopener">cloudquery</a> - Turn any website to serverless API</li>
<li><a href="https://github.com/yujiangshui/A-Programmers-Guide-to-English" target="_blank" rel="noopener">A-Programmers-Guide-to-English</a> - 专为程序员编写的英语学习指南。</li>
<li><a href="https://github.com/rrweb-io/rrweb" target="_blank" rel="noopener">rrweb</a> - 一个可以记录你页面中所有操作的库</li>
<li><a href="https://github.com/ksky521/nodeppt" target="_blank" rel="noopener">nodeppt</a> - markdown 写 ppt</li>
<li><a href="https://github.com/nextapps-de/flexsearch" target="_blank" rel="noopener">flexsearch</a> - 能让你更加高效和快速的检索文本内容</li>
<li><a href="https://github.com/toddmotto/public-apis" target="_blank" rel="noopener">public-apis</a> - 汇集了市面上一些对外免费开放的 api，做一些自己练手 app 的时候很好用。</li>
<li><a href="https://github.com/appleple/scroll-hint" target="_blank" rel="noopener">scroll-hint</a> 用于提示用户页面可以左右滑动的一个提示库</li>
<li><a href="https://github.com/krisk/fuse" target="_blank" rel="noopener">fuse.js</a> 轻量级前端模糊查询库 非常的好用</li>
<li><a href="https://github.com/eligrey/FileSaver.js" target="_blank" rel="noopener">FileSaver.js</a> 文件下载插件 很多时候下载会有兼容性问题，它能帮你解决这些问题</li>
<li><a href="https://github.com/instantpage/instant.page" target="_blank" rel="noopener">instant.page</a> 一个判断用户行为 预测提前加载页面的库</li>
<li><a href="https://github.com/sindresorhus/screenfull.js" target="_blank" rel="noopener">screenfull.js</a> 浏览器全屏插件 解决了不少兼容性问题</li>
<li><a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener">VuePress</a> 本网站就是基于它实现的，简单方便的静态网站生成器</li>
<li><a href="https://github.com/Simonwep/selection" target="_blank" rel="noopener">selection</a> 可视化选择页面元素的库</li>
<li><a href="https://github.com/scroll-out/scroll-out" target="_blank" rel="noopener">scroll-out</a> 滚动效果（滚动视差）的框架，框架大小不到 1KB,使用回调的方式将相关动画元素的属性进行实时分配</li>
<li><a href="https://github.com/gpujs/gpu.js" target="_blank" rel="noopener">gpu.js</a> 通过将 js 转为特定的 language，利用 GPU 来执行，大大提高了执行性能和速度</li>
<li><a href="https://github.com/stuyam/pressure" target="_blank" rel="noopener">pressure</a> 前端实现 3D Touch</li>
<li><a href="https://github.com/hammerjs/hammer.js" target="_blank" rel="noopener">hammer</a> 移动端手势库</li>
<li><a href="https://github.com/AlloyTeam/AlloyFinger" target="_blank" rel="noopener">AlloyFinger</a> 腾讯出的手势库</li>
<li><a href="https://github.com/typicode/lowdb" target="_blank" rel="noopener">lowdb</a> LowDB 是一个本地 JSON 数据库，基于 Lodash 开发的</li>
<li><a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">JSON-server</a> 可以配合 LowDB 使用 快速搭建一个 REST API</li>
<li><a href="https://github.com/olivernn/lunr.js" target="_blank" rel="noopener">lunr.js</a> 是个用于浏览器的轻量级 JavaScript 全文搜索引擎,对于一些小型的博客、开发者文档或 Wiki 网站来说,完全可以通过它实现站内离线搜索</li>
<li><a href="https://github.com/mathiasbynens/he" target="_blank" rel="noopener">he</a> 一个前端 encoder/decoder 库</li>
<li><a href="https://github.com/benhowdle89/grade" target="_blank" rel="noopener">grade</a> 一个可以根据你的 图片 调整底色的插件</li>
<li><a href="https://github.com/sindresorhus/pretty-bytes" target="_blank" rel="noopener">pretty-bytes</a> 将字节转换成可以读的字符串，比如 1337 个字节，会显示成 1.34 KB</li>
</ul>
<h3 id="全景图"><a href="#全景图" class="headerlink" title="全景图"></a>全景图</h3><p><a href="https://www.jianshu.com/p/b227912b1d71" target="_blank" rel="noopener">krpano全景图</a><br><a href="https://krpano.milly.me/" target="_blank" rel="noopener">krpano文档</a></p>
<h3 id="Css-amp-动画"><a href="#Css-amp-动画" class="headerlink" title="Css &amp; 动画"></a>Css &amp; 动画</h3><ul>
<li><a href="https://github.com/daneden/animate.css" target="_blank" rel="noopener">animate.css</a> 最有名的动画效果库</li>
<li><a href="https://github.com/miniMAC/magic" target="_blank" rel="noopener">magic.css</a> css 动画效果库 类似 animate.css</li>
<li><a href="https://github.com/Popmotion/popmotion" target="_blank" rel="noopener">popmotion</a> 一个函数式声明前端动画库</li>
<li><a href="https://github.com/BcRikko/NES.css" target="_blank" rel="noopener">NES.css</a> 任天堂主题风格 css 库</li>
<li><a href="https://github.com/VincentGarreau/particles.js" target="_blank" rel="noopener">particles.js</a> 前端实现颗粒粒子的动画效果库，比较炫酷，但相对的也比较吃性能</li>
<li><a href="https://www.getpapercss.com/docs/" target="_blank" rel="noopener">PaperCSS</a> 手绘风格感觉 css 库</li>
<li><a href="https://github.com/pshihn/rough" target="_blank" rel="noopener">rough</a> 基于 Canvas 的手绘风格图形库</li>
<li><a href="https://github.com/wiredjs/wired-elements" target="_blank" rel="noopener">wired-elements</a> 基于 rough.js 分装 button input radio 等组件。它的底层是 Web components</li>
<li><a href="https://github.com/liabru/matter-js" target="_blank" rel="noopener">matter-js</a> web 物理引擎</li>
<li><a href="https://github.com/webkul/micron" target="_blank" rel="noopener">micron</a> 通过在元素上绑定属性从而实现动画效果的库</li>
<li><a href="https://github.com/NigelOToole/direction-reveal" target="_blank" rel="noopener">direction-reveal</a> 根据鼠标进入位置，展现从不同方向 展现 hover 效果</li>
<li><a href="https://github.com/alexfoxy/laxxx" target="_blank" rel="noopener">laxxx</a> 滚动特效库 轻量级 压缩完 2kb</li>
<li><a href="https://cssfx.dev/" target="_blank" rel="noopener">cssfx</a> 优雅的 CSS 动画效果，开箱即用</li>
<li><a href="https://github.com/metafizzy/zdog" target="_blank" rel="noopener">zdog</a> 3D engine 引擎</li>
</ul>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ul>
<li><a href="https://github.com/shentao/vue-multiselect" target="_blank" rel="noopener">vue-multiselect</a> select 组件 目前 vue 里面用过最好用的</li>
<li><a href="https://github.com/SortableJS/Vue.Draggable" target="_blank" rel="noopener">Vue.Draggable</a> DnD 拖拽组件 基于 Sortable.js 的 vue 版本</li>
<li><a href="https://github.com/Botre/vue-sauce" target="_blank" rel="noopener">vue-sauce</a> 一个可以展示 vue 源码的指令</li>
<li><a href="https://github.com/kutlugsahin/vue-smooth-dnd" target="_blank" rel="noopener">vue-smooth-dnd</a> Vue wrappers components for smooth-dnd</li>
<li><a href="https://github.com/vuegg/vuegg" target="_blank" rel="noopener">vuegg</a> 一个 vue 可视化拖拽界面生成器</li>
<li><a href="https://github.com/baianat/vee-validate" target="_blank" rel="noopener">vee-validate</a> 基于 vue 的验证，能验证的内容比较全</li>
<li><a href="https://github.com/lusaxweb/vuesax" target="_blank" rel="noopener">vuesax</a> 一个很漂亮的基于 vue 的 ui 框架</li>
<li><a href="https://github.com/MatteoGabriele/vue-analytics" target="_blank" rel="noopener">vue-analytics</a> 基于 vue 的 谷歌统计封装</li>
<li><a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener">vue-virtual-scroller</a> 基于 vue 的虚拟列表无限滚动</li>
<li><a href="https://github.com/michalsnik/vue-content-placeholders" target="_blank" rel="noopener">vue-content-placeholders</a> 页面龙骨 skeleton</li>
</ul>
<h3 id="实践库"><a href="#实践库" class="headerlink" title="实践库"></a>实践库</h3><ul>
<li><a href="https://github.com/Jasonette/JASONETTE-iOS" target="_blank" rel="noopener">Jasonette</a> 一个用 json 来构建 hybrid App 的框架</li>
<li><a href="https://github.com/atulmy/crate" target="_blank" rel="noopener">crate</a> 一个 react 全栈练习(pc,mobile,rn,api) demo，适合入门拿来练手</li>
<li><a href="https://github.com/krasimir/react-in-patterns" target="_blank" rel="noopener">react-in-patterns</a> 一本开源教你如何写 react 的书</li>
<li><a href="https://github.com/deepsweet/hocs" target="_blank" rel="noopener">hocs</a> react 相关 hoc 收集库</li>
</ul>
<h3 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h3><ul>
<li><a href="https://github.com/tapio/live-server" target="_blank" rel="noopener">live-server</a> 可以快速启一个本地 dev 服务 并且支持自动刷新的 http server</li>
<li><a href="https://github.com/zeit/serve" target="_blank" rel="noopener">serve</a> - 快速起本地静态服务</li>
<li><a href="https://github.com/tehnokv/picojs" target="_blank" rel="noopener">picojs</a> js 人脸识别库</li>
<li><a href="https://github.com/ruanyf/es-checker" target="_blank" rel="noopener">es-checker</a> 检查当前环境对 ES6 支持的情况。支持浏览器和 node.js</li>
<li><a href="https://github.com/lukechilds/merge-images" target="_blank" rel="noopener">merge-images</a> 图片合成，利用<code>canvas</code>能将几张图片合成一张</li>
<li><a href="https://github.com/fabricjs/fabric.js" target="_blank" rel="noopener">fabric.js</a> 基于 canvas 创建交互式的图片编辑界面非常适合用来做图片合成类工作。</li>
<li><a href="https://github.com/photonstorm/phaser" target="_blank" rel="noopener">phaser</a> 这是一个为桌面和移动浏览器开发 HTML5 游戏的快速开源框架。<br>你可以为 iOS、 Android 和不同的本地应用程序创建游戏。</li>
<li><a href="https://github.com/purifycss/purifycss" target="_blank" rel="noopener">purifycss</a> 移除没使用到的 css</li>
<li><a href="https://github.com/leeoniya/dropcss" target="_blank" rel="noopener">dropcss</a> 同上</li>
<li><a href="https://github.com/sindresorhus/fast-cli" target="_blank" rel="noopener">fast-cli</a> 命令行测试下载上传速度</li>
<li><a href="https://github.com/pikapkg/web" target="_blank" rel="noopener">@pika/web</a> 让你不需要在本地 webpack 中 import，直接在游览器里面运行 npm 包</li>
<li><a href="https://github.com/hotoo/pinyin" target="_blank" rel="noopener">pinyin</a> 汉字拼音转换工具</li>
<li><a href="https://obfuscator.io/" target="_blank" rel="noopener">JavaScript Obfuscator Tool</a> js 代码混淆工具</li>
<li><a href="https://github.com/naptha/tesseract.js" target="_blank" rel="noopener">tesseract</a> 图像识别，它能识别图片中的文字，支持中文</li>
<li><a href="https://github.com/gkajs/gka" target="_blank" rel="noopener">gka</a> 一款高效、高性能的帧动画生成工具。只需一行命令，快速图片优化、生成动画文件，支持效果预览。</li>
<li><a href="https://github.com/benjamn/recast" target="_blank" rel="noopener">recast</a> 前端 ast 库</li>
<li><a href="https://github.com/facebook/jscodeshift" target="_blank" rel="noopener">jscodeshift</a> 将 js 内容解析成 AST 语法树，然后提供一些便利的操作接口，方便我们对各个节点进行更改</li>
<li><a href="https://github.com/mrdoob/stats.js/" target="_blank" rel="noopener">stats.js</a> 前端性能监控 如 FPS、内存使用情况等</li>
<li><a href="https://github.com/mholt/PapaParse" target="_blank" rel="noopener">PapaParse</a> 解析 csv excel</li>
</ul>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ul>
<li><a href="https://github.com/nuxt/consola" target="_blank" rel="noopener">consola</a> 优雅的命令行 console <code>vuepress</code> 也使用了它</li>
<li><a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">cheerio</a> - 用类 jQuery 语法处理 HTML</li>
<li><a href="https://github.com/paulmillr/chokidar" target="_blank" rel="noopener">chokidar</a> - node 监听文件变化的库</li>
<li><a href="https://github.com/jprichardson/node-fs-extra" target="_blank" rel="noopener">fs-extra</a> - fs-extra 模块是系统 fs 模块的扩展，提供了更多便利的 API，并继承了 fs 模块的 API</li>
<li><a href="https://github.com/isaacs/rimraf" target="_blank" rel="noopener">rimraf</a> - 删除文件</li>
<li><a href="https://github.com/sindresorhus/globby" target="_blank" rel="noopener">globby</a> - 用于模式匹配目录文件</li>
<li><a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">glob</a> - 文件查找</li>
<li><a href="https://github.com/terkelg/tiny-glob" target="_blank" rel="noopener">tiny-glob</a> - 文件查找</li>
<li><a href="https://github.com/npm/node-semver" target="_blank" rel="noopener">node-semver</a> - node 版本验证库</li>
<li><a href="https://github.com/mysticatea/npm-run-all/blob/master/docs/node-api.md" target="_blank" rel="noopener">npm-run-all</a> - 一个 CLI 工具可以并行或者串行执行 script</li>
<li><a href="https://github.com/tapio/live-server" target="_blank" rel="noopener">live-server</a> - 一个简单的 http server 带有 reload 功能</li>
<li><a href="https://github.com/indexzero/node-portfinder" target="_blank" rel="noopener">node-portfinder</a> - 一个端口嗅探工具</li>
<li><a href="https://github.com/yeoman/update-notifier" target="_blank" rel="noopener">update-notifier</a> - Update notifications for your CLI app. cli 升级提醒工具</li>
<li><a href="https://github.com/yargs/y18n" target="_blank" rel="noopener">y18n</a> - yargs 基于 i18n 的一个包</li>
<li><a href="https://github.com/klauscfhq/signale" target="_blank" rel="noopener">signale</a> - Hackable console logger 一个 Node 的日志格式库，自带 16 个级别，可以定制颜色和 Emoji</li>
<li><a href="https://github.com/sindresorhus/execa" target="_blank" rel="noopener">execa</a> - A better <code>child_process</code></li>
<li><a href="https://github.com/SamVerschueren/listr" target="_blank" rel="noopener">listr</a> - Terminal task</li>
<li><a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">commander.js</a> - 自动的解析命令和参数，合并多选项，处理短参，等等，功能强大，上手简单</li>
<li><a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="noopener">Inquirer.js</a> - A collection of common interactive command line user interfaces. 命令行询问库</li>
<li><a href="https://github.com/nasa/openmct" target="_blank" rel="noopener">enquirer</a> - 命令行 prompt 询问库，写 cli 的时候很有用</li>
<li><a href="https://github.com/klaussinani/qoa" target="_blank" rel="noopener">Qoa</a> 同上</li>
<li><a href="https://github.com/sindresorhus/ora" target="_blank" rel="noopener">ora</a> - Elegant terminal spinner 命令行 loading</li>
<li><a href="https://github.com/chalk/chalk" target="_blank" rel="noopener">chalk</a> - 命令行着色美化库</li>
<li><a href="https://github.com/jondot/hygen" target="_blank" rel="noopener">hygen</a> - 快速方便的创建代码 可以命令行创建预设的 template</li>
<li><a href="https://github.com/GoogleChromeLabs/ndb" target="_blank" rel="noopener">ndb</a> - node 调试</li>
<li><a href="https://github.com/sindresorhus/got" target="_blank" rel="noopener">got</a> - http 请求库 如果你觉得 request 太多的话 这是一个不错的选择</li>
<li><a href="https://github.com/zeeshanu/dumper.js" target="_blank" rel="noopener">dumper.js</a> - 能让你的 node console 更加的规整，方便调试</li>
<li><a href="https://github.com/nswbmw/node-in-debugging" target="_blank" rel="noopener">node-in-debugging</a> - node.js 调试指南</li>
<li><a href="https://github.com/i0natan/nodebestpractices" target="_blank" rel="noopener">node-best-practices</a> - node 最佳实践</li>
<li><a href="https://github.com/pyloque/fastscan" target="_blank" rel="noopener">fastscan</a> - node 敏感词库</li>
<li><a href="https://github.com/antonmedv/fx" target="_blank" rel="noopener">fx</a> - 命令行优化 JSON 输出</li>
<li><a href="https://github.com/facebook/dataloader" target="_blank" rel="noopener">dataloader</a> - 解决 Graphql 中的 N+1 查询问题</li>
<li><a href="https://github.com/bvaughn/progress-estimator" target="_blank" rel="noopener">progress-estimator</a> - 命令行 progress bar 进度条模拟库</li>
<li><a href="https://github.com/i0natan/nodebestpractices/blob/master/README.chinese.md" target="_blank" rel="noopener">Node.js 最佳实践</a></li>
<li><a href="https://github.com/grpc/grpc-web" target="_blank" rel="noopener">grpc-web</a> - 前端直连 gRPC 服务</li>
<li><a href="https://github.com/bitinn/node-fetch" target="_blank" rel="noopener">node-fetch</a> - node 环境下轻量级 fetch 请求库</li>
<li><a href="https://github.com/vadimdemedes/ink" target="_blank" rel="noopener">ink</a> 是一个 React 的命令行渲染器，命令行界面可以像写页面那么写了</li>
<li><a href="https://github.com/strapi/strapi/" target="_blank" rel="noopener">strapi</a> 开源的解决方案来创建、部署和管理自己的 API</li>
<li><a href="https://github.com/SamVerschueren/listr" target="_blank" rel="noopener">listr</a> Terminal task list</li>
<li><a href="https://github.com/motdotla/dotenv" target="_blank" rel="noopener">dotenv</a> 通过.env 设置环境部变量 vue-cli 也依赖它</li>
</ul>
<h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h3><ul>
<li><a href="https://www.prisma.io/docs/" target="_blank" rel="noopener">prisma</a> - 让前端也能快速的写出</li>
<li><a href="https://www.apollographql.com/" target="_blank" rel="noopener">Apollo GraphQL</a> - 是基于 GraphQL 的全栈解决方案集合。从后端到前端提供了对应的 lib 使得开发使用 GraphQL 更加的方便</li>
</ul>
<h3 id="有趣"><a href="#有趣" class="headerlink" title="有趣"></a>有趣</h3><ul>
<li><a href="https://github.com/hendricius/the-bread-code" target="_blank" rel="noopener">the-bread-code</a> - 使用程序员的思维制作面包 ，比如制作中使用 A/B test,<br>来比较那种做法更好。</li>
<li><a href="https://github.com/danistefanovic/build-your-own-x" target="_blank" rel="noopener">build-your-own-x</a> - 教你用各种语言实现 Bot Database Neural Network</li>
<li><a href="https://github.com/trekhleb/javascript-algorithms" target="_blank" rel="noopener">javascript-algorithms </a> - 教你用前端知识认识各种算法</li>
<li><a href="https://github.com/kleampa/not-paid" target="_blank" rel="noopener">not-paid</a> - 如果你给人做网站，交过去以后对方没有付款，那么这个 JS 会把网站的透明度一天调低一点，直到看不见</li>
<li><a href="https://github.com/infinitered/nsfwjs" target="_blank" rel="noopener">nsfwjs</a> - 前端图片鉴黄，基于 Tensorflow</li>
<li><a href="https://github.com/tholman/elevator.js" target="_blank" rel="noopener">elevator.js</a> 我很喜欢的一个库，让一个 back-to-top 的效果有了一种坐复古电梯的感觉</li>
<li><a href="https://github.com/florinpop17/app-ideas" target="_blank" rel="noopener">app-ideas</a> 很多年轻人苦于缺少练手的项目，这个项目收集了不少点子，每个点子都有明确的目标和复杂资源。</li>
<li><a href="https://github.com/PavelDoGreat/WebGL-Fluid-Simulation" target="_blank" rel="noopener">WebGL-Fluid-Simulation</a> 很酷的 WebGL 交互</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li><a href="https://github.com/high-speed-downloader/high-speed-downloader" target="_blank" rel="noopener">high-speed-downloader</a> - 百度网盘不限速下载 支持 Windows 和 Mac</li>
<li><a href="https://github.com/zeit/hyper" target="_blank" rel="noopener">hyper</a> - 前端命令行</li>
<li><a href="https://github.com/ymfe/yapi" target="_blank" rel="noopener">yapi</a> - 是一个可本地部署的、打通前后端及 QA 的、可视化的接口管理平台</li>
<li><a href="https://sway.com/" target="_blank" rel="noopener">sway</a> - 一个微软自己出的在线 ppt 很强大</li>
<li><a href="http://bigjpg.com/" target="_blank" rel="noopener">bigjpg</a> - 放大图片的神器 通过神经网络可以放大图片并能降噪</li>
<li><a href="https://asciiartgen.now.sh" target="_blank" rel="noopener">Ascii Art Generator</a> - 在线生成 Ascii 图案</li>
<li><a href="https://github.com/GetStream/Winds" target="_blank" rel="noopener">Winds</a> - 开源 RSS</li>
<li><a href="https://github.com/kitze/JSUI" target="_blank" rel="noopener">JSUI</a> - 一个用来控制管理前端项目的客户端</li>
<li><a href="https://github.com/pedronauck/docz" target="_blank" rel="noopener">docz</a> - 让你能快速写文档的一个库</li>
<li><a href="https://github.com/pod4g/hiper" target="_blank" rel="noopener">hiper</a> - 性能统计分析工具</li>
<li><a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">verdaccio</a> - 私有 npm</li>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git-guide</a> - git 入门指南</li>
<li><a href="https://github.com/521xueweihan/git-tips" target="_blank" rel="noopener">git-tips</a> - git 进阶</li>
<li><a href="https://github.com/teambit/bit" target="_blank" rel="noopener">bit</a> - 实现了项目之间的代码共享 可以自建私有</li>
<li><a href="https://github.com/Kenshin/simpread" target="_blank" rel="noopener">simpread</a> - 简悦 ( SimpRead ) 让你瞬间进入沉浸式阅读的扩展</li>
<li><a href="https://github.com/FiloSottile/mkcert" target="_blank" rel="noopener">mkcert</a> - 一键命令 让本地也支持 https</li>
<li><a href="https://github.com/nbedos/termtosvg" target="_blank" rel="noopener">termtosvg</a> - 录制 命令操作转成 svg 基于 python</li>
<li><a href="https://github.com/apex/gh-polls" target="_blank" rel="noopener">gh-polls</a> - 可以在 github issue 中添加投票</li>
<li><a href="https://github.com/liriliri/eruda" target="_blank" rel="noopener">eruda</a> - 移动端调试工具</li>
<li><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">vConsole</a> - 也是一个移动端调试工具 腾讯出品</li>
<li><a href="https://github.com/faressoft/terminalizer" target="_blank" rel="noopener">terminalizer</a> - 命令行录制工具 基于 node</li>
<li><a href="https://github.com/amio/badgen-service" target="_blank" rel="noopener">badgen</a> - 快速构建和 shields 一样的 svg badge 但速度更快</li>
<li><a href="https://github.com/luin/readability" target="_blank" rel="noopener">readability</a> - 移除页面非正文部分 基于 jsdom</li>
<li><a href="https://github.com/TKkk-iOSer/WeChatPlugin-MacOS" target="_blank" rel="noopener">WeChatPlugin-MacOS</a> - 一款功能强大的 macOS 版微信小助手</li>
<li><a href="https://github.com/checkly/puppeteer-recorder" target="_blank" rel="noopener">puppeteer-recorder</a> - 一个 chrome 插件 能够根据你的操作 自动生成 puppeteer 相关代码</li>
<li><a href="https://github.com/jxnblk/mdx-deck" target="_blank" rel="noopener">mdx-deck</a> - 用 markdown 编写演示文稿</li>
<li><a href="https://github.com/pomber/code-surfer" target="_blank" rel="noopener">code-surfer</a> - 基于 mdx-deck 的一个插件<br>让你更好的在文稿中展示 code</li>
<li><a href="https://progressivetooling.com/" target="_blank" rel="noopener">Progressive Tooling</a> - 前端性能优化工具集合</li>
<li><a href="https://github.com/artf/grapesjs" target="_blank" rel="noopener">https://github.com/artf/grapesjs</a> - 可视化建站工具 不需要写代码就能写一个页面，前端再次再次要下岗了</li>
<li><a href="https://www.image-charts.com/" target="_blank" rel="noopener">image-charts</a> - 该服务通过 URL 接受参数，然后生成图表，以图片形式返回</li>
<li><a href="https://github.com/Zulko/eagle.js" target="_blank" rel="noopener">eagle.js</a> - 一个用 vue 来制作 PPT 的库</li>
<li><a href="https://www.optimizely.com/" target="_blank" rel="noopener">Optimizely</a> - A/B Test</li>
<li><a href="http://www.appadhoc.com/" target="_blank" rel="noopener">appadhoc</a> - 一个国内的 A/B Test 服务</li>
<li><a href="https://github.com/glorious-codes/glorious-demo" target="_blank" rel="noopener">glorious-demo</a> - 通过编写代码的方式构建一个命令行的演示例子</li>
<li><a href="https://github.com/valentinxxx/nginxconfig.io/" target="_blank" rel="noopener">nginxconfig</a> - 可视化配置 nginx 提供了多个基础模板</li>
<li><a href="https://bundlephobia.com/" target="_blank" rel="noopener">bundlephobia</a> - 一个可以查看某个库的大小，并且分析它的依赖</li>
<li><a href="https://jsperf.com/popular" target="_blank" rel="noopener">jsperf</a> - 一个提供在线 test case 的网站，主要用来比较性能。可以比较如： forEach vs for 的性能</li>
<li><a href="https://github.com/lukejacksonn/perflink" target="_blank" rel="noopener">perflink</a> 与 jsperf 类似的一个比较 js 性能的网站</li>
<li><a href="https://github.com/algorithm-visualizer/algorithm-visualizer" target="_blank" rel="noopener">algorithm-visualizer</a> - 算法代码可视化</li>
<li><a href="https://github.com/yujiangshui/An-English-Guide-for-Programmers" target="_blank" rel="noopener">An-English-Guide-for-Programmers</a> - 专为程序员编写的英语学习指南</li>
<li><a href="https://webhint.io/" target="_blank" rel="noopener">Webhint</a> - 用于检查代码的可访问性、性能和安全的开源检查（Linting）工具</li>
<li><a href="https://github.com/airtap/airtap" target="_blank" rel="noopener">airtap</a> - 测试浏览器兼容性，可覆盖 800 多种浏览器</li>
<li><a href="https://github.com/bluzi/jsonstore" target="_blank" rel="noopener">jsonstore</a> - 供免费，安全且基于 JSON 的云数据存储，自己玩的小项目神器</li>
<li><a href="https://github.com/pomber/git-history" target="_blank" rel="noopener">git-history</a> - 可视化查看一个文件的历史变化</li>
<li><a href="https://github.com/myliang/x-spreadsheet" target="_blank" rel="noopener">x-spreadsheet</a> 一个基于 Canvas 的 JS 电子表格库 excel</li>
<li><a href="https://imgcook.taobao.org/" target="_blank" rel="noopener">imgcook</a> 阿里出品，一键通过设计稿生成代码</li>
<li><a href="https://github.com/Raathigesh/majestic" target="_blank" rel="noopener">majestic</a> jest 可视化</li>
<li><a href="https://github.com/leon-ai/leon" target="_blank" rel="noopener">leon</a> 你开源项目的 ai 个人助手</li>
<li><a href="https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart" target="_blank" rel="noopener">js-code-to-svg-flowchart</a> 将代码逻辑用流程图的方式展现出来</li>
<li><a href="https://github.com/xtermjs/xterm.js" target="_blank" rel="noopener">xterm.js</a> 一个 web terminal</li>
<li><a href="https://github.com/mapbox/pixelmatch" target="_blank" rel="noopener">pixelmatch</a> diff 两张图片不一样的地方</li>
<li><a href="https://github.com/kefranabg/readme-md-generator" target="_blank" rel="noopener">readme-md-generator</a> 一个命令行脚本帮你快速的创建一个 README</li>
</ul>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><ul>
<li><a href="https://github.com/nuxt/webpackbar" target="_blank" rel="noopener">webpackbar</a> webpack 打包进度可视化</li>
<li><a href="https://github.com/zouhir/jarvis" target="_blank" rel="noopener">jarvis</a> webpack dashboard</li>
<li><a href="https://github.com/neutrinojs/webpack-chain" target="_blank" rel="noopener">webpack-chain</a> 通过 chain 风格 api 的方式修改 webpack 配置</li>
<li><a href="https://github.com/stephencookdev/speed-measure-webpack-plugin" target="_blank" rel="noopener">speed-measure-webpack-plugin</a> 探测 webpack 各阶段的耗时</li>
<li><a href="https://github.com/ElemeFE/obsolete-webpack-plugin" target="_blank" rel="noopener">obsolete-webpack-plugin</a> 基于 browserslist 做浏览器升级提示</li>
<li><a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a> 提取 CSS 为单独文件</li>
<li><a href="https://github.com/webpack-contrib/copy-webpack-plugin" target="_blank" rel="noopener">copy-webpack-plugin</a> 复制额外的文件到输出目录</li>
<li><a href="https://github.com/darrenscerri/duplicate-package-checker-webpack-plugin" target="_blank" rel="noopener">duplicate-package-checker-webpack-plugin</a> 检查是否存在重复依赖</li>
</ul>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><ul>
<li><a href="https://itunes.apple.com/cn/app/get-plain-text/" target="_blank" rel="noopener">get-plain-text</a> - 能清除剪贴板里的格式 很实用</li>
<li><a href="https://github.com/lhc70000/iina" target="_blank" rel="noopener">IINA</a> - mac 平台感觉免费最好的播放器 强推</li>
<li><a href="https://itunes.apple.com/cn/app/magnet/id441258766?mt=12&ign-mpt=uo%3D4" target="_blank" rel="noopener">magnet</a> - 分屏管理</li>
<li><a href="https://zh.xnipapp.com/" target="_blank" rel="noopener">Xnip</a> - 方便好用的截图工具-支持截长图</li>
<li><a href="https://www.spectacleapp.com/" target="_blank" rel="noopener">Spectacle</a> - 窗口管理工具</li>
<li><a href="https://matthewpalmer.net/vanilla/" target="_blank" rel="noopener">vanilla</a> - 顶栏图标管理工具</li>
<li><a href="https://github.com/Mortennn/Dozer" target="_blank" rel="noopener">Dozer</a> - 一个开源的顶栏管理</li>
<li><a href="https://mac.guanjia.qq.com/index_o.html" target="_blank" rel="noopener">腾讯电脑管家</a> - 反正我用下来好觉得蛮好用的</li>
<li><a href="https://mos.caldis.me/" target="_blank" rel="noopener">mos</a> - 鼠标平滑滚动软件，很好用。免费开源</li>
<li><a href="https://www.sequelpro.com/" target="_blank" rel="noopener">sequel pro</a> - mysql 客户端 好用</li>
<li><a href="https://itunes.apple.com/us/app/microsoft-remote-desktop/id715768417?mt=12#" target="_blank" rel="noopener">Microsoft Remote Desktop Beta</a> - Mac 远程登录 Windows 调试神器</li>
<li><a href="http://paper.meiyuan.in/" target="_blank" rel="noopener">pap.er</a> - 专为 Mac 设计的壁纸应用</li>
<li><a href="https://theunarchiver.com/" target="_blank" rel="noopener">The Unarchive</a> - Mac 目前感觉最好用的免费解压软件</li>
<li><a href="https://github.com/yingDev/Tickeys" target="_blank" rel="noopener">Tickeys</a> - 让你用 Mac 键盘也能打出机械键盘的感觉</li>
<li><a href="https://github.com/beakerbrowser/beaker" target="_blank" rel="noopener">Beaker Browser</a> - P2P 开源浏览器 支持点对点发布文件，成为了文件传输工具，支持 DAT 对等协议</li>
<li><a href="https://github.com/sindresorhus/gifski-app" target="_blank" rel="noopener">Gifski</a> - 视频转 gif 工具</li>
<li><a href="https://github.com/serhii-londar/open-source-mac-os-apps" target="_blank" rel="noopener">more</a> - 更多优秀的 mac app 介绍</li>
<li><a href="https://github.com/agalwood/Motrix" target="_blank" rel="noopener">Motrix</a> - 支持 HTTP、FTP、BT、磁力链、百度网盘的下载工具</li>
</ul>
<h3 id="Chrome-拓展"><a href="#Chrome-拓展" class="headerlink" title="Chrome 拓展"></a>Chrome 拓展</h3><ul>
<li><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">Tampermonkey</a> 油猴 神器</li>
<li><a href="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco/related?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">扩展管理器</a> 轻松管理扩展，就不用担心安装太多扩展了</li>
<li><a href="https://github.com/GoogleChromeLabs/ProjectVisBug" target="_blank" rel="noopener">visbug</a> 它可以帮助你改变 css，移动元素等等一系类强大的功能,页面调试神器。当然有些时候还是 DevTools 更好用</li>
<li><a href="https://github.com/sindresorhus/refined-github" target="_blank" rel="noopener">refined-github</a> 优化 github 默认功能和样式的 chrome 插件</li>
<li><a href="https://chrome.google.com/webstore/detail/adb/dpngiggdglpdnjdoaefidgiigpemgage" target="_blank" rel="noopener">ADB</a> chrome 真机调试安卓神器</li>
<li><a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb" target="_blank" rel="noopener">Adblock Plus</a><br>免费广告拦截程序 这个应该不用说了，装机必备</li>
<li><a href="https://chrome.google.com/webstore/detail/axure-rp-extension-for-ch/dogkpdfcklifaemcdfbildhcofnopogp" target="_blank" rel="noopener">Axure RP Extension</a> 看原型必备</li>
<li><a href="https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa" target="_blank" rel="noopener">JSON Formatter</a> JSON 格式化 程序员必备</li>
<li><a href="https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk" target="_blank" rel="noopener">Lighthouse</a> 谷歌出品，检查网页综合性能评分，分析不足</li>
<li><a href="https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8qr-code-generato/pflgjjogbmmcmfhfcnlohagkablhbpmg" target="_blank" rel="noopener">二维码(QR 码)生成器</a> 手机扫码神器</li>
<li><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="noopener">Octotree</a> github 上看代码必备神器</li>
<li><a href="https://chrome.google.com/webstore/detail/octolinker/jlmafbaeoofdegohdhinkhilhclaklkp" target="_blank" rel="noopener">OctoLinker</a> 能在 github 上看代码的时候 快速链接跳转到依赖的库</li>
<li><a href="https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg" target="_blank" rel="noopener">The Great Suspender</a> chrome 太吃内存了，当页面开的很多时候会很卡，它就完美的解决了这个问题。它将几分钟没浏览过的页面都挂载了，当你想看是再重新加载</li>
<li><a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad" target="_blank" rel="noopener">WEB 前端助手</a> 支持 JSON 格式化、二维码生成与解码、代码压缩、Markdown 与 HTML 互转、网页滚动截屏、正则表达式、时间转换工具、JSON 比对工具等</li>
<li><a href="https://chrome.google.com/webstore/detail/%E6%8E%98%E9%87%91/lecdifefmmfjnjjinhaennhdlmcaeeeb" target="_blank" rel="noopener">掘金</a> 目前我默认新开 tab 的默认页，可以刷刷新的文章或者项目，还不错。</li>
<li><a href="https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg" target="_blank" rel="noopener">沙拉查词</a> 划词翻译插件</li>
<li><a href="https://github.com/npmhub/npmhub" target="_blank" rel="noopener">npmhub</a>在 README 下方显示 npm 依赖信息</li>
</ul>
<h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost" target="_blank" rel="noopener">Import Cost</a> 查看你引入的依赖模块大小</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag" target="_blank" rel="noopener">Auto Close Tag</a> 自动补全 html 标签，如输入<code>&lt;a&gt;</code>将自动补全<code>&lt;/a&gt;</code></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag" target="_blank" rel="noopener">Auto Rename Tag</a> 自动重命名 html 标签，如修改<code>&lt;a&gt;为&lt;b&gt;</code>，将自动修改结尾标签<code>&lt;/a&gt;为&lt;/b&gt;</code></li>
<li><a href="https://github.com/octref/polacode" target="_blank" rel="noopener">polacode</a> 生产代码图片快照插件</li>
<li><a href="https://github.com/jdneo/vscode-leetcode" target="_blank" rel="noopener">vscode-leetcode</a> - 一个能让你在 vscode 中刷 LeetCode 的插件 算一个划水神器吧</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=robertohuertasm.vscode-icons" target="_blank" rel="noopener">vscode-icons</a> VS Code 必备吧，为文件添加炫图标</li>
</ul>
<h3 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h3><ul>
<li><a href="https://github.com/lerna/lerna" target="_blank" rel="noopener">lerna</a> - monorepo 管理。</li>
<li><a href="https://github.com/lerna/lerna-changelog" target="_blank" rel="noopener">lerna-changelog</a> - 为 lerna 项目自动生成 changelog。</li>
<li><a href="https://github.com/eslint/eslint" target="_blank" rel="noopener">eslint</a> - JS 风格约束。</li>
<li><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">eslint-config-airbnb</a></li>
<li><a href="https://github.com/xojs/xo" target="_blank" rel="noopener">xo</a> - 封装自 eslint。</li>
<li><a href="https://github.com/prettier/prettier" target="_blank" rel="noopener">prettier</a> - 更主观的风格自动修改。</li>
<li><a href="https://github.com/yeoman/generator" target="_blank" rel="noopener">yeoman-generator</a> - 脚手架工具。</li>
<li><a href="https://github.com/zeit/serve" target="_blank" rel="noopener">serve</a> - 本地静态服务器。</li>
<li><a href="https://github.com/sindresorhus/np" target="_blank" rel="noopener">np</a> - npm publish 辅助，自动 push、打 tag、升版本等。</li>
<li><a href="https://github.com/okonet/lint-staged" target="_blank" rel="noopener">lint-staged</a> - eslint 提速，只 lint 提交的代码。</li>
<li><a href="https://github.com/marketplace/coveralls" target="_blank" rel="noopener">coveralls</a> - 覆盖率。</li>
<li><a href="https://github.com/typicode/husky" target="_blank" rel="noopener">husky</a> - 添加 git hooks。</li>
<li><a href="https://github.com/kentcdodds/cross-env" target="_blank" rel="noopener">cross-env</a> - 跨平台的环境变量声明。</li>
<li><a href="https://github.com/popomore/projj" target="_blank" rel="noopener">projj</a> - 本地 git 项目管理，支持 github 和 gitlab。</li>
<li><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a> - 管理 node 版本。</li>
<li><a href="https://github.com/kimmobrunfeldt/concurrently" target="_blank" rel="noopener">concurrently</a> -在 npm scripts 里并行执行命令。</li>
<li><a href="https://github.com/zeit/ncc" target="_blank" rel="noopener">@zeit/ncc</a> - 打包为 npm 包为一个文件。</li>
<li><a href="https://github.com/dylang/npm-check" target="_blank" rel="noopener">npm-check</a> - 检测依赖升级情况，我会和 <code>yarn upgrade-interactive</code> 配合着用，主要用来检测冗余依赖。</li>
<li><a href="https://github.com/mysticatea/cpx" target="_blank" rel="noopener">cpx</a> - 复制，支持 glob，并且可以 watch。</li>
<li><a href="https://github.com/Qard/onchange" target="_blank" rel="noopener">onchange</a> - 监听文件变动然后做一些事。</li>
</ul>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>实用库</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC整理</title>
    <url>/2019/01/16/tools/mac/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>MAC整理</strong></p>
<p>[[toc]]</p>
<h3 id="MAC整理"><a href="#MAC整理" class="headerlink" title="MAC整理"></a>MAC整理</h3><h3 id="配置sudo免密码"><a href="#配置sudo免密码" class="headerlink" title="配置sudo免密码"></a>配置sudo免密码</h3><p><a href="https://blog.csdn.net/u011046452/article/details/90140936" target="_blank" rel="noopener">创建root账户</a></p>
<p><code>1.</code> 需要在/etc/sudoers中配置。<br><br/><br>这个文件的权限是只读，配置之前需要加写权限。<br><br/><br><code>sudo chmod u+w /etc/sudoers</code></p>
<p><code>2.</code> 打开命令窗口<br><code>sudo visudo 或者 sudo vi /etc/sudoers</code></p>
<p>按i(insert)开启插入编辑模式</p>
<p><code>将 #%admin ALL=(ALL) ALL
替换为 %admin ALL=(ALL) NOPASSWD: ALL</code></p>
<p>修改后按esc键，退出编辑模式，最后按住Shift+ ZZ 保存退出</p>
<p><code>3.</code> 既然原来权限是r/r/只读的,修改之后最好也改回来。</p>
<p><code>sudo chmod u-w /etc/sudoers</code></p>
<h3 id="sudo报错信息-etc-sudoers-is-world-writable"><a href="#sudo报错信息-etc-sudoers-is-world-writable" class="headerlink" title="sudo报错信息 /etc/sudoers is world writable"></a>sudo报错信息 /etc/sudoers is world writable</h3><p>::: danger 错误信息</p>
<p>sudo: /etc/sudoers is world writable<br><br/><br>sudo: no valid sudoers sources found, quitting<br><br/><br>sudo: unable to initialize policy plugin</p>
<p>:::</p>
<p>今天误操作修改了/etc/sudoers的权限，将它的权限改成了777，结果就导致执行所有sudo的命令都报错。<br><br/><br><code>sudo: /etc/sudoers is world writable
sudo: no valid sudoers sources found, quitting</code><br><br/><br>想重新把它的权限修改回去，但是执行<code>chmod 440 /etc/sudoers</code>后却发现报错为：<br><br/><br><code>chmod: Unable to change file mode on /etc/sudoers: Operation not permitted</code><br><br/><br>这就尴尬了，改不回去。<br><br/><br>最后通过疯狂的百度谷歌，找到了一些解决方法，但是有些方法说的太简单了，还是走了好多冤枉路，现总结如下：<br><br/><br><code>1.</code> 在Mac中启动root账户 <a href="https://jingyan.baidu.com/article/49711c619e7620fa441b7ca8.html" target="_blank" rel="noopener">启动root</a><br><br/><br><code>2.</code> 切换到root用户，修改 /etc/sudoers的权限<br><br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 无法使用chmod修改权限</span><br><span class="line">ls -la &#x2F;etc&#x2F;sudoers</span><br><span class="line">-rwxrwxrwx  1 root  wheel  1371  8  9 11:28 &#x2F;etc&#x2F;sudoers</span><br><span class="line">chmod 440 &#x2F;etc&#x2F;sudoers</span><br><span class="line">chmod: Unable to change file mode on &#x2F;etc&#x2F;sudoers: Operation not permitted</span><br><span class="line"></span><br><span class="line"># 切换到root用户</span><br><span class="line"> su</span><br><span class="line">Password:你自己设置的密码</span><br><span class="line">sh-3.2# ls -l &#x2F;etc&#x2F;sudoers</span><br><span class="line">-rwxrwxrwx  1 root  wheel  1371  8  9 11:28 &#x2F;etc&#x2F;sudoers</span><br><span class="line">sh-3.2# chmod 0440 &#x2F;etc&#x2F;sudoers</span><br><span class="line">sh-3.2# ls -l &#x2F;etc&#x2F;sudoers</span><br><span class="line">-r--r-----  1 root  wheel  1371  8  9 11:28 &#x2F;etc&#x2F;sudoers</span><br><span class="line">sh-3.2# exit</span><br></pre></td></tr></table></figure>

<h3 id="mac下安装Homebrew"><a href="#mac下安装Homebrew" class="headerlink" title="mac下安装Homebrew"></a>mac下安装Homebrew</h3><p>安装 <a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Homebrew</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用方式</span><br><span class="line"># 安装 wget  </span><br><span class="line">brew install wget</span><br><span class="line"># 安装 yum   </span><br><span class="line">brew install yum</span><br></pre></td></tr></table></figure>


<h3 id="mac安装autojump"><a href="#mac安装autojump" class="headerlink" title="mac安装autojump"></a>mac安装autojump</h3><p>要知道autojump是什么，我们得先来了解一下shell，bash和zsh。<br><br/></p>
<p><strong>shell</strong>就是我们经常说的shell命令，其实就是一个c语言编写的程序，用户在命令行键入命令，经过shell解释后传送给操作系统（内核）执行。</p>
<p><strong>1. bash</strong></p>
<p>bash (Bourne-Again Shell) 是大多数Linux系统以及Mac OS X默认的shell，换句话说，bash是shell的实例。</p>
<p><strong>2. zsh</strong></p>
<p>虽然Linux和Mac OS X默认使用的几乎都是bash，但真正强大的shell其实是深藏不露的zsh，俗称终极shell。它兼容了bash，还有各种强大的功能</p>
<p><strong>autojump</strong></p>
<p>autojump是一个命令行工具，它可以使用快捷命令，直接跳转到配置好的目录，而不用管现在身在何处，依赖zsh。</p>
<p><code>echo $SHELL</code>可以查看用的哪个shell（bash or zsh）</p>
<p>查看系统安装的所有shell有哪些 <code>cat /etc/shells</code></p>
<p>将zsh设置成默认的shell：<code>chsh -s /bin/zsh</code> (重启shell)</p>
<p>安装autojump：<code>brew install autojump</code>（确保有brew）</p>
<p>使用<code>vim .zshrc</code>打开.zshrc（有些人会找不到.zshrc这个文件，其实安装了zsh才会有.zshrc ，在默认打开的终端目录下。可以打开终端并且ls -a查看）。</p>
<p>a. 找到 plugins=，在后面添加autojump：<code>plugins=(git autojump)</code></p>
<p>b. 新开一行，添加：<code>[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.sh</code></p>
<p>c. :wq保存退出，重启终端。</p>
<h3 id="Mac-终端-oh-my-zsh-配置"><a href="#Mac-终端-oh-my-zsh-配置" class="headerlink" title="Mac 终端 oh-my-zsh 配置"></a>Mac 终端 oh-my-zsh 配置</h3><p>Mac 终端默认 shell 为 <code>bash</code>。</p>
<p>主要介绍使用 zsh 以及 oh-my-zsh 的配置。</p>
<p><strong>使用 zsh</strong></p>
<p>查看当前使用的 shell</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="variable">$SHELL</span></span><br><span class="line"><span class="comment"># /bin/bash</span></span><br></pre></td></tr></table></figure>
<p><strong>使用 brew 更新 zsh</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">brew</span> install zsh</span><br></pre></td></tr></table></figure>

<p><strong>切换为 zsh</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">chsh</span> -s /bin/zsh <span class="comment"># 重启shell</span></span><br></pre></td></tr></table></figure>

<p>重启终端即可使用 <code>zsh</code></p>
<p><strong>1.安装</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sh</span> -c <span class="string">"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</span></span><br></pre></td></tr></table></figure>

<p><strong>2.主题</strong></p>
<p><code>vim ~/.zshrc</code></p>
<p>配置项 <code>ZSH_THEME</code> 即为 oh-my-zsh 的主题配置，oh-my-zsh 的 GitHub Wiki 页面提供了 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="noopener">主题列表</a></p>
<p>更新配置<code>source ~/.zshrc</code></p>
<p><strong>3.自动补全插件</strong></p>
<p><a href="http://mimosa-pudica.net/src/incr-0.2.zsh" target="_blank" rel="noopener">下载 incr 自动补全插件</a></p>
<p>将插件放在 oh-my-zsh 自定义插件目录中 <code>~/.oh-my-zsh/custom/plugins</code></p>
<p>在配置文件结束添加：</p>
<p><code>source $ZSH/custom/plugins/incr/incr*.zsh</code></p>
<p>更新配置<code>source ~/.zshrc</code></p>
<p><strong>4.自动提示功能插件</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> clone git://github.com/zsh-users/zsh-autosuggestions <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  <span class="attribute">git</span> </span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>更新配置<code>source ~/.zshrc</code></p>
<p><strong>5.安装zsh-syntax-highlighting语法高亮插件</strong></p>
<p><a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">官网</a></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> clone https://github.com/zsh-users/zsh-syntax-highlighting.git </span><br><span class="line">echo <span class="string">"source <span class="variable">$&#123;(q-)PWD&#125;</span>/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"</span> &gt;&gt; <span class="variable">$&#123;ZDOTDIR:-$HOME&#125;</span>/.zshrc</span><br></pre></td></tr></table></figure>
<p>更新配置<code>source ~/.zshrc</code></p>
<p><strong>在编辑器内配置</strong></p>
<p>在终端配置好后，打开编辑器发现仍是bash，</p>
<p>在您喜欢的编辑器中打开您的bashrc文件</p>
<p><code>sudo vim  ~/.bash_profile</code></p>
<p>然后添加文件顶部添加</p>
<p><code>exec zsh</code></p>
<p>每次加载终端并运行zsh shell时，它都会执行命令。</p>
<h3 id="mac下sshpass-不能使用"><a href="#mac下sshpass-不能使用" class="headerlink" title="mac下sshpass 不能使用"></a>mac下sshpass 不能使用</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在官网下载源码包（最新的是1.06)</span></span><br><span class="line"><span class="attribute">wget</span> https://sourceforge.net/projects/sshpass/files/sshpass/1.06/sshpass-1.06.tar.gz/download</span><br><span class="line"># 解压</span><br><span class="line">tar xvzf sshpass-<span class="number">1</span>.<span class="number">05</span>.tar.gz</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">./configure</span><br><span class="line"><span class="comment"># 如果此处失败安装 **xcode-select –install**</span></span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h3 id="mac设置git的分支记录"><a href="#mac设置git的分支记录" class="headerlink" title="mac设置git的分支记录"></a>mac设置git的分支记录</h3><p><code>基于bash,zsh下不能使用</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.进入你的home目录</span></span><br><span class="line"><span class="attribute">cd</span> ~</span><br><span class="line"><span class="comment"># 2.编辑.bash_profile</span></span><br><span class="line">vi .bash_profile</span><br><span class="line"><span class="comment"># 3.将下面的代码加入到文件的最后处</span></span><br><span class="line"></span><br><span class="line">find_git_branch () &#123;</span><br><span class="line">    <span class="attribute">local</span> dir=. head</span><br><span class="line">    until [ "$dir" -ef / ]; do</span><br><span class="line">        if [ -f "$dir/.git/HEAD" ]; then</span><br><span class="line">            head=$(&lt; "$dir/.git/HEAD")</span><br><span class="line">            if [[ $head = ref:\ refs/heads/* ]]; then</span><br><span class="line">                git_branch=" → $&#123;head#*/*/&#125;"</span><br><span class="line">            elif [[ $head != '' ]]; then</span><br><span class="line">                git_branch=" → (detached)"</span><br><span class="line">            else</span><br><span class="line">                git_branch=" → (unknow)"</span><br><span class="line">            fi</span><br><span class="line">            return</span><br><span class="line">        fi</span><br><span class="line">        dir="../$dir"</span><br><span class="line">    done</span><br><span class="line">    git_branch=''</span><br><span class="line">&#125;</span><br><span class="line">PROMPT_COMMAND="find_git_branch; $PROMPT_COMMAND"</span><br><span class="line">black=$'\[\e[1;30m\]'</span><br><span class="line">red=$'\[\e[1;31m\]'</span><br><span class="line">green=$'\[\e[1;32m\]'</span><br><span class="line">yellow=$'\[\e[1;33m\]'</span><br><span class="line">blue=$'\[\e[1;34m\]'</span><br><span class="line">magenta=$'\[\e[1;35m\]'</span><br><span class="line">cyan=$'\[\e[1;36m\]'</span><br><span class="line">white=$'\[\e[1;37m\]'</span><br><span class="line">normal=$'\[\e[m\]'</span><br><span class="line"></span><br><span class="line">PS1="$white[$magenta\u$white@$green\h$white:$cyan\w$yellow\$git_branch$white]\$ $normal"</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.保存退出</span></span><br><span class="line"><span class="comment"># 5.执行加载命令</span></span><br><span class="line"><span class="attribute">source</span> .bash_profile</span><br><span class="line"><span class="comment"># 6.完成</span></span><br></pre></td></tr></table></figure>

<h3 id="允许安装未知来源"><a href="#允许安装未知来源" class="headerlink" title="允许安装未知来源"></a>允许安装未知来源</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> spctl --master-disable</span><br></pre></td></tr></table></figure>

<h3 id="微信助手"><a href="#微信助手" class="headerlink" title="微信助手"></a>微信助手</h3><p>跳转这个链接，有教程，<a href="https://github.com/lmk123/oh-my-wechat#oh-my-wechat" target="_blank" rel="noopener">https://github.com/lmk123/oh-my-wechat#oh-my-wechat</a></p>
<h3 id="添加WebStrom的主题"><a href="#添加WebStrom的主题" class="headerlink" title="添加WebStrom的主题"></a>添加WebStrom的主题</h3><p>先到这里下载喜欢的主题<a href="http://color-themes.com/?view=index" target="_blank" rel="noopener">http://color-themes.com/?view=index</a></p>
<p>然后打开ws,左上角打开<code>File-&gt; Import Settings-&gt;选择jar文件</code></p>
<h3 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h3><p><strong>添加<code>code+文件</code>打开VSCode</strong></p>
<p>安装code：打开VSCode –&gt; command+shift+p –&gt; 输入shell command –&gt; 点击提示Shell Command: Install ‘code’ command in PATH运行</p>
]]></content>
      <categories>
        <category>Other</category>
        <category>MAC整理</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>BFC</title>
    <url>/2018/01/20/workspace/Css/bfc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>BFC</strong></p>
<p><strong>如何创建BFC</strong></p>
<ul>
<li>float的值不是none。</li>
<li>position的值不是static或者relative。</li>
<li>display的值是inline-block、table-cell、flex、table-caption或者inline-flex</li>
<li>overflow的值不是visible</li>
</ul>
<p><strong>BFC的作用</strong></p>
<ul>
<li>利用BFC避免margin重叠。</li>
<li>自适应两栏布局</li>
<li>清除浮动</li>
</ul>
<p><strong>实现一个三栏布局</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    *&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 150px;</span><br><span class="line">        float: left;</span><br><span class="line">        background: rgb(139, 214, 78);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        float: right;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background: rgb(170, 54, 236);  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">        overflow: hidden;</span><br><span class="line">        background: red;  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><a href="https://blog.csdn.net/sinat_36422236/article/details/88763187" target="_blank" rel="noopener">https://blog.csdn.net/sinat_36422236/article/details/88763187</a></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css的两种盒模型</title>
    <url>/2019/01/21/workspace/Css/box-sizing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>[[toc]]</p>
<h3 id="css的两种盒模型"><a href="#css的两种盒模型" class="headerlink" title="css的两种盒模型"></a>css的两种盒模型</h3><h4 id="W3C的标准盒模型"><a href="#W3C的标准盒模型" class="headerlink" title="W3C的标准盒模型"></a>W3C的标准盒模型</h4><p>默认是w3c标准的</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H8a671283100a4512ba5ae28cdfe70b3b6.jpg" alt="仔细看图"></p>
<blockquote>
<p>在标准的盒子模型中，width指content部分的宽度</p>
</blockquote>
<h4 id="IE的盒模型"><a href="#IE的盒模型" class="headerlink" title="IE的盒模型"></a>IE的盒模型</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H113065c568374278958356d8834155a1x.jpg" alt="仔细看图"></p>
<blockquote>
<p>在IE盒子模型中，width表示content+padding+border这三个部分的宽度</p>
</blockquote>
<h4 id="box-sizing的使用"><a href="#box-sizing的使用" class="headerlink" title="box-sizing的使用"></a>box-sizing的使用</h4><p>如果想要切换盒模型也很简单，这里需要借助css3的box-sizing属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">box-sizing: content-box  <span class="comment">//是W3C盒子模型</span></span><br><span class="line">box-sizing: border-box <span class="comment">//是IE盒子模型</span></span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>css盒模型<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.content</span> &#123;</span></span><br><span class="line">	width: 300px;</span><br><span class="line">	height: 400px;</span><br><span class="line"><span class="css">	<span class="selector-tag">border</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#242424</span>;</span></span><br><span class="line">	padding: 20px;</span><br><span class="line"><span class="css">	<span class="selector-tag">background-color</span>: <span class="selector-id">#898989</span>;</span></span><br><span class="line"><span class="css">   <span class="comment">/*box-sizing: border-box;*/</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>清除浮动的最常用的几种方法</title>
    <url>/2018/01/20/workspace/Css/clearfix/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>清除浮动的最常用的几种方法</strong></p>
<p>[[toc]]</p>
<p><strong>为什么要清除浮动？</strong></p>
<p>清除浮动主要是为了解决，父元素因为子级元素浮动引起的内部高度为0的问题</p>
<h3 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h3><p>在最后一个浮动标签后，新加一个标签，给其设置clear：both；（不推荐）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.clear&#123;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clear"</span>&gt;</span>额外标签法<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="父级添加overflow属性"><a href="#父级添加overflow属性" class="headerlink" title="父级添加overflow属性"></a>父级添加overflow属性</h3><p>通过触发BFC的方式，实现清楚浮动效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">   overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素,局限性太大</p>
<h3 id="使用after伪元素清除浮动"><a href="#使用after伪元素清除浮动" class="headerlink" title="使用after伪元素清除浮动 **"></a>使用after伪元素清除浮动 **</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;<span class="comment">/*伪元素是行内元素 正常浏览器清除浮动方法*/</span></span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用before和after双伪元素清除浮动"><a href="#使用before和after双伪元素清除浮动" class="headerlink" title="使用before和after双伪元素清除浮动 **"></a>使用before和after双伪元素清除浮动 **</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css的模块化</title>
    <url>/2018/01/20/workspace/Css/cssModules/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>css的模块化</strong></p>
<p><code>1</code>. 关于less使用建议</p>
<pre><code>1、过渡的嵌套会导致很多问题发生，使代码变得更复杂，而且太过依赖于HTML结构，这样后面要覆盖样式需要依赖于&quot;!important&quot;，而这种方式又是我们尽量避免使用的一种

2、嵌套层级不应该超过三层

3、嵌套层级编译出来的CSS，要确保其简洁，可重用

4、使用嵌套很有意义，但并不意味着无限级的嵌套</code></pre><p><code>2</code>.这玩意的好处</p>
<pre><code>解决CSS中的全局作用域问题。说白了就是解决不同页面样式冲突的问题
保留了很好的组件复用性 （composes）
很方便的按需加载</code></pre><p><code>3</code>.启用css modules 只需在webpack中使用css-loader，下面为less中使用</p>
<pre><code>`使用cssmodules后改变css,浏览器会自动刷新,因为他是基于对象的，之前直接写less的时候，需要手动的`</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//@Lynn 这里我开启自己编写的less文件的css modules功能 除了node_modules库中的less</span></span><br><span class="line"><span class="comment">//也就是可以过滤掉antd库中的样式</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">  exclude: [<span class="regexp">/node_modules/</span>],</span><br><span class="line">  use: [</span><br><span class="line">      <span class="built_in">require</span>.resolve(<span class="string">'style-loader'</span>),</span><br><span class="line">      &#123;</span><br><span class="line">          loader: <span class="built_in">require</span>.resolve(<span class="string">'css-loader'</span>),</span><br><span class="line">          options: &#123;</span><br><span class="line">              modules: <span class="literal">true</span>,</span><br><span class="line">              localIndexName:<span class="string">"[name]__[local]___[hash:base64:5]"</span></span><br><span class="line">          &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          loader: <span class="built_in">require</span>.resolve(<span class="string">'less-loader'</span>), <span class="comment">// compiles Less to CSS</span></span><br><span class="line">      &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>4</code>.    在智慧社区里面使用：<br>    1. 对于局部css   采用[name]. module.[less | css]，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//这个是在config/webpack.config.dev.js里面定义了</span></span><br><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">use: [</span><br><span class="line">  <span class="built_in">require</span>.resolve(<span class="string">'style-loader'</span>),</span><br><span class="line">  (&#123;resource&#125;) =&gt; (&#123;</span><br><span class="line">    loader: <span class="string">'css-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      importLoaders: <span class="number">1</span>,</span><br><span class="line">      modules: <span class="regexp">/\.module\.less/</span>.test(resource),</span><br><span class="line">      localIdentName: <span class="string">'[name]__[local]___[hash:base64:5]'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">  &#123;</span><br><span class="line">    loader: <span class="built_in">require</span>.resolve(<span class="string">'postcss-loader'</span>),</span><br><span class="line">    options: &#123;</span><br><span class="line">      ident: <span class="string">'postcss'</span>, <span class="comment">// https://webpack.js.org/guides/migrating/#complex-options</span></span><br><span class="line">      plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'postcss-flexbugs-fixes'</span>),</span><br><span class="line">        autoprefixer(&#123;</span><br><span class="line">          browsers: [</span><br><span class="line">            <span class="string">'&gt;1%'</span>,</span><br><span class="line">            <span class="string">'last 4 versions'</span>,</span><br><span class="line">            <span class="string">'Firefox ESR'</span>,</span><br><span class="line">            <span class="string">'not ie &lt; 9'</span>, <span class="comment">// React doesn't support IE8 anyway</span></span><br><span class="line">          ],</span><br><span class="line">          flexbox: <span class="string">'no-2009'</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    loader: <span class="built_in">require</span>.resolve(<span class="string">'less-loader'</span>),</span><br><span class="line">    options: &#123;</span><br><span class="line">      modifyVars: theme,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>2. 定义全局样式，直接在css|less文件加入:global：</code></pre><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义多个全局样式 */</span></span><br><span class="line">	<span class="selector-pseudo">:global</span> &#123;</span><br><span class="line">	  .link &#123;</span><br><span class="line">	    <span class="selector-tag">color</span>: <span class="selector-tag">green</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="selector-class">.box</span> &#123;</span><br><span class="line">	    <span class="attribute">color</span>: yellow;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<pre><code>3. 对于组件的引入</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* components&#x2F;Button.css *&#x2F;</span><br><span class="line">.base &#123; &#x2F;* 所有通用的样式 *&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">.normal &#123;</span><br><span class="line">  composes: base;</span><br><span class="line">  &#x2F;* normal 其它样式 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.disabled &#123;</span><br><span class="line">  composes: base;</span><br><span class="line">  &#x2F;* disabled 其它样式 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">import styles from &#39;.&#x2F;Button.css&#39;;</span><br><span class="line"></span><br><span class="line">buttonElem.outerHTML &#x3D; &#96;&lt;button class&#x3D;$&#123;styles.normal&#125;&gt;Submit&lt;&#x2F;button&gt;&#96;</span><br></pre></td></tr></table></figure>




<pre><code>4.css modules的局限：
1.class名必须是驼峰形式，否则不能正常在js里使用 styles.table 来引用 对此的解决方法</code></pre><figure class="highlight"><table><tr><td class="code"><pre><span class="line">className=&#123;styles['tree-component-header']</span><br></pre></td></tr></table></figure>
<pre><code>2.由于css模块化是默认，当你希望使用正常的全局css时，需要通过:local 和 :global 切换，不方便
3.所有的 className 都必须使用 {style.className} 的形式


5.composes 关键词</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//css</span></span><br><span class="line">  .serif-font &#123;</span><br><span class="line">      font-family: Georgia,serif;</span><br><span class="line">  &#125;</span><br><span class="line">  .display &#123;</span><br><span class="line">     composes: serif-font;</span><br><span class="line">      font-size: <span class="number">30</span>px;</span><br><span class="line">      line-height: <span class="number">35</span>px;</span><br><span class="line">  &#125;&#125;</span><br><span class="line"> <span class="comment">//组件</span></span><br><span class="line"> <span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">"./type.css"</span>;</span><br><span class="line"> element.innerHTML = </span><br><span class="line"> <span class="string">`</span></span><br><span class="line"><span class="string">     &lt;h1 class=&#123;styles.display&#125;&gt;</span></span><br><span class="line"><span class="string">         This is a heading</span></span><br><span class="line"><span class="string">     &lt;/h1&gt;`</span></span><br><span class="line">     </span><br><span class="line"> <span class="comment">//浏览器</span></span><br><span class="line"> &lt;h1 <span class="class"><span class="keyword">class</span></span>=<span class="string">"_type__display_0980340 _type_serif_404840"</span>&gt;</span><br><span class="line">     This is a heading</span><br><span class="line"> &lt;<span class="regexp">/h1&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>最后配上我自己设置的cssModules</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> test: lessRegex,</span><br><span class="line"> exclude: lessModuleRegex,</span><br><span class="line"> use: getStyleLoaders(</span><br><span class="line">     &#123;</span><br><span class="line">       importLoaders: <span class="number">2</span>,</span><br><span class="line">       modules: <span class="literal">true</span>,</span><br><span class="line">         localIdentName: <span class="string">'[path][name]-[local]-[hash:base64:5]'</span>,</span><br><span class="line">       sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="string">'less-loader'</span></span><br><span class="line"> ),</span><br><span class="line"> sideEffects: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详情看：</p>
<p><code>1</code>. <a href="https://www.jianshu.com/p/51ff1c8be301" target="_blank" rel="noopener">如何在react中使用antd+less+css modules</a><br/><br><code>2</code>. <a href="https://zhuanlan.zhihu.com/p/20495964" target="_blank" rel="noopener">具体使用 结合classnames</a><br/><br><code>3</code>. <a href="https://zhuanlan.zhihu.com/p/20495964" target="_blank" rel="noopener">CSS Modules 详解及 React 中实践</a></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS使用指南</title>
    <url>/2017/01/16/workspace/Css/css/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>CSS使用指南</strong></p>
<p>[[toc]]</p>
<div style="margin-left: -6px; margin-right: -6px;">
    <div class="el-col-6" style="padding-left: 6px; padding-right: 6px;">
        <div class="demo-color-box" style="background: #409EFF;">
        Brand Color
        <div class="value">#409EFF</div>
        </div>
    </div>
     <div class="el-col-6" style="padding-left: 6px; padding-right: 6px;">
        <div class="demo-color-box" style="background: rgb(103, 194, 58);">
        Success
        <div class="value">#67C23A</div>
        </div>
    </div>
    <div class="el-col-6 " style="padding-left: 6px; padding-right: 6px;">
        <div class="demo-color-box" style="background: rgb(230, 162, 60);">
        Warning
        <div class="value">#E6A23C</div>
        </div>
    </div>
    <div class="el-col-6" style="padding-left: 6px; padding-right: 6px;">
        <div class="demo-color-box" style="background: rgb(245, 108, 108);">
        Danger
        <div class="value">#F56C6C</div>
        </div>
    </div>
    <div class="el-col-6 " style="padding-left: 6px; padding-right: 6px;">
        <div class="demo-color-box" style="background: rgb(144, 147, 153);">
        Info
        <div class="value">#909399</div>
        </div>
    </div>
    <div style="padding-left: 6px; padding-right: 6px">
         <div class="demo-color-box" style="background: linear-gradient(to right,#fcb045,#fd1d1d,#833ab4);">
          渐变 
          <div class="value">✎ linear-gradient(to right,#fcb045,#fd1d1d,#833ab4)</div>
         </div>
    </div>
 </div>



<h3 id="calc方法"><a href="#calc方法" class="headerlink" title="calc方法"></a>calc方法</h3><ul>
<li>html{ font-size: calc(1em + 1vw); }</li>
</ul>
<p> <strong>less</strong>下</p>
<ul>
<li>e(“calc(100% - 260px)”) </li>
<li>calc(~”100% - 30px”)</li>
</ul>
<h3 id="animate动画-停在动画最后的的那个画面"><a href="#animate动画-停在动画最后的的那个画面" class="headerlink" title="animate动画-停在动画最后的的那个画面"></a>animate动画-停在动画最后的的那个画面</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">downIn</span> 0<span class="selector-class">.5s</span>;</span><br><span class="line"><span class="selector-tag">animation-fill-mode</span>: <span class="selector-tag">forwards</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> downIn &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;<span class="attribute">top</span>: -<span class="number">88px</span>&#125;;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;<span class="attribute">top</span>: <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nth-child-amp-nth-of-type"><a href="#nth-child-amp-nth-of-type" class="headerlink" title="nth-child() &amp; nth-of-type()"></a>nth-child() &amp; nth-of-type()</h3><p><strong>:nth-child(n)</strong> 选择器匹配父元素和属于其父元素的第N个子元素，<code>不论元素的类型</code>。</p>
<p><strong>:nth-of-type(n)</strong> 选择器匹配和父元素属于父元素的<code>特定类型</code>的第N个子元素的每个元素。</p>
<p><strong>nth-last-child()</strong> 从后面开始，类似nth-child()</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:coral;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:lightblue;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> // nth-of-type(2)</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:khaki;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  // nth-child(6)</span><br></pre></td></tr></table></figure>

<h3 id="超出隐藏"><a href="#超出隐藏" class="headerlink" title="超出隐藏"></a>超出隐藏</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.info</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  //不太实用，任何时候都有...</span><br><span class="line">  <span class="selector-tag">content</span>: "";</span><br><span class="line">  <span class="selector-tag">font-weight</span>: <span class="selector-tag">bold</span>;</span><br><span class="line">  <span class="selector-tag">text-align</span>: <span class="selector-tag">right</span>;</span><br><span class="line">  <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">  <span class="selector-tag">bottom</span>: 0;</span><br><span class="line">  <span class="selector-tag">right</span>: 0;</span><br><span class="line">  <span class="selector-tag">width</span>: 90<span class="selector-tag">px</span>;</span><br><span class="line">  <span class="selector-tag">height</span>: 16<span class="selector-tag">px</span>;</span><br><span class="line">  <span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">rgba</span>(255, 255, 255, 0), <span class="selector-tag">rgba</span>(255, 255, 255, 1) 50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多行超出隐藏"><a href="#多行超出隐藏" class="headerlink" title="多行超出隐藏"></a>多行超出隐藏</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.info</span>&#123;</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">  <span class="attribute">-webkit-line-clamp</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三角形-旋转三角效果-0-5像素的线"><a href="#三角形-旋转三角效果-0-5像素的线" class="headerlink" title="三角形 | 旋转三角效果 | 0.5像素的线"></a>三角形 | 旋转三角效果 | 0.5像素的线</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> &amp;<span class="selector-pseudo">:nth-child(1)</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">45%</span>);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">6px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#FD5E4E</span> transparent transparent transparent;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-id">#72B4FD</span>;</span><br><span class="line"><span class="selector-tag">width</span>: 100%;</span><br><span class="line"><span class="selector-tag">height</span>: 100%;</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">top</span>: 0;</span><br><span class="line"><span class="selector-tag">right</span>: <span class="selector-tag">-0</span><span class="selector-class">.23rem</span>;</span><br><span class="line"><span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">skewX</span>(<span class="selector-tag">-20deg</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skewX</span>(<span class="selector-tag">-20deg</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&amp; <span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">236px</span>;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">11px</span> <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  &amp;:after &#123;</span><br><span class="line">    <span class="selector-tag">content</span>: "";</span><br><span class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">    <span class="selector-tag">bottom</span>: 0;</span><br><span class="line">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span><br><span class="line">    <span class="selector-tag">width</span>: 100%;</span><br><span class="line">    <span class="selector-tag">height</span>: 1<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scaleY</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">transform</span>: <span class="selector-tag">scaleY</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">-webkit-transform-origin</span>: 0 0;</span><br><span class="line">    <span class="selector-tag">transform-origin</span>: 0 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="loading"><a href="#loading" class="headerlink" title="loading"></a>loading</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.loading</span></span><br><span class="line">    <span class="selector-tag">width</span>: 159<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="selector-tag">height</span>: 151<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="selector-tag">margin</span>: 0 <span class="selector-tag">auto</span>;</span><br><span class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line"> <span class="selector-class">.loading</span><span class="selector-pseudo">::before</span>,<span class="selector-class">.loading</span><span class="selector-pseudo">::after</span></span><br><span class="line">    content: '';</span><br><span class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">    <span class="selector-tag">width</span>: 0<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="selector-tag">height</span>: 0<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="selector-tag">background</span>: <span class="selector-tag">black</span>;</span><br><span class="line">    <span class="selector-tag">border-radius</span>: 50%;</span><br><span class="line">    <span class="selector-tag">top</span><span class="selector-pseudo">:0</span>;      </span><br><span class="line">    <span class="selector-tag">bottom</span>: 0;</span><br><span class="line">    <span class="selector-tag">left</span>: 0;</span><br><span class="line">    <span class="selector-tag">right</span>: 0;</span><br><span class="line">    <span class="selector-tag">margin</span>: <span class="selector-tag">auto</span>;   <span class="comment">/*上下左右都为0，再加上margin:auto; 就是自动居中*/</span></span><br><span class="line">    <span class="selector-tag">animation</span>: <span class="selector-tag">s</span> 1<span class="selector-class">.5s</span> <span class="selector-tag">linear</span> <span class="selector-tag">infinite</span>;  <span class="comment">/*加上s状态，状态开始到结束为1.5s*/</span></span><br><span class="line"><span class="selector-class">.loading</span><span class="selector-pseudo">::after</span></span><br><span class="line">    <span class="selector-tag">animation-delay</span>: 0<span class="selector-class">.75s</span>;     <span class="comment">/*第二个圆出现的时间*/</span></span><br><span class="line">    </span><br><span class="line"> <span class="keyword">@keyframes</span> s&#123;</span><br><span class="line">    0%&#123;             <span class="comment">/*初始状态*/</span></span><br><span class="line">        <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>; <span class="comment">/*透明度*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    100%&#123;           <span class="comment">/*结束状态*/</span></span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伪类面包屑"><a href="#伪类面包屑" class="headerlink" title="伪类面包屑"></a>伪类面包屑</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;ul class="breadcrumb"&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href="#"&gt;Pictures&lt;/a&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href="#"&gt;Summer 15&lt;/a&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;Italy&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.breadcrumb</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.breadcrumb</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.breadcrumb</span> <span class="selector-tag">li</span>+<span class="selector-tag">li</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"/\00a0"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.breadcrumb</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">const elm = document.documentElement</span><br><span class="line">//全局控制 </span><br><span class="line"><span class="selector-tag">elm</span><span class="selector-class">.style</span><span class="selector-class">.setProperty</span>("<span class="selector-tag">background-color</span>", "<span class="selector-tag">yellow</span>");</span><br></pre></td></tr></table></figure>

<h3 id="Css的两种盒模型"><a href="#Css的两种盒模型" class="headerlink" title="Css的两种盒模型"></a>Css的两种盒模型</h3><p><a href="/2019/01/21/workspace/Css/box-sizing/">Css的两种盒模型</a> </p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p><a href="/2018/01/20/workspace/Css/clearfix/">清除浮动的几种方法</a></p>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><a href="/2018/01/20/workspace/Css/bfc/">bfc详解</a></p>
<h3 id="CSS九宫格布局实现"><a href="#CSS九宫格布局实现" class="headerlink" title="CSS九宫格布局实现"></a>CSS九宫格布局实现</h3><p><a href="/2018/01/20/workspace/Css/lattice/">CSS九宫格布局实现</a></p>
<h3 id="CSS实现正六边形"><a href="#CSS实现正六边形" class="headerlink" title="CSS实现正六边形"></a>CSS实现正六边形</h3><p><a href="https://github.com/web-tiki/responsive-grid-of-hexagons" target="_blank" rel="noopener">github</a></p>
<h3 id="移动端viewport"><a href="#移动端viewport" class="headerlink" title="移动端viewport"></a>移动端viewport</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,viewport-fit=cover"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">content属性值 :</span><br><span class="line">width:可视区域的宽度，值可为数字或关键词device-width</span><br><span class="line">height:同width</span><br><span class="line">intial-scale:页面首次被显示是可视区域的缩放级别，取值1.0则页面按实际尺寸显示，无任何缩放</span><br><span class="line">maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0;可视区域的缩放级别，</span><br><span class="line">maximum-scale用户可将页面放大的程序，1.0将禁止用户放大到实际尺寸之上。</span><br><span class="line">user-scalable:是否可对页面进行缩放，no 禁止缩放</span><br><span class="line">viewport-fit&#x3D;cover：兼容iPhoneX刘海全屏</span><br></pre></td></tr></table></figure>

<h3 id="移动端1px很粗的问题"><a href="#移动端1px很粗的问题" class="headerlink" title="移动端1px很粗的问题"></a>移动端1px很粗的问题</h3><p>在做移动端开发时,设计师提供的视觉稿一般是750px,当你定义 border-width:1px时,在iphone6手机上却发现:边框变粗了。<br>这是因为,1px是相对于750px的(物理像素),而我们定义的1px是相对于375px的(css像素)“实际上应该是border-width:0.5px”.</p>
<p><strong>关于物理像素和独立像素</strong></p>
<p>物理像素<br/><br>移动设备出厂时,不同设备自带的不同像素,也称硬件像素;</p>
<p>独立像素<br/><br>即css中记录的像素。</p>
<p><strong>手机屏幕分为：</strong></p>
<p>一：非视网膜屏幕 （物理像素375，该设备的独立像素（视区宽度）也是375）<br/><br>二：视网膜屏幕  （物理像素是750，该设备的独立的独立像素还是375）</p>
<p><code>px都会受哪些因素的影响而变化？</code></p>
<ul>
<li>像素密度(pixel per inch, PPI)</li>
<li>设备像素比(device pixel ratio, DPR)</li>
</ul>
<p><strong>PPI</strong></p>
<p>每英寸物理像素点数），更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况,放到显示器上说的是每英寸多少物理像素或显示器设备的点距。</p>
<p><strong>DPR</strong></p>
<p>设备像素比 ＝ 物理像素 / 设备独立像素</p>
<p>通俗点讲：<strong>设备像素比(dpr)</strong> 是指在移动开发同一方向上（x轴或y轴）中1个css像素占用多少设备像素，</p>
<p>如视网膜屏幕 dpr = 2，代表1个css像素用2x2个设备像素来绘制。</p>
<p>在 JavaScript 中，可以通过window.devicePixelRatio获取到当前设备的 dpr。<br>而在 CSS 中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和-webkit-max-device-pixel-ratio进行媒体查询。</p>
<p>我们可以在运行的时候拿到设备的devicePixelRatio，动态改变viewport的initial-scale为 1/devicePixelRatio，<br>这样就能保证1px的宽度就是真正的1物理像素宽，其他适配使用rem（因为使用px的话都会被缩小）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clientWidth = <span class="built_in">window</span>.screen.width;</span><br><span class="line">  <span class="keyword">var</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line">  <span class="keyword">var</span> vp = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>);</span><br><span class="line">  <span class="built_in">document</span>.documentElement.style.fontSize = clientWidth &gt; <span class="number">414</span> ? <span class="string">'20px'</span> : <span class="number">20</span> * dpr * clientWidth / <span class="number">360</span> + <span class="string">'px'</span>;</span><br><span class="line">  vp.name = <span class="string">'viewport'</span>;</span><br><span class="line">  vp.content = <span class="string">`initial-scale=<span class="subst">$&#123;<span class="number">1.0</span> * <span class="number">1</span> <span class="regexp">/ dpr&#125;, maximum-scale=$&#123;1.0 * 1 /</span> dpr&#125;</span>, minimum-scale=<span class="subst">$&#123;<span class="number">1.0</span> * <span class="number">1</span> <span class="regexp">/ dpr&#125;, user-scalable=no, width=device-width`;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">  var m = document.getElementsByTagName('meta')[0];</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">  m.parentNode.insertBefore(vp, m);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">  </span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">  /</span><span class="regexp">/ var vp = document.getElementsByTagName('meta')[1];</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">  /</span><span class="regexp">/ vp.content = `initial-scale=$&#123;1.0 * 1 /</span> dpr&#125;</span>, maximum-scale=<span class="subst">$&#123;<span class="number">1.0</span> * <span class="number">1</span> <span class="regexp">/ dpr&#125;, minimum-scale=$&#123;1.0 * 1 /</span> dpr&#125;</span>, user-scalable=no, width=device-width`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/maqingbo/p/7528861/" target="_blank" rel="noopener">https://www.cnblogs.com/maqingbo/p/7528861/</a></p>
<h3 id="rem原理"><a href="#rem原理" class="headerlink" title="rem原理"></a>rem原理</h3><p>rem布局的本质是<code>等比缩放</code>，一般是基于宽度，假设将屏幕宽度分为100份，每份宽度是1rem，1rem的宽度是屏幕宽度/100,，然后子元素设置rem单位的属性，<br>通过改变html元素的字体大小，就可以设置子元素的实际大小。<br>rem布局加载闪烁的问题</p>
<p>解决方案，媒体查询设置根元素字体大小，比如设计稿是750px;对应的开发方式是1rem=100px,那375px的font-size 大小就是50px（具体方法可以百度一下）</p>
<p>比rem更好的方案（缺点兼容不好）</p>
<p>vw(1vw是视口宽度的1%，100vw就是视口宽度),vh(100vh就是视口高度)</p>
<h3 id="scss-Mixins"><a href="#scss-Mixins" class="headerlink" title="scss Mixins"></a>scss Mixins</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">$warning: #ead1a6;</span><br><span class="line">$danger: #f44f4d;</span><br><span class="line"></span><br><span class="line">$dpr: 2 !default;</span><br><span class="line"><span class="keyword">@function</span> second($val) &#123;</span><br><span class="line">  <span class="keyword">@return</span> round($val * $dpr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* methods</span></span><br><span class="line"><span class="comment">-------------------------- */</span></span><br><span class="line">// 背景图片地址和大小</span><br><span class="line"><span class="keyword">@mixin</span> bg($url) &#123;</span><br><span class="line">  background-image: url($url);</span><br><span class="line">  <span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>;</span><br><span class="line">  <span class="selector-tag">background-size</span>: 100% 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定位上下左右居中</span><br><span class="line"><span class="keyword">@mixin</span> center &#123;</span><br><span class="line">  <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">  <span class="selector-tag">top</span>: 50%;</span><br><span class="line">  <span class="selector-tag">left</span>: 50%;</span><br><span class="line">  <span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(<span class="selector-tag">-50</span>%, <span class="selector-tag">-50</span>%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定位上下居中</span><br><span class="line"><span class="keyword">@mixin</span> ct &#123;</span><br><span class="line">  <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">  <span class="selector-tag">top</span>: 50%;</span><br><span class="line">  <span class="selector-tag">transform</span>: <span class="selector-tag">translateY</span>(<span class="selector-tag">-50</span>%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定位左右居中</span><br><span class="line"><span class="keyword">@mixin</span> cl &#123;</span><br><span class="line">  <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">  <span class="selector-tag">left</span>: 50%;</span><br><span class="line">  <span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(<span class="selector-tag">-50</span>%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//多行显示省略号</span><br><span class="line"><span class="keyword">@mixin</span> noWrapline($<span class="attribute">line:</span><span class="number">2</span>) &#123;</span><br><span class="line">  <span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line">  -webkit-line-clamp: $line;</span><br><span class="line">  <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line">  <span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line">  <span class="comment">/*! autoprefixer: off */</span></span><br><span class="line">  <span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br><span class="line">  <span class="comment">/* autoprefixer: on */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// flex 布局和 子元素 对其方式</span><br><span class="line"><span class="keyword">@mixin</span> fj($<span class="attribute">type:</span> space-between) &#123;</span><br><span class="line">  <span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br><span class="line">  justify-content: $type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//用法</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"> @include fj(center);</span><br><span class="line"> background: $page-bg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="less-Mixins"><a href="#less-Mixins" class="headerlink" title="less Mixins"></a>less Mixins</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &#39;~antd&#x2F;es&#x2F;style&#x2F;themes&#x2F;default.less&#39;;</span><br><span class="line"></span><br><span class="line">@pro-header-hover-bg: rgba(0, 0, 0, 0.025);</span><br><span class="line"></span><br><span class="line">@blue: #3190e8;</span><br><span class="line">@bc: #e4e4e4;</span><br><span class="line">@fc:#fff;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 背景图片地址和大小</span><br><span class="line">.bis(@url) &#123;</span><br><span class="line">  background-image: url(@url);</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-size: 100% 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定位全屏</span><br><span class="line">.allcover&#123;</span><br><span class="line">  position:absolute;</span><br><span class="line">  top:0;</span><br><span class="line">  right:0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 水平垂直居中</span><br><span class="line">.center () &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定位上下居中</span><br><span class="line">.tb &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  transform: translateY(-50%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定位左右居中</span><br><span class="line">.lr &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translateX(-50%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;单行显示省略号</span><br><span class="line">.noWrap &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;多行显示省略号</span><br><span class="line">.noWrapline(@line) &#123;</span><br><span class="line">  display: -webkit-box;</span><br><span class="line">  -webkit-line-clamp: @line;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  &#x2F;*! autoprefixer: off *&#x2F;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  &#x2F;* autoprefixer: on *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用法</span><br><span class="line">.ant-menu-item-selected &#123;</span><br><span class="line">  .center;</span><br><span class="line">  background-color: @all-color </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">### cssModules</span><br><span class="line"></span><br><span class="line">[cssModules](&#x2F;2018&#x2F;01&#x2F;20&#x2F;workspace&#x2F;Css&#x2F;cssModules&#x2F;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### ✄ Flex弹性布局</span><br><span class="line"></span><br><span class="line">[Flex弹性布局](&#x2F;2018&#x2F;01&#x2F;20&#x2F;workspace&#x2F;Css&#x2F;flex&#x2F;)</span><br><span class="line"></span><br><span class="line">### PostCSS</span><br><span class="line"></span><br><span class="line">**什么是postcss**</span><br><span class="line"></span><br><span class="line">postcss 一种对css编译的工具，类似babel对js的处理，常见的功能如：&lt;br&#x2F;&gt;</span><br><span class="line">1.使用下一代css语法&lt;br&#x2F;&gt;</span><br><span class="line">2.自动补全浏览器前缀&lt;br&#x2F;&gt;</span><br><span class="line">3.自动把px代为转换成rem&lt;br&#x2F;&gt;</span><br><span class="line">4.css代码压缩等等&lt;br&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">**如何使用**</span><br><span class="line"></span><br><span class="line">这里只说在webpack里集成使用，首先需要 loader</span><br><span class="line"></span><br><span class="line">&#96;sudo yarn add -D postcss-loader  postcss-preset-env&#96;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;javascript</span><br><span class="line"> &#123;</span><br><span class="line">    loader: require.resolve(&#39;postcss-loader&#39;),</span><br><span class="line">    options: &#123;</span><br><span class="line">        ident: &#39;postcss&#39;,</span><br><span class="line">        plugins: () &#x3D;&gt; [</span><br><span class="line">            require(&#39;postcss-flexbugs-fixes&#39;),</span><br><span class="line">            require(&#39;postcss-preset-env&#39;)(&#123;</span><br><span class="line">                autoprefixer: &#123;</span><br><span class="line">                    flexbox: &#39;no-2009&#39;,</span><br><span class="line">                &#125;,</span><br><span class="line">                stage: 3,</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>postcss-flexbugs-fixes  修复Flexbugs<br/></li>
<li>postcss-preset-env  将现代CSS转换成浏览器能理解的东西【安装postcss-preset-env，无需再安装autoprefixer，由于postcss-preset-env已经内置了相关功能。】<br/></li>
<li>postcss-cssnext  使用下个版本的css语法；如css4（可以理解为css中的Babel）</li>
<li>postcss-sprites 自动制作雪碧图，不用手动拼接啦</li>
<li>postcss-hash-classname 把转换后的css文件名附上哈希值</li>
<li>postcss-pxtorem  把px转换成rem</li>
<li>pixrem 将rem转换为px</li>
<li>postcss-px-to-viewport 把px转换成viewport单位【viewport-units-buggyfill(vw的兼容处理)】</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   plugins: &#123;</span><br><span class="line">       <span class="string">'postcss-px-to-viewport'</span>: &#123;</span><br><span class="line">           viewportWidth: <span class="number">750</span>,   <span class="comment">// 视窗的宽度，对应的是我们设计稿的宽度，一般是750</span></span><br><span class="line">           viewportHeight: <span class="number">1334</span>, <span class="comment">// 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置</span></span><br><span class="line">           unitPrecision: <span class="number">3</span>,     <span class="comment">// 指定`px`转换为视窗单位值的小数位数</span></span><br><span class="line">           viewportUnit: <span class="string">"vw"</span>,   <span class="comment">//指定需要转换成的视窗单位，建议使用vw</span></span><br><span class="line">           selectorBlackList: [<span class="string">'.ignore'</span>],<span class="comment">// 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名</span></span><br><span class="line">           minPixelValue: <span class="number">1</span>,     <span class="comment">// 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值</span></span><br><span class="line">           mediaQuery: <span class="literal">false</span>     <span class="comment">// 允许在媒体查询中转换`px`</span></span><br><span class="line">       &#125;   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="暗黑模式"><a href="#暗黑模式" class="headerlink" title="暗黑模式"></a>暗黑模式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">@media (prefers-color-scheme: dark) &#123; // 黑暗模式 </span><br><span class="line">  .guide-page &#123;</span><br><span class="line">    background: #292929;</span><br><span class="line">    .guide-title &#123;</span><br><span class="line">      font-size: 28px;</span><br><span class="line">      color: white</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (prefers-color-scheme: light) &#123; // 正常的</span><br><span class="line">  .guide-page &#123;</span><br><span class="line">    background: white;</span><br><span class="line">    .guide-title &#123;</span><br><span class="line">      font-size: 28px;</span><br><span class="line">      color: #222222eb</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme" target="_blank" rel="noopener">文档</a></p>
<h3 id="SVG-favicon"><a href="#SVG-favicon" class="headerlink" title="SVG favicon"></a>SVG favicon</h3><p>favicon 支持实现黑白模式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        circle &#123;</span><br><span class="line">            fill: yellow;</span><br><span class="line">            stroke: black;</span><br><span class="line">            stroke-width: 3px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme:</span> dark) &#123;</span></span><br><span class="line">            circle &#123;</span><br><span class="line">            fill: black;</span><br><span class="line">            stroke: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"47"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="如何设置body背景色，height-100-不生效？"><a href="#如何设置body背景色，height-100-不生效？" class="headerlink" title="如何设置body背景色，height:100%,不生效？"></a>如何设置body背景色，height:100%,不生效？</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//同时设置html，body的高度</span><br><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>；</span><br><span class="line">&#125; </span><br><span class="line">或</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  height: 100vh; // 代表占屏幕100%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="去除ios-手机端input输入框的内阴影"><a href="#去除ios-手机端input输入框的内阴影" class="headerlink" title="去除ios 手机端input输入框的内阴影"></a>去除ios 手机端input输入框的内阴影</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span>&#123; </span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="iOS端input输入框光标错位"><a href="#iOS端input输入框光标错位" class="headerlink" title="iOS端input输入框光标错位"></a>iOS端input输入框光标错位</h3><p>是由于fixed定位引起的，改成absolute就解决了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图片显示中间部分"><a href="#图片显示中间部分" class="headerlink" title="图片显示中间部分"></a>图片显示中间部分</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit" target="_blank" rel="noopener">object-fit</a></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//1</span><br><span class="line"><span class="selector-tag">object-fit</span>: <span class="selector-tag">cover</span>;</span><br><span class="line">//2</span><br><span class="line"><span class="selector-tag">object-position</span>: 50% 50%;</span><br></pre></td></tr></table></figure>

<h3 id="iOS下取消input在输入的时候英文首字母的默认大写"><a href="#iOS下取消input在输入的时候英文首字母的默认大写" class="headerlink" title="iOS下取消input在输入的时候英文首字母的默认大写"></a>iOS下取消input在输入的时候英文首字母的默认大写</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;input type="text" autocapitalize="none"&gt;</span><br></pre></td></tr></table></figure>

<h3 id="禁止-iOS-识别长串数字为电话"><a href="#禁止-iOS-识别长串数字为电话" class="headerlink" title="禁止 iOS 识别长串数字为电话"></a>禁止 iOS 识别长串数字为电话</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;meta name="format-detection" content="telephone=no" /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="一些情况下对非可点击元素如-label-span-监听click事件，ios下不会触发"><a href="#一些情况下对非可点击元素如-label-span-监听click事件，ios下不会触发" class="headerlink" title="一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发"></a>一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">cursor</span>: <span class="selector-tag">pointer</span>;</span><br></pre></td></tr></table></figure>

<h3 id="禁止ios和android用户选中文字"><a href="#禁止ios和android用户选中文字" class="headerlink" title="禁止ios和android用户选中文字"></a>禁止ios和android用户选中文字</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-user-select</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure>

<h3 id="利用灰色滤镜做灰色图"><a href="#利用灰色滤镜做灰色图" class="headerlink" title="利用灰色滤镜做灰色图"></a>利用灰色滤镜做灰色图</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-filter</span>: <span class="selector-tag">grayscale</span>(1);</span><br></pre></td></tr></table></figure>

<h3 id="页面自适应最佳实践"><a href="#页面自适应最佳实践" class="headerlink" title="页面自适应最佳实践"></a>页面自适应最佳实践</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">375px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="comment">/* iPhone6的375px尺寸作为16px基准，414px正好18px大小, 600 20px */</span></span><br><span class="line">        <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">100%</span> + <span class="number">2</span> * (<span class="number">100vw</span> - <span class="number">375px</span>) / <span class="number">39</span>);</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">16px</span> + <span class="number">2</span> * (<span class="number">100vw</span> - <span class="number">375px</span>) / <span class="number">39</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">414px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="comment">/* 414px-1000px每100像素宽字体增加1px(18px-22px) */</span></span><br><span class="line">        <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">112.5%</span> + <span class="number">4</span> * (<span class="number">100vw</span> - <span class="number">414px</span>) / <span class="number">586</span>);</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">18px</span> + <span class="number">4</span> * (<span class="number">100vw</span> - <span class="number">414px</span>) / <span class="number">586</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="comment">/* 600px-1000px每100像素宽字体增加1px(20px-24px) */</span></span><br><span class="line">        <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">125%</span> + <span class="number">4</span> * (<span class="number">100vw</span> - <span class="number">600px</span>) / <span class="number">400</span>);</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">20px</span> + <span class="number">4</span> * (<span class="number">100vw</span> - <span class="number">600px</span>) / <span class="number">400</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1000px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="comment">/* 1000px往后是每100像素0.5px增加 */</span></span><br><span class="line">        <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">137.5%</span> + <span class="number">6</span> * (<span class="number">100vw</span> - <span class="number">1000px</span>) / <span class="number">1000</span>);</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">22px</span> + <span class="number">6</span> * (<span class="number">100vw</span> - <span class="number">1000px</span>) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Project</category>
        <category>Css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex弹性布局</title>
    <url>/2018/01/20/workspace/Css/flex/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Flex弹性布局</strong></p>
<p>[[toc]]</p>
<p><strong><code>容器的属性</code></strong></p>
<h4 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h4><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">row</span>（默认值）：主轴为水平方向，起点在左端。</span><br><span class="line"><span class="selector-tag">row-reverse</span>：主轴为水平方向，起点在右端。</span><br><span class="line"><span class="selector-tag">column</span>：主轴为垂直方向，起点在上沿。</span><br><span class="line"><span class="selector-tag">column-reverse</span>：主轴为垂直方向，起点在下沿。</span><br></pre></td></tr></table></figure>

<h4 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h4><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nowrap</span>（默认）：不换行。</span><br><span class="line"><span class="selector-tag">wrap</span>：换行，第一行在上方。</span><br><span class="line"><span class="selector-tag">wrap-reverse</span>：换行，第一行在下方。</span><br></pre></td></tr></table></figure>

<h4 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h4><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>
<h4 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h4><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">flex-start</span>（默认值）：左对齐</span><br><span class="line"><span class="selector-tag">flex-end</span>：右对齐</span><br><span class="line"><span class="selector-tag">center</span>： 居中</span><br><span class="line"><span class="selector-tag">space-between</span>：两端对齐，项目之间的间隔都相等。</span><br><span class="line"><span class="selector-tag">space-around</span>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br></pre></td></tr></table></figure>

<h4 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h4><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">flex-start</span>：交叉轴的起点对齐。</span><br><span class="line"><span class="selector-tag">flex-end</span>：交叉轴的终点对齐。</span><br><span class="line"><span class="selector-tag">center</span>：交叉轴的中点对齐。</span><br><span class="line"><span class="selector-tag">baseline</span>: 项目的第一行文字的基线对齐。</span><br><span class="line"><span class="selector-tag">stretch</span>（默认值）：如果项目未设置高度或设为<span class="selector-tag">auto</span>，将占满整个容器的高度。</span><br></pre></td></tr></table></figure>

<h4 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h4><p><code>align-content</code>属性定义了<code>多根轴线</code>的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">flex-start</span>：与交叉轴的起点对齐。</span><br><span class="line"><span class="selector-tag">flex-end</span>：与交叉轴的终点对齐。</span><br><span class="line"><span class="selector-tag">center</span>：与交叉轴的中点对齐。</span><br><span class="line"><span class="selector-tag">space-between</span>：与交叉轴两端对齐，轴线之间的间隔平均分布。</span><br><span class="line"><span class="selector-tag">space-around</span>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span><br><span class="line"><span class="selector-tag">stretch</span>（默认值）：轴线占满整个交叉轴。</span><br></pre></td></tr></table></figure>

<p><strong>适用于弹性盒模型容器子元素</strong></p>
<h4 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h4><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h4><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在<strong><code>剩余空间</code></strong>，也不放大。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <br/>

<img style="border: .3em solid #e0dfcc;border-radius: 1em;width：98%"  src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H71fcbd2221b642a6bc7f52d3170378239.png">

<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h4 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h4><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br/>

<img style="border: .3em solid #e0dfcc;border-radius: 1em;width：98%"  src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H245bfecf53234ecba3042bd2f74545efo.jpg">

<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</p>
<h4 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h4><p>flex-basis表示在flex items 被放入flex容器之前的大小，也就是items的理想或者假设大小，但是并不是其真实大小，<br>其真实大小取决于flex容器的宽度，flex items的min-width,max-width等其他样式，具体分析看下文</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">    width: 350px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 1px solid #c3c3c3;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#main div &#123;</span><br><span class="line">    flex-grow: 0;</span><br><span class="line">    flex-shrink: 0;</span><br><span class="line">    flex-basis: 40px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#main div:nth-of-type(2) &#123;</span><br><span class="line">    flex-basis: 80px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:coral;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:lightblue;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:khaki;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:pink;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:lightgrey;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H8ca6768902df41ecb593aec7f900645ad.png" alt=""></p>
<h4 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h4><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为0 1 auto。后两个属性可选。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</span><br></pre></td></tr></table></figure>

<h4 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h4><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br/>

<img style="border: .3em solid #e0dfcc;border-radius: 1emwidth：98%;"  src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hedafd4f059f24e8cb9093252cad6f53an.png">

]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS九宫格布局实现</title>
    <url>/2018/01/20/workspace/Css/lattice/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>CSS九宫格布局实现</strong></p>
<p>[[toc]]</p>
<p><strong>基本的布局</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">"width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,viewport-fit=cover"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#e4f7fd61</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#0786ada1</span>;</span></span><br><span class="line">            border-radius: 8px;</span><br><span class="line">        &#125;</span><br><span class="line">        ul &#123;</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.box</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">            list-style: none;</span><br><span class="line">            text-align: center;</span><br><span class="line">            line-height: 200px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(146, 203, 230, 0<span class="selector-class">.65</span>);</span></span><br><span class="line">            border-radius: 8px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>9<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="margin负值实现"><a href="#margin负值实现" class="headerlink" title="margin负值实现"></a>margin负值实现</h3><ul>
<li>最外层的包裹元素等于：li宽度<em>3+li右间距</em>2</li>
<li>子盒子左浮动，margin-left margin-bottom间距为20px</li>
<li>父盒子的margin-bottom和margin-top的的间距为-20px,消除子盒子代理的移动</li>
<li>父盒子消除浮动</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">940px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: -<span class="number">20px</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nth-child"><a href="#nth-child" class="headerlink" title="nth-child"></a>nth-child</h3><p>跟上面的那种方法类似，就是把父盒子的移动换成了指定的子盒子移动</p>
<p>但是这回出现一个问题就是最下的一层盒子个数不确定所以margin-bottom,就没办法正确的设置<br>所以就会用到css的级联使用，方法看如下的代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">...  // 代码跟上面的一致，去除UI部分</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(3n)</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(3n+1)</span><span class="selector-pseudo">:nth-last-child(-n+3)</span>, <span class="selector-class">.box</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(3n+1)</span><span class="selector-pseudo">:nth-last-child(-n+3)</span> ~ <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> <span class="selector-class">.grid</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.grid</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">4px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#6a8bad</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">border-color</span>: red;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">500ms</span>;</span><br><span class="line">    <span class="comment">/*z-index:-2;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个地方需要注意，就是不要再给li子项设置宽度和高度。<br>该grid布局中，也可以在hover时添加z-index:2;来提高叠加等级,不然没办法展示全部</p>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">312px</span>;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">4px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">146</span>, <span class="number">203</span>, <span class="number">230</span>, <span class="number">0.65</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="comment">/*z-index:2;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Electron基础</title>
    <url>/2019/07/16/workspace/Electron/base/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Electron基础</strong></p>
<p>[[toc]]</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>​Electron 是一个由 GitHub 开发的开源库，通过将 Chromium) 和Node.js 组合并使用 HTML，CSS 和 JavaScript 进行构建 Mac，Windows，和 Linux 跨平台桌面应用程序。</code></p>
<p><strong>优点:</strong></p>
<p>方便快捷的开发桌面应用，跨平台，对前端开发者友好，活跃的社区，丰富的api……</p>
<p><strong>缺点:</strong></p>
<p>性能肯定比不上原生的桌面应用，发布的包很大。（DeskGap这个不带浏览器的功能，包比较小）</p>
<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p><strong>1.electron-react-boilerplate</strong></p>
<p><a href="https://github.com/electron-react-boilerplate/electron-react-boilerplate" target="_blank" rel="noopener">star~13000</a></p>
<p><strong>2.</strong> 使用脚手架<code>electron-forge</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局安装脚手架</span></span><br><span class="line">yarn global add @electron-forge/cli</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化项目</span></span><br><span class="line">yarn create electron-app my-app</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> 自己搭建</p>
<ul>
<li><p>新建main.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: hzf;</span></span><br><span class="line"><span class="comment"> * Date: 2019-08-08 13:57;</span></span><br><span class="line"><span class="comment"> * Description:主进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;app, BrowserWindow&#125; = electron;</span><br><span class="line"><span class="comment">//保持对window对象的全局引用</span></span><br><span class="line"><span class="comment">// 垃圾回收的时候，window对象将会自动的关闭</span></span><br><span class="line"><span class="keyword">let</span> win;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createWindow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建浏览器窗口</span></span><br><span class="line">    win = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">        width: <span class="number">800</span>,</span><br><span class="line">        height: <span class="number">600</span>,</span><br><span class="line">        webPreferences: &#123;</span><br><span class="line">            preload: path.join(__dirname, <span class="string">'preload.js'</span>),</span><br><span class="line">            nodeIntegration: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 加载index.html文件</span></span><br><span class="line">    win.loadFile(<span class="string">'index.html'</span>);</span><br><span class="line">    <span class="comment">// 打开开发者工具</span></span><br><span class="line">    win.webContents.openDevTools();</span><br><span class="line">    <span class="comment">// 当 window 被关闭，这个事件会被触发。</span></span><br><span class="line">    win.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 取消引用 window 对象，如果你的应用支持多窗口的话，</span></span><br><span class="line">        <span class="comment">// 通常会把多个 window 对象存放在一个数组里面，</span></span><br><span class="line">        <span class="comment">// 与此同时，你应该删除相应的元素。</span></span><br><span class="line">        win = <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Electron 会在初始化后并准备</span></span><br><span class="line"><span class="comment">// 创建浏览器窗口时，调用这个函数。</span></span><br><span class="line"><span class="comment">// 部分 API 在 ready 事件触发后才能使用。</span></span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当全部窗口关闭时退出。</span></span><br><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在 macOS 上，除非用户用 Cmd + Q 确定地退出，</span></span><br><span class="line">    <span class="comment">// 否则绝大部分应用及其菜单栏会保持激活。</span></span><br><span class="line">    <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) app.quit()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'activate'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在macOS上，当单击dock图标并且没有其他窗口打开时，</span></span><br><span class="line">    <span class="comment">// 通常在应用程序中重新创建一个窗口。</span></span><br><span class="line">    <span class="keyword">if</span> (win === <span class="literal">null</span>) createWindow()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建index.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//渲染进程</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"zh-Hans-CN"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化git </p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line"><span class="comment">//electron 运行 package.json 的 main 脚本的进程被称为主进程。 在主进程中运行的脚本通过创建web页面来展示用户界面。</span></span><br><span class="line"><span class="comment">// 一个 Electron 应用总是有且只有一个主进程。</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"electron"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"main.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"electron ."</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"keywords"</span>: [],</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"electron"</span>: <span class="string">"^6.0.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载index.html文件</span></span><br><span class="line">win.loadFile(path.join(__dirname, <span class="string">'index.html'</span>));</span><br><span class="line"><span class="comment">//加载URL</span></span><br><span class="line">win.loadURL(<span class="string">'http://music.migu.cn/'</span>);</span><br><span class="line"><span class="comment">//打开开发者工具</span></span><br><span class="line">win.webContents.openDevTools();</span><br><span class="line"><span class="comment">//关闭开发者工具</span></span><br><span class="line">win.webContents.closeDevTools();</span><br></pre></td></tr></table></figure>

<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p><code>devDependencies与dependencies的区别</code></p>
<p><code>dependencies</code> 表示我们要在生产环境下使用该依赖，<code>devDependencies</code> 则表示我们仅在开发环境使用该依赖。<br>在打包时，一定要分清哪些包属于生产依赖，哪些属于开发依赖，尤其是在项目较大，依赖包较多的情况下。<br>若在生产环境下错应或者少引依赖包，即便是成功打包，但在使用应用程序期间也会报错，导致打包好的程序无法正常运行。</p>
]]></content>
      <categories>
        <category>Electron</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter基础</title>
    <url>/2019/07/16/workspace/Flutter/base/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Flutter基础</strong></p>
<p>[[toc]]</p>
<h3 id="待总结"><a href="#待总结" class="headerlink" title="待总结"></a>待总结</h3>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Github API 调用</title>
    <url>/2019/07/19/workspace/Git/github/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Github API 调用</strong></p>
<p>[[toc]]</p>
<h3 id="基本访问"><a href="#基本访问" class="headerlink" title="基本访问"></a>基本访问</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl https:<span class="comment">//api.github.com/users/hzfvictory</span></span><br></pre></td></tr></table></figure>
<ul>
<li>个人主要信息<code>https://api.github.com/users/用户名</code></li>
<li>个人所有repo。<code>https://api.github.com/users/用户名/repos</code>。会得到一个repo的JSON格式列表。</li>
<li>repo详细信息。<code>https://api.github.com/repos/用户名/仓库名</code>。repo的路径就开始和个人信息不同了。</li>
<li>获取某文件的原始内容（Raw）。<ul>
<li>通过上面的文件信息中提取download_url这条链接，就能获取它的原始内容了。</li>
<li>或者直接访问：<code>https://raw.githubusercontent.com/用户名/仓库名/分支名/文件路径</code></li>
</ul>
</li>
<li><strong>repo中所有的commits列表。<code>https://api.github.com/repos/用户名/仓库名/commits</code>。</strong></li>
<li>某一条commit详情。<code>https://api.github.com/repos/用户名/仓库名/commits/某一条commit的SHA</code></li>
<li><strong>issues列表。<code>https://api.github.com/repos/用户名/仓库名/issues</code>。</strong></li>
<li>某条issue详情。<code>https://api.github.com/repos/用户名/仓库名/issues/序号</code>。issues都是以1,2,3这样的序列排号的。</li>
<li><strong>某issue中的comments列表。<code>https://api.github.com/repos/用户名/仓库名/issues/序号/comments</code>。</strong></li>
<li>某comment详情。<code>https://api.github.com/repos/用户名/仓库名/issues/comments/评论详情的ID</code>。其中评论ID是从issues列表中获得的。</li>
</ul>
<h3 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h3><ul>
<li>分页功能。格式是<code>?page=页数&amp;per_page=每页包含数量</code>。</li>
<li>issues状态。格式是<code>?state=状态</code>。</li>
</ul>
<h3 id="权限认证-Authentication"><a href="#权限认证-Authentication" class="headerlink" title="权限认证 Authentication"></a>权限认证 Authentication</h3><p>我的项目一般私有的，直接获取没有权限，需要添加token</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H0fec58c800544c24b103e00bf3f4e82aY.png" alt=""></p>
<p><strong>1.直接作为url中的参数传输</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl https:<span class="comment">//api.github.com/?access_token=OAUTH-TOKEN</span></span><br></pre></td></tr></table></figure>
<p><strong>2.作为header中的参数传输</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">"Authorization: token OAUTH-TOKEN"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">`https://api.github.com/repos/hzfvictory/file/commits?per_page=15&amp;sha=develop`</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        method: <span class="string">'GET'</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">'Authorization'</span>: <span class="string">'token OAUTH-TOKEN'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">        <span class="keyword">this</span>.show = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response.json();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'接口调取失败！'</span>);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://segmentfault.com/a/1190000015144126" target="_blank" rel="noopener">Github Api</a></p>
]]></content>
      <categories>
        <category>Git</category>
        <category>Github API 调用</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基础</title>
    <url>/2019/01/16/workspace/Git/git/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Git基础</strong></p>
<p>[[toc]]</p>
<h3 id="git-emoji"><a href="#git-emoji" class="headerlink" title="git emoji"></a>git emoji</h3><p>执行 git commit 时使用 emoji 为本次提交打上一个 “标签”, 使得此次 commit 的主要工作得以凸现，也能够使得其在整个提交历史中易于区分与查找。</p>
<table>
<thead>
<tr>
<th align="left">emoji</th>
<th align="left">emoji 代码</th>
<th align="left">commit 说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:tada: (庆祝)</td>
<td align="left"><code>:tada:</code></td>
<td align="left">初次提交</td>
</tr>
<tr>
<td align="left">:sparkles: (火花)</td>
<td align="left"><code>:sparkles:</code></td>
<td align="left">引入新功能</td>
</tr>
<tr>
<td align="left">:bookmark: (书签)</td>
<td align="left"><code>:bookmark:</code></td>
<td align="left">发行/版本标签</td>
</tr>
<tr>
<td align="left">:bug: (bug)</td>
<td align="left"><code>:bug:</code></td>
<td align="left">修复 bug</td>
</tr>
<tr>
<td align="left">:ambulance: (急救车)</td>
<td align="left"><code>:ambulance:</code></td>
<td align="left">重要补丁</td>
</tr>
<tr>
<td align="left">:globe_with_meridians: (地球)</td>
<td align="left"><code>:globe_with_meridians:</code></td>
<td align="left">国际化与本地化</td>
</tr>
<tr>
<td align="left">:lipstick: (口红)</td>
<td align="left"><code>:lipstick:</code></td>
<td align="left">更新 UI 和样式文件</td>
</tr>
<tr>
<td align="left">:clapper: (场记板)</td>
<td align="left"><code>:clapper:</code></td>
<td align="left">更新演示/示例</td>
</tr>
<tr>
<td align="left">:rotating_light: (警车灯)</td>
<td align="left"><code>:rotating_light:</code></td>
<td align="left">移除 linter 警告</td>
</tr>
<tr>
<td align="left">:wrench: (扳手)</td>
<td align="left"><code>:wrench:</code></td>
<td align="left">修改配置文件</td>
</tr>
<tr>
<td align="left">:heavy_plus_sign: (加号)</td>
<td align="left"><code>:heavy_plus_sign:</code></td>
<td align="left">增加一个依赖</td>
</tr>
<tr>
<td align="left">:heavy_minus_sign: (减号)</td>
<td align="left"><code>:heavy_minus_sign:</code></td>
<td align="left">减少一个依赖</td>
</tr>
<tr>
<td align="left">:arrow_up: (上升箭头)</td>
<td align="left"><code>:arrow_up:</code></td>
<td align="left">升级依赖</td>
</tr>
<tr>
<td align="left">:arrow_down: (下降箭头)</td>
<td align="left"><code>:arrow_down:</code></td>
<td align="left">降级依赖</td>
</tr>
<tr>
<td align="left">:zap: (闪电)<br>:racehorse: (赛马)</td>
<td align="left"><code>:zap:</code><br><code>:racehorse:</code></td>
<td align="left">提升性能</td>
</tr>
<tr>
<td align="left">:chart_with_upwards_trend: (上升趋势图)</td>
<td align="left"><code>:chart_with_upwards_trend:</code></td>
<td align="left">添加分析或跟踪代码</td>
</tr>
<tr>
<td align="left">:rocket: (火箭)</td>
<td align="left"><code>:rocket:</code></td>
<td align="left">部署功能</td>
</tr>
<tr>
<td align="left">:white_check_mark: (白色复选框)</td>
<td align="left"><code>:white_check_mark:</code></td>
<td align="left">增加测试</td>
</tr>
<tr>
<td align="left">:memo: (备忘录)</td>
<td align="left"><code>:memo:</code></td>
<td align="left">撰写文档</td>
</tr>
<tr>
<td align="left">:hammer: (锤子)</td>
<td align="left"><code>:hammer:</code></td>
<td align="left">重大重构</td>
</tr>
<tr>
<td align="left">:art: (调色板)</td>
<td align="left"><code>:art:</code></td>
<td align="left">改进代码结构/代码格式</td>
</tr>
<tr>
<td align="left">:fire: (火焰)</td>
<td align="left"><code>:fire:</code></td>
<td align="left">移除代码或文件</td>
</tr>
<tr>
<td align="left">:pencil2: (铅笔)</td>
<td align="left"><code>:pencil2:</code></td>
<td align="left">修复 typo</td>
</tr>
<tr>
<td align="left">:construction: (施工)</td>
<td align="left"><code>:construction:</code></td>
<td align="left">工作进行中</td>
</tr>
<tr>
<td align="left">:construction_worker: (工人)</td>
<td align="left"><code>:construction_worker:</code></td>
<td align="left">添加 CI 构建系统</td>
</tr>
<tr>
<td align="left">:green_heart: (绿心)</td>
<td align="left"><code>:green_heart:</code></td>
<td align="left">修复 CI 构建问题</td>
</tr>
<tr>
<td align="left">:lock: (锁)</td>
<td align="left"><code>:lock:</code></td>
<td align="left">修复安全问题</td>
</tr>
<tr>
<td align="left">:whale: (鲸鱼)</td>
<td align="left"><code>:whale:</code></td>
<td align="left">Docker 相关工作</td>
</tr>
<tr>
<td align="left">:apple: (苹果)</td>
<td align="left"><code>:apple:</code></td>
<td align="left">修复 macOS 下的问题</td>
</tr>
<tr>
<td align="left">:penguin: (企鹅)</td>
<td align="left"><code>:penguin:</code></td>
<td align="left">修复 Linux 下的问题</td>
</tr>
<tr>
<td align="left">:checkered_flag: (旗帜)</td>
<td align="left"><code>:checked_flag:</code></td>
<td align="left">修复 Windows 下的问题</td>
</tr>
</tbody></table>
<h3 id="git实用命令"><a href="#git实用命令" class="headerlink" title="git实用命令"></a>git实用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~4 合并commit 的记录</span><br><span class="line">git clone --depth&#x3D;1</span><br><span class="line">git log</span><br><span class="line">git reflog</span><br><span class="line">git remote -v :查看仓库源</span><br><span class="line">git checkout -b [name]:创建并切换</span><br><span class="line">git reset -–hard ID :回退代码   git reset --hard origin&#x2F;master 可以用来清空本地的代码</span><br><span class="line">git merge [name] :合并分支</span><br><span class="line">git branch -l :查看本地分支</span><br><span class="line">git branch -r :查看远程分支</span><br><span class="line">git branch -a :查看全部分支（远程的和本地的）</span><br><span class="line">git branch -m dev develop   :换本地分支名字，然后删除远程的，提交下就可以同步更新</span><br><span class="line">git branch -d （分支名称） :可以删除本地分支（在主分支中）</span><br><span class="line">git push origin --delete [name] :删除线上的分支</span><br><span class="line">git checkout -- &lt;file&gt;  :丢弃工作区的修改</span><br><span class="line">git checkout .  :本地所有修改的。没有的提交的，都返回到原来的状态</span><br><span class="line">git blame src&#x2F;pages&#x2F;item&#x2F;ItemTable&#x2F;ItemTable.js  :查看当前谁修改过代码</span><br><span class="line">git reset HEAD &lt;file&gt;  :当你不但改乱了工作区某个文件的内容，还添加到了暂存时，想丢弃修改</span><br><span class="line">git commit --amend -m&#39;新提交消息&#39;  :提交信息出错&#96;</span><br><span class="line">git stash  :储藏</span><br><span class="line">git stash pop  :删除当前储藏</span><br><span class="line">git  config --global  user.name &#39;hezhenfeng&#39;  :修改git的用户名 </span><br><span class="line">git  config --global  user.email &#39;feng960106@163.com&#39;  :修改git的邮箱</span><br><span class="line">git config –-list   ：查看信息</span><br><span class="line">git config --global credential.helper cache  :设置记住密码（默认15分钟）</span><br><span class="line">git config credential.helper &#39;cache --timeout&#x3D;3600&#39;  :设置记住密码（1h）</span><br><span class="line">git config --global credential.helper store :永久</span><br></pre></td></tr></table></figure>




<h3 id="git-revert-和-git-reset-的区别"><a href="#git-revert-和-git-reset-的区别" class="headerlink" title="git revert 和 git reset 的区别"></a>git revert 和 git reset 的区别</h3><ul>
<li><p><code>git revert</code>是用一次新的commit来回滚之前的commit，<code>git reset</code>是直接删除指定的commit。</p>
</li>
<li><p>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的commit“中和”之前的提交<br>，因此日后合并老的branch时，导致这部分改变不会再次出现，但是<code>git reset</code>是之间把某些commit在某个branch上删除，<br>因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</p>
</li>
<li><p><code>git reset</code> 是把HEAD向后移动了一下，而<code>git revert</code>是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</p>
</li>
</ul>
<h3 id="拉取代码-git-pull-–rebase"><a href="#拉取代码-git-pull-–rebase" class="headerlink" title="拉取代码 git pull –rebase"></a>拉取代码 git pull –rebase</h3><p>假设提交线图在执行 pull 前是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A---B---C  remotes&#x2F;origin&#x2F;master</span><br><span class="line">             &#x2F;</span><br><span class="line">        D---E---F---G  master</span><br></pre></td></tr></table></figure>

<p>如果是执行 git pull 后，提交线图会变成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A---B---C remotes&#x2F;origin&#x2F;master</span><br><span class="line">               &#x2F;         \</span><br><span class="line">          D---E---F---G---H master</span><br></pre></td></tr></table></figure>

<p>结果多出了 H 这个没必要的提交记录。如果是执行 git pull –rebase 的话，提交线图就会变成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remotes&#x2F;origin&#x2F;master</span><br><span class="line">                         |</span><br><span class="line">         D---E---A---B---C---F&#39;---G&#39;  master</span><br></pre></td></tr></table></figure>

<p>F G 两个提交通过 rebase 方式重新拼接在 C 之后，多余的分叉去掉了，目的达到</p>
<p>::: danger 注意：</p>
<p>git pull = git fetch + git merge</p>
<p>git pull –rebase = git fetch + git rebase</p>
<p>:::</p>
<h3 id="rebase合并分支"><a href="#rebase合并分支" class="headerlink" title="rebase合并分支"></a>rebase合并分支</h3><p>master分支,节点链表指向为: c1&lt;–C3&lt;–c4</p>
<p>dev分支，节点链表指向为: c1&lt;–C2&lt;–c5</p>
<p>master分支和dev分支祖先为c1,假定在master分支上做git merge dev合并，得到的提交历史为:</p>
<p>c1&lt;–c2&lt;–c3&lt;–c4&lt;–c5&lt;–C6 (c1、 c4、 c5做了-次三方合并发现冲突,手工处理完毕后git add/commit增加了提交节点c6)</p>
<p>采用git merge dev处理提交log是按照时间戳先后顺序的。</p>
<p>假定采用的是git rebase处理过程为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git rebase master <span class="comment">//将dev上的c2、 c5在master分支 上做次衍合处理,并且保证在dev新增的commit 会排在 log 的最后</span></span><br><span class="line"><span class="comment">//git提示出现了代码冲突，此处为之前埋下的冲突点，处理完毕后</span></span><br><span class="line">git add . <span class="comment">//添加冲突处理后的文件</span></span><br><span class="line">git rebase --<span class="keyword">continue</span>  <span class="comment">//单加上--continue参数让rebase继续处理 ，无需执行 git-commit </span></span><br><span class="line"><span class="comment">//开发完成, 在 master 上用 mergin 合并dev,不会自动产生合并分支的 'commit'</span></span><br></pre></td></tr></table></figure>

<p><a href="https://imgssl.luxiaoquan.com/FtjtK3w9rjUXEip-hxjzSQhRSCSC?imageView2/2/w/640/interlace/1" target="_blank" rel="noopener"></a></p>
<h3 id="git分支命名"><a href="#git分支命名" class="headerlink" title="git分支命名"></a>git分支命名</h3><p>master：主分支，负责记录上线版本的迭代，该分支代码与线上代码是完全一致的。</p>
<p>develop：开发分支，该分支记录相对稳定的版本，所有的feature分支和bugfix分支都从该分支创建。其它分支为短期分支，其完成功能开发之后需要删除</p>
<p>feature/*：特性（功能）分支，用于开发新的功能，不同的功能创建不同的功能分支，功能分支开发完成并自测通过之后，需要合并到 develop 分支，之后删除该分支。</p>
<p>bugfix/*：bug修复分支，用于修复不紧急的bug，普通bug均需要创建bugfix分支开发，开发完成自测没问题后合并到 develop 分支后，删除该分支。</p>
<p>release/*：发布分支，用于代码上线准备，该分支从develop分支创建，创建之后由测试同学发布到测试环境进行测试，测试过程中发现bug需要开发人员在该release分支上进行bug修复，所有bug修复完后，在上线之前，需要合并该release分支到master分支和develop分支。</p>
<p>hotfix/*：紧急bug修复分支，该分支只有在紧急情况下使用，从master分支创建，用于紧急修复线上bug，修复完成后，需要合并该分支到master分支以便上线，同时需要再合并到develop分支。</p>
<h3 id="gitlab的key"><a href="#gitlab的key" class="headerlink" title="gitlab的key"></a>gitlab的key</h3><p>ssh-keygen -t rsa -C “<a href="mailto:feng960106@163.com">feng960106@163.com</a>“</p>
<p>cat ~/.ssh/id_rsa.pub</p>
<h3 id="迁移-github"><a href="#迁移-github" class="headerlink" title="迁移 github"></a>迁移 github</h3><p>sed -i ‘’ “s/115.28.166.109/123.57.86.216/g” .git/config</p>
<h3 id="git-无法添加文件夹下文件"><a href="#git-无法添加文件夹下文件" class="headerlink" title="git 无法添加文件夹下文件"></a>git 无法添加文件夹下文件</h3><p>最近做项目时，发现无法提交某个子文件夹下的文件。</p>
<p>google后发现可能是该子文件夹下有.git文件夹导致无法上传。</p>
<p>删除子文件夹下.git后，依然无法提交子文件夹下的文件。</p>
<p>继续google，</p>
<p>尝试以下方法：</p>
<p> git rm –cached directory<br> git add directory</p>
<p><strong>注：</strong> directory为子文件夹的路径。</p>
<p>但是执行git rm –cached directory时，提示</p>
<blockquote>
<p>fatal: Unable to create ‘xx/.git/index.lock’: File exists.</p>
</blockquote>
<p>执行rm -f xx/.git/index.lock后解决</p>
]]></content>
      <categories>
        <category>Git</category>
        <category>Git基础</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Array的方法简单整理</title>
    <url>/2018/01/17/workspace/Js/array/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Array的方法简单整理</strong></p>
<p>[[toc]]</p>
<h3 id="快速生成一个数组"><a href="#快速生成一个数组" class="headerlink" title="快速生成一个数组"></a>快速生成一个数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速生成一个数组</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">100</span>), (key, index) =&gt; index);</span><br><span class="line"></span><br><span class="line">[...new <span class="built_in">Array</span>(<span class="number">100</span>).keys()]</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">''</span>); <span class="comment">//["", "", ""]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(&#123;&#125;).map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    title:<span class="string">"掘金会员"</span>,</span><br><span class="line">    createtime:<span class="string">"2020-05-03"</span>,</span><br><span class="line">    state:<span class="number">1</span>,</span><br><span class="line">    price:<span class="number">19.8</span>,</span><br><span class="line">    timeNum:<span class="number">12</span>,</span><br><span class="line">    userName:<span class="string">"虎克小哥哥"</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    city:<span class="string">"上海"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    arr.push(i);</span><br><span class="line">    dfs(++i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">100</span>).join(<span class="string">","</span>).split(<span class="string">","</span>).map(<span class="function">(<span class="params">key,index</span>)=&gt;</span> index)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>,<span class="built_in">Array</span>(<span class="number">100</span>)).map(<span class="function">(<span class="params">key,index</span>)=&gt;</span>index)</span><br></pre></td></tr></table></figure>

<h3 id="some-amp-every"><a href="#some-amp-every" class="headerlink" title="some() &amp; every()"></a>some() &amp; every()</h3><p>every()与some()方法都是JS中数组的迭代方法。</p>
<p><code>some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true;some一直在找符合条件的值，一旦找到，则不会继续迭代下去。</code></p>
<p><code>every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true;every从迭代开始，一旦有一个不符合条件，则不会继续迭代下去。</code></p>
<img style="border: .3em solid #e0dfcc;border-radius: 1em;width：98%"  src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H1f23b6d819f24380a396fd15d5ed914dA.png">


<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><ul>
<li><p>reducer 函数接收4个参数:</p>
<ul>
<li><p>Accumulator (acc) (累计器,没有返回值为undefined)</p>
</li>
<li><p>CurrentValue (cur) (当前值)</p>
</li>
<li><p>CurrentIndex (idx) (当前索引)</p>
</li>
<li><p>SourceArray (ary) (原数组)</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">Accumulator,CurrentValue,CurrentIndex,SourceArray</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;, init);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//求数组项之和</span></span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//求数组项最大值</span></span><br><span class="line"><span class="keyword">var</span> max = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(prev,cur);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max(...arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组去重</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    prev.indexOf(cur) === <span class="number">-1</span> &amp;&amp; prev.push(cur);</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;,[]);</span><br></pre></td></tr></table></figure>

<h3 id="isArray"><a href="#isArray" class="headerlink" title="isArray()"></a>isArray()</h3><p>Array.isArray() 用于确定传递的值是否是一个 Array。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;<span class="attr">foo</span>: <span class="number">123</span>&#125;);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dom1 =  <span class="built_in">document</span>.getElementsByClassName(<span class="string">'token'</span>)</span><br><span class="line"><span class="built_in">Array</span>.isArray(dom1);  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([...dom1]);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.from(dom1));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><code>Array.isArray 实现</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.myIsArray = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Object</span>(o)) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.myIsArray([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p><strong>请注意:</strong> 该方法并<code>不会修改数组</code>，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。</p>
<ul>
<li>arr.slice(begin ,end?)<ul>
<li>（包含 begin，但不包含 end）。</li>
<li>slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animals = [<span class="string">'ant'</span>, <span class="string">'bison'</span>, <span class="string">'camel'</span>, <span class="string">'duck'</span>, <span class="string">'elephant'</span>];</span><br><span class="line"><span class="comment">//[].slice.call(animals,1,3)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["camel", "duck", "elephant"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["camel", "duck"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["bison", "camel", "duck", "elephant"]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//slice的内部实现</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice = <span class="function"><span class="keyword">function</span>(<span class="params">start,end</span>)</span>&#123; </span><br><span class="line">      <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line">      start = start || <span class="number">0</span>; </span><br><span class="line">      end = end || <span class="keyword">this</span>.length; <span class="comment">//this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键 </span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = start; i &lt; end; i++)&#123; </span><br><span class="line">           result.push(<span class="keyword">this</span>[i]); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> result; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p><code>splice()</code> 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</p>
<p><strong>删除</strong></p>
<p>第二个参数为<code>删除的个数</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ary =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">//[].splice.call(ary,1,1)</span></span><br><span class="line">ary.splice(<span class="number">1</span>,<span class="number">1</span>);   <span class="comment">// 返回删除的一项 [2]</span></span><br><span class="line">ary  <span class="comment">//[1, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p><strong>插入</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ary =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">ary.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">"7"</span>);   <span class="comment">//[], 没有元素被删除</span></span><br><span class="line">ary  <span class="comment">//[1, 2, "7", 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">ary.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">"9"</span>,<span class="string">'10'</span>,<span class="number">11</span>,<span class="number">12</span>)</span><br><span class="line">ary  <span class="comment">//[1, 2, "9", "10", 11, 12, "7", 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p><strong>删除 &amp; 插入</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFish = [<span class="string">'angel'</span>, <span class="string">'clown'</span>, <span class="string">'trumpet'</span>, <span class="string">'sturgeon'</span>];</span><br><span class="line">myFish.splice(<span class="number">0</span>, <span class="number">2</span>, <span class="string">'parrot'</span>, <span class="string">'anemone'</span>, <span class="string">'blue'</span>); <span class="comment">//["angel", "clown"]</span></span><br><span class="line">myFish  <span class="comment">//["parrot", "anemone", "blue", "trumpet", "sturgeon"]</span></span><br></pre></td></tr></table></figure>

<h3 id="filter-实现"><a href="#filter-实现" class="headerlink" title="filter() 实现"></a>filter() 实现</h3><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p>
<p>注意： filter() 不会对空数组进行检测。</p>
<p>注意： filter() 不会改变原始数组。</p>
<p><strong>语法</strong></p>
<p>array.filter(function(currentValue,index,arr), thisValue)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfFilter = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> aArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = aArr.length;</span><br><span class="line">  <span class="keyword">let</span> aFArr = [];</span><br><span class="line">  <span class="comment">// 循环调用callback</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!aArr.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    callback.call(context, aArr[i], i, <span class="keyword">this</span>) &amp;&amp; aFArr.push(aArr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> aFArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Map-Set-WeakMap-WeakSet"><a href="#Map-Set-WeakMap-WeakSet" class="headerlink" title="Map + Set + WeakMap + WeakSet"></a>Map + Set + WeakMap + WeakSet</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sets</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="string">"hello"</span>).add(<span class="string">"goodbye"</span>).add(<span class="string">"hello"</span>);</span><br><span class="line">s.size === <span class="number">2</span>;</span><br><span class="line">s.has(<span class="string">"hello"</span>) === <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Weak Sets </span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(&#123; <span class="attr">data</span>: <span class="number">42</span> &#125;); <span class="comment">//只能是对象（null除外）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Maps</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">"hello"</span>, <span class="number">42</span>);</span><br><span class="line">m.set(s, <span class="number">34</span>);</span><br><span class="line">m.get(s) == <span class="number">34</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Weak Maps</span></span><br><span class="line"><span class="keyword">var</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); </span><br><span class="line">wm.set(s, &#123; <span class="attr">extra</span>: <span class="number">42</span> &#125;);<span class="comment">//只接受对象作为键名（null除外）</span></span><br><span class="line">wm.size === <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<img style="border-radius: 4px;width:49%"  src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H98fdbfe7a328477cae2506f4f3346bd1G.png">

<img style="border-radius: 4px;width:49%"  src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Ha1b8b3b1e2db46e6926de265813c5cd3Z.png">

<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(fn, []);</span><br><span class="line">&#125;</span><br><span class="line">unique([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">15</span>,<span class="number">6</span>], <span class="function"><span class="keyword">function</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">  !arr.includes(item) &amp;&amp; arr.push(item);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="forEach中return有效果吗？如何中断forEach循环？"><a href="#forEach中return有效果吗？如何中断forEach循环？" class="headerlink" title="forEach中return有效果吗？如何中断forEach循环？"></a>forEach中return有效果吗？如何中断forEach循环？</h3><p>在forEach中用return不会返回，函数会继续执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">nums.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>;<span class="comment">//无效</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>中断方法：</strong></p>
<p>(1). 使用try监视代码块，在需要中断的地方抛出异常。</p>
<p>(2). 官方推荐方法（替换方法）：用every和some替代forEach函数。every在碰到return false的时候，中止循环。some在碰到return true的时候，中止循环</p>
<h3 id="js将多维数组转换为一维数组"><a href="#js将多维数组转换为一维数组" class="headerlink" title="js将多维数组转换为一维数组"></a>js将多维数组转换为一维数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]]]]</span><br><span class="line"><span class="built_in">console</span>.log(arr.join())   <span class="comment">// 输出为：1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = arr.join().split(<span class="string">','</span>)</span><br><span class="line"><span class="keyword">let</span> newArr = arr.toString().split(<span class="string">','</span>)</span><br><span class="line"><span class="keyword">let</span> newArr = (arr + <span class="string">''</span>).split(<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// 输出为：["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"]</span></span><br></pre></td></tr></table></figure>


<p><strong>递归</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]]]]</span><br><span class="line"><span class="keyword">let</span> newArr = [] <span class="comment">// 存放转化后的一维数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrConversion</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">      arrConversion(arr[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">arrConversion(arr)</span><br><span class="line"><span class="built_in">console</span>.log(newArr)</span><br></pre></td></tr></table></figure>

<p><strong>flat</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span> ,[<span class="number">2</span>, <span class="number">3</span>]].flat()); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 指定转换的嵌套层数</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]]].flat(<span class="number">2</span>)); <span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不管嵌套多少层</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]]].flat(<span class="literal">Infinity</span>)); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>正则</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(ary);</span><br><span class="line"><span class="keyword">let</span> result = str.replace(<span class="regexp">/(\[|\])/g</span>, <span class="string">''</span>).split(<span class="string">','</span>);</span><br><span class="line"><span class="built_in">console</span>.log( result )</span><br></pre></td></tr></table></figure>

<h3 id="数组快速随机排序"><a href="#数组快速随机排序" class="headerlink" title="数组快速随机排序"></a>数组快速随机排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">let</span> t;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.length; i++)&#123;</span><br><span class="line">  <span class="keyword">let</span> rand = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*arr.length);</span><br><span class="line">     t = arr[rand];</span><br><span class="line">     arr[rand] =arr[i];</span><br><span class="line">     arr[i] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">arr.sort(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i ; j&lt;len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                [arr[i],arr[j]] = [arr[j],arr[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;  <span class="comment">//递归出口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> left = [],</span><br><span class="line">        right = [],</span><br><span class="line">        current = arr.splice(<span class="number">0</span>,<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; current) &#123;</span><br><span class="line">            left.push(arr[i])  <span class="comment">//放在左边</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i]) <span class="comment">//放在右边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(current,quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断数组中是否有重复元素"><a href="#判断数组中是否有重复元素" class="headerlink" title="判断数组中是否有重复元素"></a>判断数组中是否有重复元素</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRepeat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRepeat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">   obj[arr[i]] = arr[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj).length !== arr.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求第一个数组中没有第二个数组中部分的值"><a href="#求第一个数组中没有第二个数组中部分的值" class="headerlink" title="求第一个数组中没有第二个数组中部分的值"></a>求第一个数组中没有第二个数组中部分的值</h3><p><strong>差集</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">differenceSecond</span>(<span class="params">ary1,ary2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    ary1.filter(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">      !ary2.includes(item)&amp;&amp;arr.push(item)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">differenceSecond</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = [...m, ...n];</span><br><span class="line">  <span class="keyword">let</span> b = n;</span><br><span class="line">  <span class="keyword">let</span> aHasNaN = m.some(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isNaN</span>(v);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> bHasNaN = n.some(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isNaN</span>(v);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> difference = a</span><br><span class="line">    .filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> b.indexOf(v) == <span class="number">-1</span> &amp;&amp; !<span class="built_in">isNaN</span>(v);</span><br><span class="line">    &#125;)</span><br><span class="line">    .concat(</span><br><span class="line">      b.filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.indexOf(v) == <span class="number">-1</span> &amp;&amp; !<span class="built_in">isNaN</span>(v);</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .concat(aHasNaN ^ bHasNaN ? [<span class="literal">NaN</span>] : []);</span><br><span class="line">  <span class="keyword">return</span> difference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">MDN ARRAY</a></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>Array的方法简单整理</category>
      </categories>
  </entry>
  <entry>
    <title>Date时间</title>
    <url>/2018/01/16/workspace/Js/date/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Date时间</strong></p>
<p>[[toc]]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间戳</span></span><br><span class="line"><span class="built_in">Date</span>.now()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置时间</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2019-06-16 07:55:55"</span>); <span class="comment">// Sun Jun 16 2019 07:55:55 GMT+0800 (中国标准时间)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间格式化 </span></span><br><span class="line">date2 = <span class="keyword">new</span> <span class="built_in">Date</span>().toISOString().slice(<span class="number">0</span>,<span class="number">10</span>);   <span class="comment">// 2019-06-16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> date2 <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure>

<h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 补0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillZero</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &gt;= <span class="number">10</span> ? num : <span class="string">"0"</span> + num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">timestamp, formatStr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timestamp) <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(timestamp)</span><br><span class="line">    <span class="keyword">let</span> year = date.getFullYear()</span><br><span class="line">    <span class="keyword">let</span> month = <span class="keyword">this</span>.fillZero(date.getMonth() + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> day = <span class="keyword">this</span>.fillZero(date.getDate())</span><br><span class="line">    <span class="keyword">let</span> hour = <span class="keyword">this</span>.fillZero(date.getHours())</span><br><span class="line">    <span class="keyword">let</span> minute = <span class="keyword">this</span>.fillZero(date.getMinutes())</span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">this</span>.fillZero(date.getSeconds())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> formatStr</span><br><span class="line">            .replace(<span class="string">'YYYY'</span>, year)</span><br><span class="line">            .replace(<span class="string">'MM'</span>, month)</span><br><span class="line">            .replace(<span class="string">'DD'</span>, day)</span><br><span class="line">            .replace(<span class="string">'HH'</span>, hour)</span><br><span class="line">            .replace(<span class="string">'mm'</span>, minute)</span><br><span class="line">            .replace(<span class="string">'ss'</span>, second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">timeStamp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(timeStamp);</span><br><span class="line">    <span class="keyword">return</span> date.getFullYear() + <span class="string">"年"</span></span><br><span class="line">        + (date.getMonth() + <span class="number">1</span>).toString().padStart(<span class="number">2</span>, <span class="number">0</span>) + <span class="string">"月"</span></span><br><span class="line">        + (date.getDate()).toString().padStart(<span class="number">2</span>, <span class="number">0</span>) + <span class="string">"日 "</span></span><br><span class="line">        + (date.getHours()).toString().padStart(<span class="number">2</span>, <span class="number">0</span>) + <span class="string">":"</span></span><br><span class="line">        + (date.getMinutes().toString().padStart(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="倒计时时间格式化"><a href="#倒计时时间格式化" class="headerlink" title="倒计时时间格式化"></a>倒计时时间格式化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format_time</span>(<span class="params">timeStamp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> day = <span class="built_in">Math</span>.floor(timeStamp / (<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">let</span> leave1 = timeStamp % (<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">let</span> hours = <span class="built_in">Math</span>.floor(leave1 / (<span class="number">3600</span> * <span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">let</span> leave2 = leave1 % (<span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">let</span> minutes = <span class="built_in">Math</span>.floor(leave2 / (<span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">let</span> leave3 = leave2 % (<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">let</span> seconds = <span class="built_in">Math</span>.floor(leave3 / <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (day) <span class="keyword">return</span> day + <span class="string">"天"</span> + hours + <span class="string">"小时"</span> + minutes + <span class="string">"分"</span>;</span><br><span class="line">    <span class="keyword">if</span> (hours) <span class="keyword">return</span> hours + <span class="string">"小时"</span> + minutes + <span class="string">"分"</span> + seconds + <span class="string">"秒"</span>;</span><br><span class="line">    <span class="keyword">if</span> (minutes) <span class="keyword">return</span> minutes + <span class="string">"分"</span> + seconds + <span class="string">"秒"</span>;</span><br><span class="line">    <span class="keyword">if</span> (seconds) <span class="keyword">return</span> seconds + <span class="string">"秒"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"时间到！"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="距离现在多久"><a href="#距离现在多久" class="headerlink" title="距离现在多久"></a>距离现在多久</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SECOND = <span class="number">1000</span></span><br><span class="line"><span class="keyword">const</span> MINUTE = SECOND * <span class="number">60</span></span><br><span class="line"><span class="keyword">const</span> HOUR = MINUTE * <span class="number">60</span></span><br><span class="line"><span class="keyword">const</span> DAY = HOUR * <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatToInterval</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">let</span> value = now - timestamp</span><br><span class="line">    value = value &lt; <span class="number">1</span> ? <span class="number">1</span> : value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; MINUTE) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.floor(value / SECOND) + <span class="string">'秒前'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; HOUR) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.floor(value / MINUTE) + <span class="string">'分钟前'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; DAY) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.floor(value / HOUR) + <span class="string">'小时前'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> format(timestamp, <span class="string">'MM月DD日'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
        <category>Date时间</category>
      </categories>
  </entry>
  <entry>
    <title>JS设计模式探索</title>
    <url>/2018/01/16/workspace/Js/design-pattern/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>JS设计模式探索</strong></p>
<p>[[toc]]</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = &#123;</span><br><span class="line"> name: <span class="string">'hzf'</span>,</span><br><span class="line"> age: <span class="number">24</span>,</span><br><span class="line"> walk: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.age); <span class="comment">//24</span></span><br><span class="line"> &#125;,</span><br><span class="line"> eat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//todo</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不足之处:<br/><ul>
<li>(1)没有什么封装性，所有的属性方法都是暴露的。<br/></li>
<li>(2)全局变量很容易造成命名空间污染。<br/></li>
<li>(3)对象一开始变创建，万一我们用不上就浪费了。<br/></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">// 这里声明私有变量和方法；</span></span><br><span class="line">     <span class="keyword">const</span> privateVariable = <span class="string">'私有的外面获取不到'</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">showPrivate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(privateVariable);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//公有的变量和方法(可以访问私有变量和方法);</span></span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">         publicMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             showPrivate();</span><br><span class="line">         &#125;,</span><br><span class="line">         publicVar: <span class="string">'共有的外面能直接获取'</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span>  single = person();</span><br><span class="line"></span><br><span class="line">single.publicMethod(); <span class="comment">// '私有的外面获取不到'</span></span><br><span class="line"><span class="built_in">console</span>.log(single.publicVar); <span class="comment">// '共有的外面能直接获取'</span></span><br></pre></td></tr></table></figure>


<h3 id="发布订阅模式-观察者模式"><a href="#发布订阅模式-观察者模式" class="headerlink" title="发布订阅模式+观察者模式"></a>发布订阅模式+观察者模式</h3><p>如下图所示：</p>
<img style="width:50%" src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hd0dd34b5adf14ea1a3b9648fa8fa1507b.jpg">

<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>观察者和被观察者一般是<code>直接联系</code>的，相互知道对方的存在。</p>
<p>观察者一般是同步的，被观察者一旦有变化，观察者会立即发生反应</p>
<p><code>Subject</code> - 被观察者，发布者;</p>
<p><code>Observer</code> - 观察者，订阅者；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>. observers = []; <span class="comment">// 观察者列表</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加订阅者</span></span><br><span class="line">  add(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除...</span></span><br><span class="line">  remove(observer) &#123;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="keyword">this</span>.observers.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item === observer);</span><br><span class="line">    idx &gt; <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>.observers.splice(idx, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知  全部执行</span></span><br><span class="line">  notify(boss) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> o <span class="keyword">of</span> <span class="keyword">this</span>.observers) &#123;</span><br><span class="line">      o.update(boss);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 目标对象更新时触发的回调，即收到更新通知后的回调</span></span><br><span class="line">  update(boss) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;boss&#125;</span>通知我职位了，我是：<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 实例化目标者</span></span><br><span class="line"><span class="keyword">let</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 实例化两个观察者</span></span><br><span class="line"><span class="keyword">let</span> obs1 = <span class="keyword">new</span> Observer(<span class="string">'高级前端开发工程师'</span>);</span><br><span class="line"><span class="keyword">let</span> obs2 = <span class="keyword">new</span> Observer(<span class="string">'初级后端开发工程师'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 向目标者添加观察者</span></span><br><span class="line">subject.add(obs1);</span><br><span class="line">subject.add(obs2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知</span></span><br><span class="line">subject.notify(<span class="string">'HR'</span>);</span><br><span class="line">subject.notify(<span class="string">'CTO'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><p>发布者和订阅者是解耦的，他们是通过一个<code>介质</code>（往往是消息队列）执行代码</p>
<p>发布订阅模式由于是消息队列代理的存在，往往是异步的</p>
<p><strong>代码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制中心</span></span><br><span class="line"><span class="keyword">let</span> pubSub = &#123;</span><br><span class="line">  list: &#123;&#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  subscribe: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.list[key]) <span class="keyword">this</span>.list[key] = [];</span><br><span class="line">    <span class="comment">//可能是多个</span></span><br><span class="line">    <span class="keyword">this</span>.list[key].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//取消订阅</span></span><br><span class="line">  unsubscribe: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fnList = <span class="keyword">this</span>.list[key];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!fnList) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123; <span class="comment">// 不传入指定的方法，清空所用 key 下的订阅</span></span><br><span class="line">      fnList &amp;&amp; (fnList.length = <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> curFn =  fnList.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  item !== fn </span><br><span class="line">      &#125;);</span><br><span class="line">     <span class="keyword">this</span>.list[key]=curFn</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 发布</span></span><br><span class="line">  publish: <span class="function"><span class="keyword">function</span>(<span class="params">key, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> <span class="keyword">this</span>.list[key]) fn.call(<span class="keyword">this</span>, ...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="function"><span class="keyword">function</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`上班了：<span class="subst">$&#123;time&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="function"><span class="keyword">function</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`下班了：<span class="subst">$&#123;time&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">pubSub.subscribe(<span class="string">'onwork'</span>,sub1 )</span><br><span class="line">pubSub.subscribe(<span class="string">'onwork'</span>, sub2 )</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">pubSub.publish(<span class="string">'onwork'</span>, <span class="string">'18:00:00'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">pubSub.unsubscribe(<span class="string">'onwork'</span>);</span><br></pre></td></tr></table></figure>



<p><strong>DOM 的事件监听是”发布订阅模式”</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>  hzf = <span class="built_in">document</span>.getElementById(<span class="string">'#hzf'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 监听回调函数（指定事件）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notifyClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我被点击了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加事件监听</span></span><br><span class="line">hzf.addEventListener(<span class="string">'click'</span>, notifyClick);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户触发点击, 事件中心派发指定事件</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 取消事件监听</span></span><br><span class="line">loginBtn.removeEventListener(<span class="string">'click'</span>, notifyClick);</span><br></pre></td></tr></table></figure>

<h4 id="两种模式的关联和区别"><a href="#两种模式的关联和区别" class="headerlink" title="两种模式的关联和区别"></a>两种模式的关联和区别</h4><p>发布订阅模式更灵活，是进阶版的观察者模式，<code>指定</code>对应分发。</p>
<p>观察者模式维护<code>单一</code>事件对应多个依赖该事件的对象关系；<br/><br>发布订阅维护<code>多个</code>事件（主题）及依赖各事件（主题）的对象之间的关系；</p>
<p>观察者模式是目标对象直接触发通知（全部通知），观察对象被迫接收通知。<br/><br>发布订阅模式多了个中间层（事件中心），由其去管理通知广播（只通知订阅对应事件的对象）；</p>
<p>观察者模式对象间依赖关系较强，发布订阅模式中对象之间实现真正的解耦。</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://juejin.im/post/5c0a9d9bf265da612909ff1b" target="_blank" rel="noopener">观察者模式 vs 发布订阅模式</a></p>
<p><a href="https://juejin.im/post/5d25a2316fb9a07f04207010" target="_blank" rel="noopener">观察者模式与发布订阅模式</a></p>
<p><a href="https://juejin.im/post/591a4f2a128fe1005cda28df" target="_blank" rel="noopener">观察者模式</a></p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h3 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……."></a>未完待续…….</h3>]]></content>
      <categories>
        <category>JS</category>
        <category>JS设计模式探索</category>
      </categories>
  </entry>
  <entry>
    <title>自定义事件</title>
    <url>/2020/08/28/workspace/Js/dispatchEvent/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>自定义事件</strong></p>
<p>[[toc]]</p>
<h3 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a>dispatchEvent</h3><p><strong>已废弃</strong></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/Event" target="_blank" rel="noopener">initEvent</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*<span class="doctag">TODO:</span> 基于浏览器原生事件做通信*/</span></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="built_in">window</span>.evt = <span class="built_in">document</span>.createEvent(<span class="string">"HTMLEvents"</span>);</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">window</span>.evt.initEvent(<span class="string">"handleData"</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 触发</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'handleData'</span>, <span class="keyword">this</span>.handelData, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h4 id="createEvent"><a href="#createEvent" class="headerlink" title="createEvent()"></a>createEvent()</h4><p><code>createEvent()</code>方法返回新创建的Event对象，支持一个参数，表示事件类型，具体见下表：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>事件接口</th>
<th>初始化方法</th>
</tr>
</thead>
<tbody><tr>
<td>HTMLEvents</td>
<td>HTMLEvent</td>
<td>initEvent()</td>
</tr>
<tr>
<td>MouseEvents</td>
<td>MouseEvent</td>
<td>initMouseEvent()</td>
</tr>
<tr>
<td>UIEvents</td>
<td>UIEvent</td>
<td>initUIEvent()</td>
</tr>
</tbody></table>
<h4 id="initEvent"><a href="#initEvent" class="headerlink" title="initEvent()"></a>initEvent()</h4><p><code>initEvent()</code>方法用于初始化通过<code>DocumentEvent</code>接口创建的Event的值。</p>
<p>支持三个参数：<code>initEvent(eventName, canBubble, preventDefault)</code><br> 分别表示：</p>
<ul>
<li>事件名称</li>
<li>是否可以冒泡</li>
<li>是否阻止事件的默认操作</li>
</ul>
<h4 id="dispatchEvent-1"><a href="#dispatchEvent-1" class="headerlink" title="dispatchEvent()"></a>dispatchEvent()</h4><p><code>dispatchEvent()</code>就是触发执行了，<code>dom.dispatchEvent(eventObject)</code><br> 参数<code>eventObject</code>表示事件对象，是<code>createEvent()</code>方法返回的创建的<code>Event</code>对象。</p>
<h3 id="Event-单向"><a href="#Event-单向" class="headerlink" title="Event (单向)"></a>Event (单向)</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/Event" target="_blank" rel="noopener">Event</a></p>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event = <span class="keyword">new</span> Event(typeArg, eventInit);</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> typeArg 事件名称</span><br><span class="line"><span class="number">2.</span> eventInit</span><br><span class="line">  <span class="string">"bubbles"</span>，可选 默认值为 <span class="string">`false`</span>，表示该事件是否冒泡。</span><br><span class="line">  <span class="string">"cancelable"</span>，可选 默认值为 <span class="string">`false`</span>， 表示该事件能否被取消。</span><br><span class="line">  <span class="string">"composed"</span>，可选 默认值为 <span class="string">`false`</span>，指示事件是否会在影子DOM根节点之外触发侦听器。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ev = <span class="keyword">new</span> Event(<span class="string">"look"</span>, &#123;<span class="string">"bubbles"</span>:<span class="literal">true</span>, <span class="string">"cancelable"</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听事件</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'look'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; ... &#125;, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(ev);</span><br><span class="line"><span class="comment">// 事件可以在任何元素触发，不仅仅是document</span></span><br><span class="line">myDiv.dispatchEvent(ev);</span><br></pre></td></tr></table></figure>



<h3 id="CustomEvent（多向）"><a href="#CustomEvent（多向）" class="headerlink" title="CustomEvent（多向）"></a>CustomEvent（多向）</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent" target="_blank" rel="noopener">CustomEvent</a></p>
<p><code>CustomEvent</code> 可以创建一个更高度自定义事件，还可以附带一些数据，具体用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> CustomEvent(eventname, options);</span><br><span class="line">其中 options 可以是：</span><br><span class="line">&#123;</span><br><span class="line">  detail: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;, <span class="comment">// 初始化事件时传递的所有数据。</span></span><br><span class="line">  bubbles: <span class="literal">true</span>,    <span class="comment">//是否冒泡</span></span><br><span class="line">  cancelable: <span class="literal">false</span> <span class="comment">//是否取消默认事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父应用 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   mounted() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">createEvent</span>(<span class="params">params, eventName = <span class="string">'look'</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 数据必须挂载到detail上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomEvent(eventName, &#123;<span class="attr">detail</span>: params&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 初始化</span></span><br><span class="line">      <span class="built_in">window</span>.cEvt = createEvent(&#123;<span class="attr">handelData</span>: <span class="keyword">this</span>.handelData&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handelData(...opt) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ary.push(...opt)</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">this</span>.ary = _.uniqWith(<span class="keyword">this</span>.ary, _.isEqual);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ary</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子应用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   methods: &#123;</span><br><span class="line">     queryData(&#123;<span class="attr">detail</span>: &#123;handelData&#125;&#125;) &#123;</span><br><span class="line">       <span class="comment">// 返回当前传入的值</span></span><br><span class="line">       <span class="keyword">const</span> data =  handelData(&#123;<span class="attr">ary</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="attr">msg</span>: <span class="string">'子传父'</span>&#125;);</span><br><span class="line">     &#125;,</span><br><span class="line">     dispatchData() &#123;</span><br><span class="line">       <span class="comment">// 子应用触发当前函数</span></span><br><span class="line">       <span class="built_in">document</span>.addEventListener(<span class="string">'look'</span>, <span class="keyword">this</span>.queryData);</span><br><span class="line">       <span class="comment">// 发起事件</span></span><br><span class="line">       <span class="built_in">document</span>.dispatchEvent(<span class="built_in">window</span>.cEvt);</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;,</span><br><span class="line">   mounted() &#123;</span><br><span class="line">      <span class="comment">// 移除事件监听器。</span></span><br><span class="line">      <span class="keyword">this</span>.$once(<span class="string">'hook:beforeDestroy'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">'look'</span>, <span class="keyword">this</span>.queryData);</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
        <category>自定义事件</category>
      </categories>
  </entry>
  <entry>
    <title>ES6-新增特性一览</title>
    <url>/2019/01/16/workspace/Js/es6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>ES6-新增特性一览</strong></p>
<p>[[toc]]</p>
<h3 id="1-let-const取代var"><a href="#1-let-const取代var" class="headerlink" title="1. let/const取代var"></a>1. let/const取代var</h3><h3 id="2-字符串模板"><a href="#2-字符串模板" class="headerlink" title="2. 字符串模板"></a>2. 字符串模板</h3><h3 id="3-对象解构"><a href="#3-对象解构" class="headerlink" title="3. 对象解构"></a>3. 对象解构</h3><h3 id="4-新数据类型-Symbol"><a href="#4-新数据类型-Symbol" class="headerlink" title="4. 新数据类型 Symbol"></a>4. 新数据类型 Symbol</h3><h3 id="5-新数据结构Map-Set-WeakMap-WeakSet"><a href="#5-新数据结构Map-Set-WeakMap-WeakSet" class="headerlink" title="5. 新数据结构Map/Set/WeakMap/WeakSet"></a>5. 新数据结构<a href="https://github.com/lukehoban/es6features#map--set--weakmap--weakset" target="_blank" rel="noopener">Map/Set/WeakMap/WeakSet</a></h3><h3 id="6-Proxy、Reflect"><a href="#6-Proxy、Reflect" class="headerlink" title="6. Proxy、Reflect"></a>6. <a href="https://github.com/lukehoban/es6features#proxies" target="_blank" rel="noopener">Proxy</a>、<a href="https://www.cnblogs.com/zczhangcui/p/6486582.html" target="_blank" rel="noopener">Reflect</a></h3><h3 id="7-扩展"><a href="#7-扩展" class="headerlink" title="7. 扩展"></a>7. 扩展</h3><ul>
<li><p>字符串填充（padStart 和 padEnd）</p>
</li>
<li><p>Array</p>
<ul>
<li>Array.from()</li>
<li>Array.of()</li>
<li>Array.copyWithin()</li>
<li>Array.find()</li>
<li>Array.findIndex()</li>
<li>Array.fill()</li>
<li>Array.includes()<sup><code>ES7</code></sup></li>
</ul>
</li>
<li><p>Object</p>
<ul>
<li>Object.keys()</li>
<li>Object.values()<sup><code>ES8</code></sup></li>
<li>Object.entries()<sup><code>ES8</code></sup></li>
<li>Object.assign()</li>
<li>Object. is()</li>
</ul>
</li>
</ul>
<h3 id="8-异步"><a href="#8-异步" class="headerlink" title="8. 异步"></a>8. 异步</h3><ul>
<li><a href="https://github.com/lukehoban/es6features#promises" target="_blank" rel="noopener">Promise</a><ul>
<li>Promise.prototype.then</li>
<li>Promise.prototype.catch</li>
<li>Promise.prototype.finally<sup><code>ES9</code></sup></li>
<li>Promise.all()</li>
<li>Promise.rece()</li>
</ul>
</li>
<li><a href="https://github.com/lukehoban/es6features#iterators--forof" target="_blank" rel="noopener">Iterator</a><ul>
<li>Iterator接口</li>
<li>for of</li>
</ul>
</li>
<li><a href="https://github.com/lukehoban/es6features#generators" target="_blank" rel="noopener">Generator</a><ul>
<li>yield*</li>
</ul>
</li>
<li>async/await<sup><code>ES8</code></sup></li>
</ul>
<h3 id="9-Class类"><a href="#9-Class类" class="headerlink" title="9. Class类"></a>9. Class类</h3><ul>
<li>class</li>
<li>extends</li>
<li>decorator<sup><code>ES7</code></sup></li>
</ul>
<h3 id="10-Module"><a href="#10-Module" class="headerlink" title="10. Module"></a>10. Module</h3><ul>
<li>import</li>
<li>export</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// export default 方式</span></span><br><span class="line"><span class="keyword">import</span> defaultName <span class="keyword">from</span> <span class="string">'modules.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export type 方式</span></span><br><span class="line"><span class="keyword">import</span> &#123; export1, export2 &#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 <span class="keyword">as</span> ex1, export2 <span class="keyword">as</span> ex2 &#125; <span class="keyword">from</span> <span class="string">'moduls.js'</span>; <span class="comment">// as 关键字</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moduleName <span class="keyword">from</span> <span class="string">'modules.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时引入export default 和export type</span></span><br><span class="line"><span class="keyword">import</span> defaultName, &#123; expoprt1, export2 &#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br><span class="line"><span class="keyword">import</span> defaultName， * <span class="keyword">as</span> moduleName <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入无输出模块</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'modules'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/87699079" target="_blank" rel="noopener">司徒正美</a></p>
</li>
<li><p><a href="https://github.com/lukehoban/es6features" target="_blank" rel="noopener">es6features</a></p>
</li>
<li><p><a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md" target="_blank" rel="noopener">Finished Proposals</a></p>
</li>
<li><p><a href="http://es6.ruanyifeng.com/#docs/reference" target="_blank" rel="noopener">ryf es6 reference</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6-新增特性一览</category>
      </categories>
  </entry>
  <entry>
    <title>Event-Loop</title>
    <url>/2019/01/11/workspace/Js/eventloop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Event-Loop</strong></p>
<p>[[toc]]</p>
<h3 id="同步-amp-异步-amp-多线程"><a href="#同步-amp-异步-amp-多线程" class="headerlink" title="同步 &amp; 异步 &amp; 多线程"></a>同步 &amp; 异步 &amp; 多线程</h3><p><strong>同步与异步的区别</strong></p>
<p>同步（Synchronous）：在执行某个操作时，应用程序<code>必须等待该操作执行完成后</code>才能继续执行。<br/><br>异步（Asynchronous）：在执行某个操作时，应用程序可在异步操作执行时继续执行。实质：异步操作，启动了新的，线程主线程与方法线程并行执行。<code>异步任务是不会进入主线程，而是会先进入任务队列</code><br/></p>
<p><strong>异步和多线程的区别</strong></p>
<p>我们已经知道， 异步和多线程并不是一个同等关系,<code>异步是最终目的</code>,<code>多线程只是我们实现异步的一种手段</code>。<br>异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。</p>
<p>简单的说就是：异步线程是由<code>线程池</code>负责管理，而多线程，我们可以<code>自己控制</code>，当然在多线程中我们也可以使用线程池。</p>
<p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">运行机制详解</a></p>
<h3 id="JS中的异步操作"><a href="#JS中的异步操作" class="headerlink" title="JS中的异步操作"></a>JS中的异步操作</h3><ul>
<li>定时函数，如setTimeout setInterval requestAnimationFrame setImmediate(nodeJS) </li>
<li>IO 操作，如readFile readdir</li>
<li>网络请求，如ajax http.get（也可以同步，但是等待ajax请求响应之前，页面会卡住，用户什么都做不了,体验差）</li>
</ul>
<p>这两个看你怎么说了</p>
<ul>
<li>事件绑定都是异步操作 <br/><br>除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</li>
<li>回调函数可以理解为异步（不是严谨的异步操作，同步回调，异步回调）<br/><br>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</li>
</ul>
<h3 id="event-loop（事件轮询）"><a href="#event-loop（事件轮询）" class="headerlink" title="event-loop（事件轮询）"></a>event-loop（事件轮询）</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hc9dd012443fb4f35bcd41ef829e72834k.jpg" alt=""></p>
<p>主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，<br>它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”<strong>任务队列（task queue）</strong>“，依次执行那些事件所对应的回调函数</p>
<h3 id="宏任务-amp-微任务"><a href="#宏任务-amp-微任务" class="headerlink" title="宏任务 &amp; 微任务"></a>宏任务 &amp; 微任务</h3><ul>
<li><p><strong>浏览器的任务队列:</strong><br> -主任务队列:存储的都是同步任务</p>
<ul>
<li>等待任务队列:存储的都是异步任务</li>
</ul>
</li>
<li><p><strong>微任务:</strong></p>
<ul>
<li>Promise的then回调函数</li>
<li>async函数中await下面的代码</li>
<li>process.nextTick（nodeJS）</li>
<li>MutationObserver</li>
</ul>
</li>
<li><p><strong>宏任务:</strong></p>
<ul>
<li>定时器(setInterval/setTimeout)</li>
<li>requestAnimationFrame</li>
<li>setImmediate(nodeJS)</li>
</ul>
</li>
</ul>
<p><strong>微任务的优先级⽐宏任务的优先级要高</strong></p>
<h3 id="async-await-和-promise-的执行顺序"><a href="#async-await-和-promise-的执行顺序" class="headerlink" title="async/await 和 promise 的执行顺序"></a>async/await 和 promise 的执行顺序</h3><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p><strong>带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象</strong>,async 函数也没啥了不起的，你就想它无非就是把return值包装了一下，其他就跟普通函数一样,重点是里面的await。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn1())</span><br><span class="line"><span class="built_in">console</span>.log(fn2())</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Promise &#123;&lt;resolved&gt;: 123&#125;</span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>await等待的是右侧「表达式」的结果</p>
<p>对于await来说，分2个情况</p>
<ul>
<li>不是promise对象</li>
<li>是promise对象</li>
</ul>
<p><strong>如果不是 promise（会被转成一个立即resolve的 Promise 对象） , await会阻塞后面（并非await后面那个函数）的代码，先执行async函数<code>外面</code>的同步代码，同步代码执行完，再回到async内部，据需执行下面的方法</strong></p>
<p><strong>如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async函数<code>外面</code>的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果，然后在继续向下执行剩余的代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ff = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>); <span class="comment">//【1】</span></span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)<span class="comment">//【2】</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">11</span>);<span class="comment">//【3】</span></span><br><span class="line">            resolve(<span class="number">22</span>)</span><br><span class="line">        &#125;).then(</span><br><span class="line">            (data) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);<span class="comment">//【4】</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'外面'</span>)<span class="comment">//【5】</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解析：async函数下的方法，就想成跟普通的函数一样的就行，函数先执行【1】然后执行到await执行的async2，Promise内部相当于同步函数，然后执行【3】，</span></span><br><span class="line"><span class="comment">然后执行async外面的方法，发现没有，然后又回到ff函数内部，执行resolve里面的函数【4】,最后就该轮到【2】和【4】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* async1 start</span></span><br><span class="line"><span class="comment">* 11</span></span><br><span class="line"><span class="comment">* 22</span></span><br><span class="line"><span class="comment">* async1 end</span></span><br><span class="line"><span class="comment">* 外面</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> ff = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">        <span class="keyword">await</span> async2();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">11</span>);</span><br><span class="line">            a(<span class="number">22</span>)</span><br><span class="line">        &#125;).then(</span><br><span class="line">            (data) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    async1();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'外面'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解析：跟上面的一样，就是在ff重新声明一个async1函数，这种比上面那种更加实用，不会堵塞async1外面的同步代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* async1 start</span></span><br><span class="line"><span class="comment">* 11</span></span><br><span class="line"><span class="comment">* 外面</span></span><br><span class="line"><span class="comment">* 22</span></span><br><span class="line"><span class="comment">* async1 end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>面试题</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ff = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">        <span class="keyword">await</span> async2()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">            a(<span class="string">'async222'</span>)</span><br><span class="line">        &#125;).then(</span><br><span class="line">            (data) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    async1();</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://segmentfault.com/a/1190000017224799" target="_blank" rel="noopener">参考文档</a></p>
<p><a href="https://www.cnblogs.com/jiasm/p/9482443.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiasm/p/9482443.html</a></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>Event-Loop</category>
      </categories>
  </entry>
  <entry>
    <title>for in和for of区别</title>
    <url>/2018/01/16/workspace/Js/for-in-for-of/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>for in和for of区别</strong></p>
<p>[[toc]]</p>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><p>以任意顺序遍历一个对象的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties" target="_blank" rel="noopener">可枚举属性</a>。遍历数组时，key为数组下标字符串；遍历对象，key为对象字段名。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">age</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">age</span>: <span class="number">5</span>&#125;, &#123;<span class="attr">age</span>: <span class="number">100</span>&#125;, &#123;<span class="attr">age</span>: <span class="number">34</span>&#125;]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, arr[key])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// 0 &#123;age: 1&#125;</span></span><br><span class="line"><span class="comment">// 1 &#123;age: 5&#125;</span></span><br><span class="line"><span class="comment">// 2 &#123;age: 100&#125;</span></span><br><span class="line"><span class="comment">// 3 &#123;age: 34&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[key]); <span class="comment">// 会正常打印 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果在 Array 原型链上添加一个方法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[key]); <span class="comment">// 此时会打印 1, 2, ƒ () &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">f1</span>: <span class="string">'test1'</span>, <span class="attr">f2</span>: <span class="string">'test2'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, obj[key])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// f1 test1</span></span><br><span class="line"><span class="comment">// f2 test2</span></span><br></pre></td></tr></table></figure>



<h4 id="for-in-缺点"><a href="#for-in-缺点" class="headerlink" title="for in 缺点"></a>for in 缺点</h4><ol>
<li>for in 迭代顺序依赖于执行环境，不一定保证顺序</li>
<li>for in 不仅会遍历当前对象，还包括原型链上的可枚举属性</li>
<li>for in 没有break中断</li>
<li>for in 不适合遍历数组，主要应用为对象</li>
</ol>
<h4 id="Object-keys-和for-in的区别"><a href="#Object-keys-和for-in的区别" class="headerlink" title="Object.keys()和for in的区别"></a>Object.keys()和for in的区别</h4><ul>
<li>遍历结果为由对象自身可枚举属性组成的<code>数组</code>，数组中的属性名排列顺序与使用for in循环遍历该对象时返回的顺序一致；</li>
<li>与for in区别在于<code>不能遍历</code>出原型链上的属性；</li>
</ul>
<h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><p>ES6引入的新语法。在<code>可迭代对象</code>（包括 Array，Map，Set，String，TypedArray，arguments对象，NodeList对象）上创建一个迭代循环,调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<p><code>Object对象不是可迭代对象，故for of 不支持。</code>for of有个很大的特点是支持数组的break中断。</p>
<h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">age</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">age</span>: <span class="number">5</span>&#125;, &#123;<span class="attr">age</span>: <span class="number">100</span>&#125;, &#123;<span class="attr">age</span>: <span class="number">34</span>&#125;]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> &#123;age&#125; <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// for of 允许中断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="三个数组：arr1-1-2-3-4-arr2-4-5-6-arr3-5-将arr1与arr2合并，去重，然后返回不包含arr3中元素的新数组（用es6标准的新特性实现）"><a href="#三个数组：arr1-1-2-3-4-arr2-4-5-6-arr3-5-将arr1与arr2合并，去重，然后返回不包含arr3中元素的新数组（用es6标准的新特性实现）" class="headerlink" title="三个数组：arr1=[1,2,3,4],arr2=[4,5,6],arr3=[5],将arr1与arr2合并，去重，然后返回不包含arr3中元素的新数组（用es6标准的新特性实现）"></a>三个数组：arr1=[1,2,3,4],arr2=[4,5,6],arr3=[5],将arr1与arr2合并，去重，然后返回不包含arr3中元素的新数组（用es6标准的新特性实现）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], arr3 = [<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr1, arr2, arr3</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ary4 = [...arr1, ...arr2];</span><br><span class="line">    <span class="keyword">let</span> ary5 = [...new <span class="built_in">Set</span>(ary4)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [ind, item] <span class="keyword">of</span> ary5.entries()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr3.includes(item)) &#123;</span><br><span class="line">            ary5.splice(ind, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ary5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for-of-优点"><a href="#for-of-优点" class="headerlink" title="for of 优点"></a>for of 优点</h4><ol>
<li>for of 有与for in 一样的简洁语法（这也是两者容易混乱的点），但没有for in的缺点</li>
<li>for of 保证顺序且不会仅遍历当前对象</li>
<li>for of 可与break，continue，return配合</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
        <category>for in和for of区别</category>
      </categories>
  </entry>
  <entry>
    <title>堆内存 &amp; 栈内存</title>
    <url>/2019/05/16/workspace/Js/heap_stack/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>堆内存 &amp; 栈内存</strong></p>
<p>[[toc]]</p>
<p>前几天面试刚问到的 ，这几天有空话总结下 </p>
<p>在js引擎中对变量的存储主要有两种内存，堆内存（heap）和栈内存（stack），下面从三个方面简单介绍</p>
<h3 id="存储角度"><a href="#存储角度" class="headerlink" title="存储角度"></a>存储角度</h3><p><strong>栈内存</strong> 主要用于存储各种基本类型的变量，包括<code>Boolean、Number、String、Undefined、Null</code>以及对象变量的<code>指针</code>，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。</p>
<p><strong>堆内存</strong> 主要负责像对象<code>Object</code>这种变量类型的存储</p>
<p>盗用一张图</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H98e4d550d5d444d9b8d1666c70024915J.png" alt=""></p>
<p>我们平时用<code>const</code>定义的常量，如果是引用数据类型的话，仅仅是在栈内存保存的一个指针，而对于const定义的基础变量而言，这个值就相当于const对象的指针，是不可变。当<code>let cosnt</code>在重新声明的时候，会首先遍历当前的<code>内存栈</code>，看看有没有重名变量，有的话就返回错误</p>
<h3 id="存取速度"><a href="#存取速度" class="headerlink" title="存取速度"></a>存取速度</h3><p>栈区由于基本数据类型值比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存储进去的，系统分配效率高，存取速度快</p>
<p>堆内存首先要在运行时动态分配内存，之后又要把指针存储到栈内存中，效率相对就要低一些了。</p>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>栈区GC比较频繁，变量基本上用完就回收了</p>
<p>堆区内存中的变量因为存在很多不确定的引用，一般由程序员分配释放， 若程序员不释放，程序结束时才可能被销毁</p>
]]></content>
      <categories>
        <category>JS</category>
        <category>堆内存 &amp; 栈内存</category>
      </categories>
  </entry>
  <entry>
    <title>输入URL背后的技术步骤</title>
    <url>/2018/01/16/workspace/Js/http-base/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>输入URL背后的技术步骤</strong></p>
<p>[[toc]]</p>
<p>一道经典的面试题，涵盖的知识点非常多，这里解答下该问题，以对自己的知识体系进行梳理。</p>
<ol>
<li>系统层<ol>
<li>发起http请求，解析域名</li>
<li>DNS<ol>
<li>Chrome搜索自身DNS缓存。chrome输入<code>chrome://net-internals/#dns</code>可查看到</li>
<li>搜索操作系统自身DNS缓存</li>
<li>读取本地HOST文件</li>
<li>以上都查询不到时，浏览器发送一个DNS的系统调用，DNS请求到达宽带运营商服务器。</li>
<li>宽带运营商服务器查询自身缓存</li>
<li>没查询时，发起一个迭代（顶级域–次级域名–…）的DNS解析请求,直到获取到域名对应的IP地址。</li>
</ol>
</li>
<li>拿到域名对应的IP并缓存<ol>
<li>宽带运营商服务器缓存DNS</li>
<li>结果返回操作系统并缓存DNS</li>
<li>结果返回浏览器并缓存DNS</li>
</ol>
</li>
<li>得到目标IP，发起Http“三次握手”，建立起TCP/IP连接<ol>
<li>客户端发送一个带有SYN标志的数据包给服务端</li>
<li>服务器发回确认包SYN/ACK标志的数据</li>
<li>客户端再发送确认包ACK标志的数据包给服务端</li>
</ol>
</li>
<li>连接成功后，浏览器向服务器发起标准Http请求<ol>
<li>构建Http请求报文<ul>
<li>请求行。<ul>
<li>格式：Method Request-URL HTTP-Version CRLF，如：GET index.html HTTP/1.1</li>
<li>Method可选项：GET, POST, PUT, DELETE, OPTIONS, HEAD</li>
</ul>
</li>
<li>请求报头<ul>
<li>允许客户端向服务器传递请求的附加信息</li>
<li>常见请求报头：Content-Type, Cache-Control,CookieAccept-Encoding,Accept-Language,等</li>
</ul>
</li>
<li>请求正文<ul>
<li>当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。</li>
</ul>
</li>
</ul>
</li>
<li>通过TCP协议，发送到服务器指定端口（Http协议默认80端口、Https协议默认443）</li>
</ol>
</li>
<li>服务器收到请求后，经过后端处理返回结果。（前后端分离）<ul>
<li>响应报文<ul>
<li>状态码<ul>
<li>1xx：指示信息–表示请求已接收，继续处理。</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>
</ul>
</li>
<li>响应报头</li>
<li>响应报文</li>
</ul>
</li>
</ul>
</li>
<li>返回Html页面等资源，html包含css/js等资源，重复以上http请求</li>
</ol>
</li>
<li>渲染层<ol>
<li>Chrome浏览器的渲染引擎 Blink（常说的浏览器内核）边接收边解析 HTML 内容，浏览器自上而下逐行解析 HTML 内容，经过词法分析、语法分析，<code>构建 DOM 树</code>。HTML文档被加载和解析完成时（DOM树构建完成），触发DOMContentLoaded事件，此时页面可以渲染展示出内容了。（html引用的图片可能还在http请求加载，当所有资源全部请求完成，触发load事件）<ul>
<li>当遇到外部 CSS 链接时，不阻塞而继续构建 DOM 树。</li>
<li>当遇到外部 JS 链接时，异步获取资源。JS下载后，V8引擎（常说的JavaScript引擎）会解析、编译JS内容。由于 JS 可能会修改 DOM 树和 CSSOM 树而造成回流和重绘，故JS会阻塞DOM树的构建。</li>
</ul>
</li>
<li>下载CSS后，主线程会在合适时机解析CSS内容，<code>构建 CSSOM 树</code>。本来构建DOM树和CSSOM树是并行的，互不影响，但当解析到上文提到的JavaScript时，需要构建完成CSSOM树后，才能执行js代码（DOM树此时被刮起），因为js可以查询/修改任意对象的样式，此时需要CSSOM树构建完成。</li>
<li>浏览器结合 DOM 树和 CSSOM 树<code>构建 Render 树</code>。Render树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。</li>
<li>浏览器渲染（布局 + 绘制 + 复合图层化），布局（Layout）环节主要负责各元素尺寸、位置的计算，绘制（Paint）环节则是绘制页面像素信息，合成（Composite）环节是多个复合层的合成，最终合成的页面被用户看到。<ol>
<li>回流：DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等</li>
<li>重绘：当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H258f15ed94f94b36b10619fde4732b6bn.jpg" alt="image"></p>
<blockquote>
<p>html内容从上到下解析，浏览器遇到body标签开始显示内容。CSS 不会阻塞 DOM 的解析，JS 会阻止DOM的解析。</p>
</blockquote>
<blockquote>
<p>当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。</p>
</blockquote>
<blockquote>
<p>现代浏览器都使用了预加载器，在js挂起DOM解析时，会继续解析后面的html，寻找需要下载的资源。预加载器下载这些资源，以减少JS阻塞带来的影响。</p>
</blockquote>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>了解以上，我们就能知道以下这些前端优化点：</p>
<ul>
<li><strong>http请求数减少</strong>，如：雪碧图、合并CSS/JS文件、缓存资源等（针对http1.1）</li>
<li><strong>http请求资源体积减少</strong>，如：启用gzip压缩、图片压缩、减少cookie、按需加载等</li>
<li><strong>css放在head中</strong>。由于同时具有 DOM 和 CSSOM 才能构建渲染树，所以HTML 和 CSS 都是阻塞渲染的资源，所以尽量精简CSS也是优化方式之一。</li>
<li><strong>js放在body底部</strong>，减少白屏时间。因为js会阻止浏览器解析。</li>
<li><strong>减少回流和重绘制</strong>，比如不要一条一条修改DOM样式、使用documentFragment操作DOM等。</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol>
<li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</li>
<li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1</li>
</ol>
<h3 id="三次握手四次挥手面试题"><a href="#三次握手四次挥手面试题" class="headerlink" title="三次握手四次挥手面试题"></a>三次握手四次挥手面试题</h3><p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p>
<p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，<br>它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。<br>但关闭连接时，当收到对方的FIN报文通知时，<code>它仅仅表示对方没有数据发送给你了；
但未必你所有的数据都全部发送给对方了</code>，<br>所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，<br>再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">从输入URL到页面加载发生了什么？</a></li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>输入URL背后的技术步骤</category>
      </categories>
  </entry>
  <entry>
    <title>技术清单</title>
    <url>/2018/01/16/workspace/Js/home/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>技术清单</strong></p>
<p>[[toc]]</p>
<h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p>localStorage的库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn add store</span><br></pre></td></tr></table></figure>

<p>JS检测本地储存localStorage的变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'storage'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>IndexedDB的库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn add hello-indexeddb</span><br></pre></td></tr></table></figure>

<h2 id="页面直接编辑"><a href="#页面直接编辑" class="headerlink" title="页面直接编辑"></a>页面直接编辑</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.contentEditable = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><p><code>defineProperty</code>版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"input"</span>&gt;</span><br><span class="line">&lt;span id=<span class="string">"text"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">'text'</span>, &#123;</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line"></span><br><span class="line">        input.value = value;</span><br><span class="line">        text.innerText = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>(val) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'获取值'</span>, <span class="keyword">this</span>);  <span class="comment">//this就是当前的对象</span></span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">input.oninput = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data.text = e.target.value);</span><br><span class="line">    <span class="built_in">console</span>.log(data.text);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>proxy</code>版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"input"</span>&gt;</span><br><span class="line">&lt;span id=<span class="string">"text"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, key, value) &#123;  <span class="comment">//当前对象  key  当前值</span></span><br><span class="line">        target[key] = value;</span><br><span class="line">        input.value = value;</span><br><span class="line">        text.innerText = value;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>(obj, value, target) &#123;<span class="comment">//&#123;key:当前值&#125; 当前值 当前对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'获取值'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, handler);</span><br><span class="line"></span><br><span class="line">input.oninput = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    proxy.text1 = e.target.value</span><br><span class="line">    <span class="built_in">console</span>.log(proxy.text2 = e.target.value);</span><br><span class="line">    <span class="built_in">console</span>.log(proxy.text1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="节流防抖"><a href="#节流防抖" class="headerlink" title="节流防抖"></a>节流防抖</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到并返回应项的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>list list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>music 查找对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> findIndex = <span class="function">(<span class="params">list, music</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> list.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.id === music.id</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 防抖函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (current - now &gt;= delay) &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      now = current</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="导出表格"><a href="#导出表格" class="headerlink" title="导出表格"></a>导出表格</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">window</span>.URL.createObjectURL(</span><br><span class="line">  <span class="keyword">new</span> Blob([res], &#123; <span class="attr">type</span>: <span class="string">"application/vnd.ms-excel"</span> &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> fileName = <span class="string">`操作日志<span class="subst">$&#123;dayjs().format(<span class="string">"YYYY-MM-DD"</span>)&#125;</span>.xls`</span>;</span><br><span class="line"><span class="keyword">let</span> link = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">link.style.display = <span class="string">"none"</span>;</span><br><span class="line">link.href = url;</span><br><span class="line">link.setAttribute(<span class="string">"download"</span>, fileName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(link);</span><br><span class="line">link.click();</span><br><span class="line"><span class="comment">//释放URL对象所占资源</span></span><br><span class="line"><span class="built_in">window</span>.URL.revokeObjectURL(url);</span><br><span class="line"><span class="comment">//用完即删</span></span><br><span class="line"><span class="built_in">document</span>.body.removeChild(link);</span><br></pre></td></tr></table></figure>

<h2 id="window-requestAnimationFrame-amp-window-requestIdleCallback"><a href="#window-requestAnimationFrame-amp-window-requestIdleCallback" class="headerlink" title="window.requestAnimationFrame &amp; window.requestIdleCallback"></a>window.requestAnimationFrame &amp; window.requestIdleCallback</h2><p><strong>软知识：</strong></p>
<ol>
<li><p><strong>屏幕刷新频率：</strong> 屏幕每秒出现图像的次数,普通笔记本为60Hz.</p>
</li>
<li><p><strong>动画原理：</strong> 计算机每16.7ms刷新一次（1000/60），由于人眼的视觉停留，所以看起来是流畅的移动。</p>
</li>
<li><p><strong>setTimeout：</strong> 通过设定<code>间隔时间</code>来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p>
<blockquote>
<p>1、settimeout任务被放入<code>异步队列</code>，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；<br/><br>2、settimeout的固定<code>时间间隔不一定与屏幕刷新时间相同</code>，会引起丢帧。</p>
</blockquote>
</li>
<li><p><strong>requestAnimationFrame：</strong> 优势：</p>
<blockquote>
<p>1.由<code>系统决定回调函数的执行时机</code>，60Hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿<br/><br>2.CPU节能：使用setTimeout实现的动画，<code>当页面被隐藏或最小化时</code>，<code>setTimeout 仍然在后台执行动画任务</code>，由于此时页面处于不可见或不可用状态，<br>刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，<br>因此跟着系统步伐走的<code>requestAnimationFrame也会停止渲染</code>，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。<br/><br>3.函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，<br>使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。</p>
</blockquote>
</li>
</ol>
<h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//回到顶部</span></span><br><span class="line"><span class="keyword">const</span> goTop=<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> product_content = <span class="built_in">document</span>.getElementById(<span class="string">'product_content'</span>);</span><br><span class="line"><span class="keyword">this</span>.progress = product_content.scrollTop;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.progress &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame(<span class="keyword">this</span>.step);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> step= <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> product_content = <span class="built_in">document</span>.getElementById(<span class="string">'product_content'</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.progress &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.progress -= <span class="number">250</span>;  <span class="comment">//这里可以根据高度成比例减少，不会突兀</span></span><br><span class="line">      product_content.scrollTop = <span class="keyword">this</span>.progress;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame(<span class="keyword">this</span>.step);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.cancelAnimationFrame(<span class="keyword">this</span>.step);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h3><p>浏览器每一帧都需要完成哪些工作？</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H2b91ea861e554256b0226556ca50ef791.jpg" alt=""></p>
<p>通过上图可看到，一帧内需要完成如下六个步骤的任务：</p>
<p>处理用户的交互<br/><br>JS 解析执行<br/><br>帧开始。窗口尺寸变更，页面滚去等的处理<br/><br>requestAnimationFrame(rAF)<br/><br>布局<br/><br>绘制<br/></p>
<p>上面六个步骤完成后没超过16.7ms,说明时间有富余，此时就会执行<code>requestIdleCallback里注册的任务</code>(requestIdleCallback的时长并不是16ms,他是一个肉眼觉察不到的时间),如果没rAF这样的循环处理，浏览器一直处于空闲状态的话，<code>deadline.timeRemaining</code>可以得到的最长时间</p>
<p>在<code>空闲时段</code>这种情况下，用户代理可能没有即将完成的任务，可以限制空闲周期的结束。为了避免在不可预测的任务（例如用户输入的处理）中引起用户可察觉的延迟，这些空闲周期的长度应限制为最大值50ms。</p>
<p>最大期限为50毫秒，是根据研究[ RESPONSETIME ] 得出的，该研究表明，对用户输入的100毫秒以内的响应通常被认为对人类是瞬时的。将闲置截止期限设置为50ms意味着即使在闲置任务开始后立即发生用户输入，用户代理仍然有剩余的50ms可以在其中响应用户输入而不会产生用户可察觉的滞后。</p>
<p><strong>API</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="built_in">window</span>.requestIdleCallback(callback[, options])</span><br></pre></td></tr></table></figure>

<ul>
<li>callback：回调，即空闲时需要执行的任务，该回调函数接收一个IdleDeadline对象作为入参。其中IdleDeadline对象包含：<ul>
<li><strong>didTimeout</strong>，布尔值，表示任务是否超时，结合 timeRemaining 使用。</li>
<li><strong>timeRemaining()</strong>，表示当前帧剩余的时间，也可理解为留给任务的时间还有多少。</li>
</ul>
</li>
<li>options：目前 options 只有一个参数<ul>
<li><strong>timeout</strong>。表示超过这个时间后，如果任务还没执行，则强制执行，不必等待空闲</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">requestIdleCallback(myNonEssentialWork, &#123; <span class="attr">timeout</span>: <span class="number">2000</span> &#125;);</span><br><span class="line"><span class="comment">// 任务队列</span></span><br><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line"> () =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"第一个任务"</span>);</span><br><span class="line"> &#125;,</span><br><span class="line"> () =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"第二个任务"</span>);</span><br><span class="line"> &#125;,</span><br><span class="line"> () =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"第三个任务"</span>);</span><br><span class="line"> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span> (<span class="params">deadline</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 如果帧内有富余的时间，或者超时</span></span><br><span class="line"> <span class="keyword">while</span> ((deadline.timeRemaining() &gt; <span class="number">0</span> || deadline.didTimeout) &amp;&amp; tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   work();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>)</span><br><span class="line">   requestIdleCallback(myNonEssentialWork);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">work</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> tasks.shift()();</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'执行任务'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超时的情况，其实就是浏览器很忙，没有空闲时间，此时会等待指定的 timeout 那么久再执行<br>，通过入参 dealine 拿到的 <code>didTmieout 会为 true，同时 timeRemaining () 返回的也是 0</code>。<br>超时的情况下如果选择继续执行的话，肯定会出现卡顿的，因为必然会将一帧的时间拉长</p>
<p><strong>cancelIdleCallback</strong></p>
<p>与 setTimeout 类似，返回一个唯一 id，可通过 cancelIdleCallback 来取消任务。</p>
<h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h2><p>MutationObserver 是一个可以监听DOM结构变化的接口。</p>
<p>异步的 （微任务）</p>
<ul>
<li>childList：如果突变目标的子代被观察，则设置为 true。</li>
<li>attributes：如果要观察目标属性的突变，则设置为 true。 如果指定了 attributeOldValue 和（或）attributeFilter，则可以省略。</li>
<li>characterData：如果要观察到目标数据的突变，则设置为 true。 如果指定了characterDataOldValue，则可以省略。</li>
<li>subtree：如果突变不仅仅是目标对象，而且包括目标的后代（descendants），则设置为 true。</li>
<li>attributeOldValue：如果前面的 attributes 属性设置为 true 或省略，并且目标的属性值在突变前要做记录，则设置为 true。</li>
<li>characterDataOldValue：如果前面的 characterData 属性设置为 true 或省略，并且目标的数据在突变前要做记录，则设置为 true。</li>
<li>attributeFilter：设置为属性本地名称列表（没有命名空间），如果不是所有属性突变都需要观察，属性为 true 或省略。例如：[‘class’,’src’]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> dom =   <span class="built_in">document</span>.body.getAttribute(<span class="string">'data-random'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(dom)  <span class="comment">// 如果用户修改body的属性，就会触发这个方法</span></span><br><span class="line">&#125;).observe(<span class="built_in">document</span>.body, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random())</span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random())</span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只会输出一次 ovserver</span></span><br></pre></td></tr></table></figure>

<h2 id="弱网检测"><a href="#弱网检测" class="headerlink" title="弱网检测"></a>弱网检测</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isSlowNetwork = navigator.connection</span><br><span class="line">  ? navigator.connection.saveData ||</span><br><span class="line">    (navigator.connection.type !== <span class="string">'wifi'</span> &amp;&amp;</span><br><span class="line">      navigator.connection.type !== <span class="string">'ethernet'</span> &amp;&amp;</span><br><span class="line">      /(<span class="number">2</span>|<span class="number">3</span>)g/.test(navigator.connection.effectiveType))</span><br><span class="line">  : <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!navigator.onLine || isSlowNetwork) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="userAgent"><a href="#userAgent" class="headerlink" title="userAgent"></a>userAgent</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断浏览器内核、手机系统等，使用 browser.userAgent.mobile</span></span><br><span class="line"><span class="keyword">var</span> browser = &#123;</span><br><span class="line">    userAgent: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ua = navigator.userAgent;</span><br><span class="line">        <span class="keyword">var</span> ualower = navigator.userAgent.toLocaleLowerCase();</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            trident: ua.indexOf(<span class="string">'Trident'</span>) &gt; <span class="number">-1</span>, <span class="comment">// IE内核</span></span><br><span class="line">            presto: ua.indexOf(<span class="string">'Presto'</span>) &gt; <span class="number">-1</span>, <span class="comment">// opera内核</span></span><br><span class="line">            webKit: ua.indexOf(<span class="string">'AppleWebKit'</span>) &gt; <span class="number">-1</span>, <span class="comment">//苹果、谷歌内核</span></span><br><span class="line">            gecko: ua.indexOf(<span class="string">'Gecko'</span>) &gt; <span class="number">-1</span> &amp;&amp; ua.indexOf(<span class="string">'KHTML'</span>) == <span class="number">-1</span>, <span class="comment">// 火狐内核</span></span><br><span class="line">            mobile: !!ua.match(<span class="regexp">/AppleWebKit.*Mobile.*/</span>) || !!ua.match(<span class="regexp">/AppleWebKit/</span>), <span class="comment">// 是否为移动终端</span></span><br><span class="line">            ios: !!ua.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">// IOS终端</span></span><br><span class="line">            android: ua.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span>, <span class="comment">// 安卓终端</span></span><br><span class="line">            iPhone: ua.indexOf(<span class="string">'iPhone'</span>) &gt; <span class="number">-1</span>, <span class="comment">// 是否为iphone或QQHD浏览器</span></span><br><span class="line">            iPad: ua.indexOf(<span class="string">'iPad'</span>) &gt; <span class="number">-1</span>, <span class="comment">// 是否为iPad</span></span><br><span class="line">            webApp: ua.indexOf(<span class="string">'Safari'</span>) == <span class="number">-1</span>, <span class="comment">// 是否web应用程序，没有头部与底部</span></span><br><span class="line">            QQbrw: ua.indexOf(<span class="string">'MQQBrowser'</span>) &gt; <span class="number">-1</span>, <span class="comment">// QQ浏览器(手机上的)</span></span><br><span class="line">            weiXin: ua.indexOf(<span class="string">'MicroMessenger'</span>) &gt; <span class="number">-1</span>, <span class="comment">// 微信</span></span><br><span class="line">            QQ: ualower.match(<span class="regexp">/\sQQ/i</span>) == <span class="string">" qq"</span>, <span class="comment">// QQ App内置浏览器（需要配合使用）</span></span><br><span class="line">            weiBo: ualower.match(<span class="regexp">/WeiBo/i</span>) == <span class="string">"weibo"</span>, <span class="comment">// 微博</span></span><br><span class="line">            ucLowEnd: ua.indexOf(<span class="string">'UCWEB7.'</span>) &gt; <span class="number">-1</span>, <span class="comment">//</span></span><br><span class="line">            ucSpecial: ua.indexOf(<span class="string">'rv:1.2.3.4'</span>) &gt; <span class="number">-1</span>,</span><br><span class="line">            webview: !(ua.match(<span class="regexp">/Chrome\/([\d.]+)/</span>) || ua.match(<span class="regexp">/CriOS\/([\d.]+)/</span>)) &amp;&amp; ua.match(<span class="regexp">/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/</span>),</span><br><span class="line">            ucweb: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">parseFloat</span>(ua.match(<span class="regexp">/ucweb\d+\.\d+/gi</span>).toString().match(<span class="regexp">/\d+\.\d+/</span>).toString()) &gt;= <span class="number">8.2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ua.indexOf(<span class="string">'UC'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;(),</span><br><span class="line">            Symbian: ua.indexOf(<span class="string">'Symbian'</span>) &gt; <span class="number">-1</span>,</span><br><span class="line">            ucSB: ua.indexOf(<span class="string">'Firofox/1.'</span>) &gt; <span class="number">-1</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="import和require区别"><a href="#import和require区别" class="headerlink" title="import和require区别"></a>import和require区别</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.tsx</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">"./sum"</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//sum.tsx</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum=<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//result: 2,1,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//import命令是编译阶段执行的，在代码运行之前。因此这意味着被导入的模块会先运行，而导入模块的文件会后执行</span></span><br><span class="line"><span class="comment">//如果是require()结果会依次打印出来，1，2，3</span></span><br></pre></td></tr></table></figure>

<h2 id="检测数据类型"><a href="#检测数据类型" class="headerlink" title="检测数据类型"></a>检测数据类型</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typeof用以获取一个变量或者表达式的类型，typeof一般只能返回如下几个结果：</span></span><br><span class="line">number,boolean,string,<span class="function"><span class="keyword">function</span>（函数）,<span class="title">symbol</span>,<span class="title">object</span>（<span class="title">NULL</span>,数组，对象）,<span class="title">undefined</span>。</span></span><br></pre></td></tr></table></figure>


<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line"><span class="comment">//可以看到[1, 2, 3]是类型Array的实例</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">val, type</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> rightProto = type.prototype; <span class="comment">// 取右边 prototype的值</span></span><br><span class="line">    <span class="keyword">let</span> leftPrevProto = val.__proto__; <span class="comment">// 取左边__proto__值</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftPrevProto === <span class="literal">null</span>) &#123; <span class="comment">//如果左边的__proto__值为null，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftPrevProto === rightProto) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">        &#125; </span><br><span class="line">        leftPrevProto = leftPrevProto.__proto__ ; <span class="comment">//以上都不满足，取上一层原型继续循环，直到没取到为null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>1：null 和 undefined 无constructor，这种方法判断不了。</p>
<p>2：还有，如果自定义对象，开发者重写prototype之后，原有的constructor会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">''</span>.constructor===<span class="built_in">String</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">111</span>).constructor===<span class="built_in">Number</span></span><br><span class="line">(<span class="number">11</span>).constructor===<span class="built_in">Number</span></span><br><span class="line"><span class="literal">false</span>.constructor===<span class="built_in">Boolean</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().constructor===<span class="built_in">Date</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>().constructor===<span class="built_in">Function</span></span><br><span class="line">[].constructor===<span class="built_in">Array</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chameleon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123; newColor = <span class="string">"green"</span> &#125; = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newColor = newColor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Chameleon.constructor===<span class="built_in">Function</span></span><br><span class="line"><span class="keyword">new</span> Chameleon().constructor.constructor===<span class="built_in">Function</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> Chameleon().constructor) <span class="comment">//"[object Function]"</span></span><br><span class="line"><span class="keyword">new</span> ew Chameleon().constructor===<span class="built_in">Function</span>  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>


<h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">type, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clas = <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Object</span>(obj)).slice(<span class="number">8</span>, <span class="number">-1</span>);   <span class="comment">//Object(null)</span></span><br><span class="line">    <span class="keyword">return</span> obj !== <span class="literal">undefined</span> &amp;&amp; obj !== <span class="literal">null</span> &amp;&amp; clas === type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is(<span class="string">'String'</span>, <span class="string">'test'</span>); <span class="comment">// true</span></span><br><span class="line">is(<span class="string">'String'</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="HTML页面加载完毕后运行JS"><a href="#HTML页面加载完毕后运行JS" class="headerlink" title="HTML页面加载完毕后运行JS"></a>HTML页面加载完毕后运行JS</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">//可以判断js时候加载完毕</span></span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;); </span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//当dom加载完就可以执行（比window.onload更早）</span></span><br></pre></td></tr></table></figure>
<p><strong>两者的主要区别</strong></p>
<p>当一个文档完全下载到浏览器中时，才会触发<code>window.onload</code>事件</p>
<p>$(document).ready{ }是在DOM完全就绪并可以使用时调用，此时可能图片等还可能没有下载完成</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Symbol 是基本数据类型  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Age=<span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Age === <span class="string">'symbol'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性名 为不可枚举属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">   [<span class="built_in">Symbol</span>(<span class="string">'name'</span>)]: <span class="string">'一斤代码'</span>,</span><br><span class="line">   age: <span class="number">18</span>,</span><br><span class="line">   title: <span class="string">'Engineer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj)   <span class="comment">// ['age', 'title']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(p)   <span class="comment">// 分别会输出：'age' 和 'title'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)   <span class="comment">// ['age', 'title']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj)  <span class="comment">// &#123;"age":18,"title":"Engineer"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一些专门针对Symbol的API</span></span><br><span class="line"><span class="comment">// 使用Object的API</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [Symbol(name)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新增的反射API</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj) <span class="comment">// [Symbol(name), 'age', 'title']</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Symbol代替REDUX的常量</span></span><br><span class="line"><span class="comment">// const TYPE_AUDIO = 'AUDIO'</span></span><br><span class="line"><span class="comment">// const TYPE_VIDEO = 'VIDEO'</span></span><br><span class="line"><span class="comment">// const TYPE_IMAGE = 'IMAGE'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure>

<h2 id="IntersectionObserver-是否可见"><a href="#IntersectionObserver-是否可见" class="headerlink" title="IntersectionObserver 是否可见"></a>IntersectionObserver 是否可见</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="keyword">function</span>(<span class="params">changes</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(changes);</span><br><span class="line">  changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element, index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// statements</span></span><br><span class="line">    <span class="keyword">if</span> (element.intersectionRatio &gt; <span class="number">0</span> &amp;&amp; element.intersectionRatio &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      element.target.src = element.target.dataset.src;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addObserver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> listItems = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.list-item-img'</span>);</span><br><span class="line">listItems.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  observer.observe(item);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addObserver();</span><br></pre></td></tr></table></figure>

<h2 id="小东西"><a href="#小东西" class="headerlink" title="小东西"></a>小东西</h2><ul>
<li><p>显示版本号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">'../package.json'</span>);</span><br><span class="line"><span class="built_in">window</span>.mmPlayer = <span class="built_in">window</span>.mmplayer = <span class="string">`欢迎使用 </span></span><br><span class="line"><span class="string">当前版本为：V<span class="subst">$&#123;pkg.version&#125;</span></span></span><br><span class="line"><span class="string">作者：<span class="subst">$&#123;pkg.auter&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">`%c<span class="subst">$&#123;<span class="built_in">window</span>.mmPlayer&#125;</span>`</span>, <span class="string">`color:blue`</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>耗时监控</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">1000000</span>).keys()</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="number">111</span>)  <span class="comment">//111: 8.5390625ms</span></span><br></pre></td></tr></table></figure></li>
<li><p>table</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.table()</span><br></pre></td></tr></table></figure></li>
<li><p>清空控制台历史记录</p>
<ul>
<li>在控制台<code>右键</code>，或者按下 <code>Ctrl 并单击鼠标</code>，选择 Clear Console。</li>
<li>在脚本窗口输入 <code>clear()</code>执行。</li>
<li>使用快捷键 <code>command + K</code></li>
</ul>
</li>
<li><p>切换主题</p>
</li>
</ul>
<p>Chrome 提供了 亮&amp;暗 两种主题,当你视觉疲劳的时候,可以 switch 哦, 快捷键 <code>command+shift+p</code> ,打开 Command Menu,输入 <code>theme</code> ,即可选择切换</p>
<h2 id="Think-循环"><a href="#Think-循环" class="headerlink" title="Think 循环"></a>Think 循环</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">if</span> condition=<span class="string">"$Think.get.edit == 1 OR $Think.get.judge == 1"</span>&gt;disabled&lt;/<span class="keyword">if</span>&gt; </span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">if</span>($_GET[<span class="string">'id'</span>] == $parter[<span class="string">'id'</span>])&#123; <span class="keyword">echo</span> <span class="string">"selected"</span>;&#125;<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> dump ($vo)<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;volist name=<span class="string">"areas"</span> id=<span class="string">"vo"</span>&gt;&lt;/volist&gt;</span><br></pre></td></tr></table></figure>

<h2 id="js文件压缩原因和压缩原理"><a href="#js文件压缩原因和压缩原理" class="headerlink" title="js文件压缩原因和压缩原理"></a>js文件压缩原因和压缩原理</h2><p><strong>压缩：</strong> 删除 Javascript 代码中所有注释、跳格符号、换行符号及无用的空格，从而压缩 JS 文件大小。<br/><br><strong>混淆：</strong> 经过编码将变量和函数原命名改为毫无意义的命名，以防止他人窥视和窃取 Javascript 源代码。</p>
<p><strong>javascript文件压缩的原理</strong></p>
<p>第一个当然就是去掉注释了。</p>
<p>另外就是跟CSS压缩相同的去掉换行符，空格什么的。</p>
<p>JAVASCRIPT中有几种变量形式，如变量，函数名，函数的参数等，通常我们在手写JS代码的时候，为了便于理解，我们都会给这些变量名以直观易懂的字符串，如：var title=”javascript”;这个习惯是值得推崇的。</p>
<p>但是，这些变量对于用户理解有帮助，对于计算机却没什么影响，如果我们把前面的句子变成：var a=”javascript”;对电脑来讲是一样的。</p>
<p>通常深度压缩JS都必须要做的一步就是尽量地缩短变量名，因为一份体积巨大的JS代码，其中的变量名会占去不少空间。</p>
<p>26个单字母，几乎就可以把一个函数中所有的参数都写完，所以我们经常在压缩版的JS代码中发现a,b,c,d之类的连续变量。</p>
<p>另外，Javascript有个特性就是不同作用域的变量名可以任意重复，所以此函数中有a,b,c,d，其他函数也可以有。这样短又大量重复的变量可以让人索云里雾里不知所云，也变相的起到了加密JS代码的作用.</p>
<p><strong>注意</strong></p>
<ol>
<li>压缩前的代码格式要标准。因为去掉换行与空格时，所有语句就变成一行了，如果你的代码有瑕疵（比如某行少了个分号），那就会导致整个文件报错。当然，现在有的压缩工具已经比较智能了。</li>
<li>备份原文件</li>
<li>压缩很可能不会一次成功，一般要多试，多改</li>
</ol>
<h2 id="window-performance-API"><a href="#window-performance-API" class="headerlink" title="window.performance API"></a>window.performance API</h2><p>允许网页访问某些函数来测量网页和Web应用程序的性能,包括 Navigation Timing API和高分辨率时间数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerformanceTiming</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> performance = <span class="built_in">window</span>.performance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!performance) &#123;</span><br><span class="line">    <span class="comment">// 当前浏览器不支持</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你的浏览器不支持 performance 接口'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> t = performance.timing;</span><br><span class="line">  <span class="keyword">var</span> times = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//【重要】页面加载完成的时间</span></span><br><span class="line">  <span class="comment">//【原因】这几乎代表了用户等待页面可用的时间</span></span><br><span class="line">  times.loadPage = t.loadEventEnd - t.navigationStart;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//【重要】解析 DOM 树结构的时间</span></span><br><span class="line">  <span class="comment">//【原因】反省下你的 DOM 树嵌套是不是太多了！</span></span><br><span class="line">  times.domReady = t.domComplete - t.responseEnd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//【重要】重定向的时间</span></span><br><span class="line">  <span class="comment">//【原因】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com</span></span><br><span class="line">  times.redirect = t.redirectEnd - t.redirectStart;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//【重要】DNS 查询时间</span></span><br><span class="line">  <span class="comment">//【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？</span></span><br><span class="line">  <span class="comment">// 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364)</span></span><br><span class="line">  times.lookupDomain = t.domainLookupEnd - t.domainLookupStart;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//【重要】读取页面第一个字节的时间</span></span><br><span class="line">  <span class="comment">//【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？</span></span><br><span class="line">  <span class="comment">// TTFB 即 Time To First Byte 的意思</span></span><br><span class="line">  <span class="comment">// 维基百科：https://en.wikipedia.org/wiki/Time_To_First_Byte</span></span><br><span class="line">  times.ttfb = t.responseStart - t.navigationStart;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//【重要】内容加载完成的时间</span></span><br><span class="line">  <span class="comment">//【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？</span></span><br><span class="line">  times.request = t.responseEnd - t.requestStart;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//【重要】执行 onload 回调函数的时间</span></span><br><span class="line">  <span class="comment">//【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？</span></span><br><span class="line">  times.loadEvent = t.loadEventEnd - t.loadEventStart;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DNS 缓存时间</span></span><br><span class="line">  times.appcache = t.domainLookupStart - t.fetchStart;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 卸载页面的时间</span></span><br><span class="line">  times.unloadEvent = t.unloadEventEnd - t.unloadEventStart;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TCP 建立连接完成握手的时间</span></span><br><span class="line">  times.connect = t.connectEnd - t.connectStart;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计算性能指标</strong></p>
<pre><code>可以使用Navigation.timing 统计到的时间数据来计算一些页面性能指标，比如DNS查询耗时、白屏时间、domready等等。如下：

DNS查询耗时 = domainLookupEnd - domainLookupStart
TCP链接耗时 = connectEnd - connectStart
request请求耗时 = responseEnd - responseStart
解析dom树耗时 = domComplete - domInteractive
白屏时间 = domloadng - fetchStart
domready时间 = domContentLoadedEventEnd - fetchStart
onload时间 = loadEventEnd - fetchStart</code></pre><h2 id="读取注释"><a href="#读取注释" class="headerlink" title="读取注释"></a>读取注释</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eachComment</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> child = ele.childNodes[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (child.nodeType === <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(child.nodeValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bodyElement = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"body"</span>)[<span class="number">0</span>];</span><br><span class="line">eachComment(bodyElement);</span><br></pre></td></tr></table></figure>

<h2 id="es5的几种继承方式"><a href="#es5的几种继承方式" class="headerlink" title="es5的几种继承方式"></a>es5的几种继承方式</h2><h3 id="对象冒充实现继承"><a href="#对象冒充实现继承" class="headerlink" title="对象冒充实现继承"></a>对象冒充实现继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">'张三'</span>;  <span class="comment">/*属性*/</span></span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">this</span>.run=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">/*实例方法*/</span></span><br><span class="line">        alert(<span class="keyword">this</span>.name+<span class="string">'在运动'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;      </span><br><span class="line">Person.prototype.sex=<span class="string">"男"</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     alert(<span class="keyword">this</span>.name+<span class="string">'在工作'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Web类 继承Person类   对象冒充的组合继承模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>);    <span class="comment">/*对象冒充实现继承*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> w=<span class="keyword">new</span> Web();</span><br><span class="line"><span class="comment">// w.run();  //**对象冒充可以继承构造函数里面的属性和方法**</span></span><br><span class="line"></span><br><span class="line">w.work();  <span class="comment">//对象冒充可以继承构造函数里面的属性和方法   但是没法继承原型链上面的属性和方法</span></span><br></pre></td></tr></table></figure>
<h3 id="原型链实现继承"><a href="#原型链实现继承" class="headerlink" title="原型链实现继承"></a>原型链实现继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">'张三'</span>;  <span class="comment">/*属性*/</span></span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">this</span>.run=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">/*实例方法*/</span></span><br><span class="line">        alert(<span class="keyword">this</span>.name+<span class="string">'在运动'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br><span class="line">Person.prototype.sex=<span class="string">"男"</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     alert(<span class="keyword">this</span>.name+<span class="string">'在工作'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Web类 继承Person类   原型链+对象冒充的组合继承模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params">name,age</span>)</span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Web.prototype=<span class="keyword">new</span> Person();   <span class="comment">//原型链实现继承</span></span><br><span class="line"><span class="keyword">var</span> w=<span class="keyword">new</span> Web();</span><br><span class="line"><span class="comment">//原型链实现继承:可以继承构造函数里面的属性和方法 也可以继承原型链上面的属性和方法</span></span><br><span class="line"><span class="comment">//w.run();</span></span><br><span class="line"></span><br><span class="line">w.work();</span><br><span class="line"> <span class="comment">//缺点是实例化子类的时候没法给父类传参</span></span><br></pre></td></tr></table></figure>

<h3 id="原型链-对象冒充的组合继承模式"><a href="#原型链-对象冒充的组合继承模式" class="headerlink" title="原型链+对象冒充的组合继承模式"></a>原型链+对象冒充的组合继承模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;  <span class="comment">/*属性*/</span></span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">        <span class="keyword">this</span>.run=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">/*实例方法*/</span></span><br><span class="line">            alert(<span class="keyword">this</span>.name+<span class="string">'在运动'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;      </span><br><span class="line">Person.prototype.sex=<span class="string">"男"</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name+<span class="string">'在工作'</span>);</span><br><span class="line"></span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>,name,age);   <span class="comment">//对象冒充继承   实例化子类可以给父类传参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Web.prototype=<span class="keyword">new</span> Person();<span class="comment">//上面已经继承了构函数的方法 ， 这里new 一个会重新继承狗杂函数的方法 ，所以这里可以直接 -&gt; Web.prototype=Person.prototype;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w=<span class="keyword">new</span> Web(<span class="string">'赵四'</span>,<span class="number">20</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// w.run();</span></span><br><span class="line">w.work();</span><br><span class="line"></span><br><span class="line"><span class="comment">// var w1=new Web('王五',22);</span></span><br></pre></td></tr></table></figure>

<h3 id="class实现继承源码"><a href="#class实现继承源码" class="headerlink" title="class实现继承源码"></a>class实现继承源码</h3><p><code>ES6</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = props.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 向父类传参</span></span><br><span class="line">    <span class="keyword">super</span>(&#123; <span class="attr">name</span>: <span class="string">'B'</span> &#125;);</span><br><span class="line">    <span class="comment">// this 必须在 super() 下面使用</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ES5</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__extends</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 修改对象原型</span></span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(child, parent);</span><br><span class="line">  <span class="comment">// 寄生继承，创建一个干净的构造函数，用于继承父类的 prototype</span></span><br><span class="line">  <span class="comment">// 这样做的好处是，修改子类的 prototype 不会影响父类的 prototype</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 修正 constructor 指向子类</span></span><br><span class="line">    <span class="keyword">this</span>.constructor = child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原型继承，继承父类原型属性，但是无法向父类构造函数传参</span></span><br><span class="line">  child.prototype =</span><br><span class="line">    parent === <span class="literal">null</span></span><br><span class="line">      ? <span class="built_in">Object</span>.create(parent)</span><br><span class="line">      : ((__.prototype = parent.prototype), <span class="keyword">new</span> __());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> B = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = props.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> A = (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</span><br><span class="line">    __extends(A, _super);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = _super.call(<span class="keyword">this</span>, &#123; <span class="attr">name</span>: <span class="string">'B'</span> &#125;) || <span class="keyword">this</span>; <span class="comment">// // 向父类传参</span></span><br><span class="line">        <span class="comment">// this 必须在 super() 下面使用</span></span><br><span class="line">        <span class="built_in">console</span>.log(_this);</span><br><span class="line">        <span class="keyword">return</span> _this;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;(B));</span><br></pre></td></tr></table></figure>


<h2 id="参看文档"><a href="#参看文档" class="headerlink" title="参看文档"></a>参看文档</h2><p><a href="https://sourcegraph.com/github.com/alienzhou/frontend-tech-list@master/-/blob/README.md?utm_source=share" target="_blank" rel="noopener">github</a><br><a href="https://panjiachen.github.io/awesome-bookmarks/repository/" target="_blank" rel="noopener">博客1</a><br><a href="https://lq782655835.github.io/blogs//" target="_blank" rel="noopener">博客2</a><br><a href="https://www.muyiy.cn/" target="_blank" rel="noopener">博客3</a></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>技术清单</category>
      </categories>
  </entry>
  <entry>
    <title>Object的方法简单整理</title>
    <url>/2018/01/16/workspace/Js/object/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Object的方法简单整理</strong></p>
<p>[[toc]]</p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>描述：该方法创建一个新对象，将对象继承到<strong>proto</strong>属性上<br/><br>格式：Object.create(proto[, propertiesObject])<br/><br>用法：如果用传统的方法要给一个对象的原型上添加属性和方法，是通过 <strong>propt</strong> 实现的<br/></p>
<p>通过构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个构造函数或者类</span></span><br><span class="line"><span class="keyword">var</span> People = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">People.prototype.y = <span class="number">20</span></span><br><span class="line">People.prototype.z = <span class="number">40</span></span><br><span class="line">People.prototype.showNum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//通过构造函数创建实例</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> People();</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === People.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>使用<code>Object.create()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = &#123;</span><br><span class="line">    y: <span class="number">20</span>,</span><br><span class="line">    z: <span class="number">40</span>,</span><br><span class="line">    showNum()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(proto);</span><br></pre></td></tr></table></figure>


<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>Object.defineProperty(obj, prop, descriptor)</p>
<p>obj: 需要被操作的目标对象<br/><br>prop: 目标对象需要定义或修改的属性的名称<br/><br>descriptor: 将被定义或修改的属性的描述符<br/></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">'张三'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name)  <span class="comment">//张三</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的数据属性"><a href="#对象的数据属性" class="headerlink" title="对象的数据属性"></a>对象的数据属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">'name'</span>,&#123;</span><br><span class="line">    configurable:<span class="literal">false</span>,<span class="comment">// 能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true</span></span><br><span class="line">    enumerable:<span class="literal">false</span>,<span class="comment">// 不可枚举 对象属性是否可通过for-in循环，flase为不可循环，默认值为true</span></span><br><span class="line">    writable:<span class="literal">false</span>,<span class="comment">// 对象属性是否可修改,flase为不可修改，默认值为true</span></span><br><span class="line">    value:<span class="string">'xiaoming'</span> <span class="comment">// 对象属性的默认值，默认值为undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// value</span></span><br><span class="line"><span class="built_in">console</span>.log(person);<span class="comment">// xiaoming，默认value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// writable</span></span><br><span class="line">person.name=<span class="string">"666"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person);<span class="comment">// xiaoming，不可修改value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// enumerable</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> person)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(person[i]) <span class="comment">// 无结果，不可循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(person) <span class="comment">// []  与for in区别在于不能遍历出原型链上的属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(person) <span class="comment">// ['name']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// configurable</span></span><br><span class="line"><span class="keyword">delete</span> person.name</span><br><span class="line"><span class="built_in">console</span>.log(person.name)<span class="comment">// xiaoming，不可删除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">'name'</span>,&#123;</span><br><span class="line">    configurable:<span class="literal">true</span> <span class="comment">// 不可修改，将抛出错误</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.getOwnPropertyDescriptors(person) // 返回自身所有的属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">'name'</span>) <span class="comment">// 返回自身属性</span></span><br><span class="line">&#123;</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">  value: <span class="string">"xiaoming"</span></span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h3><p>Object.defineProperties(obj, props)</p>
<p>obj: 将要被添加属性或修改属性的对象<br/><br>props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">'张三'</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        value: <span class="number">18</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// 张三, 18</span></span><br></pre></td></tr></table></figure>


<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>描述：用于读取一个对象的原型对象；</p>
<p>格式：Object.getPrototypeOf(obj);</p>
<p>用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="string">'foo'</span>) === <span class="built_in">String</span>.prototype === <span class="string">'foo'</span>.__proto__ <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">true</span>) === <span class="built_in">Boolean</span>.prototype === <span class="literal">true</span>.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf("></a>Object.setPrototypeOf(</h3><p>描述: Object.setPrototypeOf方法的作用与_proto_相同，用来设置一个对象的prototype对象，返回参数对象本身</p>
<p>格式：Object.setPrototypeOf(object, prototype)</p>
<p>该方法等同于下面的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">obj, proto</span>) </span>&#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"> </span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"> </span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<h3 id="keys-amp-values-amp-entries"><a href="#keys-amp-values-amp-entries" class="headerlink" title="keys &amp; values &amp; entries"></a>keys &amp; values &amp; entries</h3><ul>
<li>Object.keys   键</li>
<li>Object.values  值 </li>
<li>Object.entries  组件二级数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj =  &#123;</span><br><span class="line">    address: <span class="string">"434343422"</span>,</span><br><span class="line">    admin: <span class="string">"3434"</span>,</span><br><span class="line">    adminCharater: <span class="string">'4444'</span>,</span><br><span class="line">    adminRecord: <span class="string">'33'</span>,</span><br><span class="line">    article: <span class="string">'22'</span>,</span><br><span class="line">    artist: <span class="string">'11'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.entries(obj)<span class="comment">// [["address", "434343422"]...]</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(obj) <span class="comment">//["address", "admin", "adminCharater", "adminRecord", "article", "artist"]</span></span><br><span class="line">  <span class="built_in">Object</span>.values(obj) <span class="comment">//["434343422", "3434", "4444", "33", "22", "11"]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历数组，字符串等...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="built_in">Object</span>.values(obj)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">in</span> obj) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object-keys、Object-getOwnPropertyNames区别"><a href="#Object-keys、Object-getOwnPropertyNames区别" class="headerlink" title="Object.keys、Object.getOwnPropertyNames区别"></a>Object.keys、Object.getOwnPropertyNames区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">"prop1"</span>: <span class="string">"v1"</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"prop2"</span>, &#123; <span class="attr">value</span>: <span class="string">"v2"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj).length);           <span class="comment">//output：1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).length);    <span class="comment">//output：2</span></span><br></pre></td></tr></table></figure>

<p><strong>内置的判断，访问和迭代方法</strong></p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">可枚举(writable:true)</th>
<th align="left">可枚举、不可枚举</th>
</tr>
</thead>
<tbody><tr>
<td align="left">判断</td>
<td align="left">propertyIsEnumerable</td>
<td align="left">in/hasOwnProperty</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">Object.keys</td>
<td align="left">Object.getOwnPropertyNames</td>
</tr>
<tr>
<td align="left">迭代</td>
<td align="left">for..in..</td>
<td align="left">Object.getOwnPropertyNames</td>
</tr>
</tbody></table>
<h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p>ES10新增</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">  [<span class="string">'baz'</span>, <span class="number">42</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(entries);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// expected output: Object &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="lodash-pick"><a href="#lodash-pick" class="headerlink" title="lodash/pick"></a>lodash/pick</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> <span class="variable">obj</span></span> - 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> <span class="variable">props</span></span> - 要取那些属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">predicate</span></span> - 回调</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;object&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basePickBy</span>(<span class="params">obj, props, predicate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> props.reduce(<span class="function">(<span class="params">acc, key</span>) =&gt;</span> &#123;</span><br><span class="line">      predicate(obj[key], key) &amp;&amp; (acc[key] = obj[key]);</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pick</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">obj</span></span> - 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">props</span></span> - 要取那些属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">obj, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> basePickBy(obj, props, (value, key) =&gt; key <span class="keyword">in</span> obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">message</span>: <span class="string">"Foo"</span>, <span class="attr">a</span>: <span class="number">11</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line">pick(data,[<span class="string">'a'</span>,<span class="string">'b'</span>])  <span class="comment">// &#123;a: 11, b: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="浅拷贝-深拷贝"><a href="#浅拷贝-深拷贝" class="headerlink" title="浅拷贝/深拷贝"></a>浅拷贝/深拷贝</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//浅克隆 [层级嵌套不能超过2级,包括2级]</span></span><br><span class="line"><span class="keyword">const</span> clone = <span class="function"><span class="params">source</span> =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, source)</span><br><span class="line"><span class="keyword">const</span> clone = <span class="function"><span class="params">source</span> =&gt;</span> &#123; ...source &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深克隆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepclone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; obj !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> o = obj.push?[]:&#123;&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.push);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> attr <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(attr))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[attr] === <span class="string">'object'</span>)&#123;</span><br><span class="line">                o[attr] = deepclone(obj[attr]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                o[attr] = obj[attr];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or 取巧方法 JSON.parse(JSON.stringify());</span></span><br><span class="line"><span class="comment">// 注意这种取巧方法是有限制的</span></span><br><span class="line"><span class="comment">// 1. 只能解析Number、String、Array等能够被json表示的数据结构（无法拷贝一写特殊的对象，诸如 RegExp, Date, Set, Map，函数 等。）</span></span><br><span class="line"><span class="comment">// 2. 不能处理循环引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">val</span>:<span class="number">2</span>&#125;;</span><br><span class="line">obj.target = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝obj会出现系统栈溢出，因为出现了无限递归的情况。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">//VM913:1 Uncaught TypeError: Converting circular structure to JSON</span></span><br><span class="line"><span class="comment">//--&gt; starting at object with constructor 'Object'</span></span><br><span class="line"><span class="comment">//--- property 'target' closes the circle</span></span><br><span class="line"><span class="comment">//at JSON.stringify (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">//at &lt;anonymous&gt;:1:17</span></span><br><span class="line"><span class="comment">//(anonymous) @ VM913:1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//解决死循环的问题</span></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">target</span>) =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> || <span class="keyword">typeof</span> target === <span class="string">'function'</span>) &amp;&amp; target !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">Map</span>(</span>)) =&gt;</span> &#123; </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//如果有的话直接跳过</span></span><br><span class="line">  <span class="keyword">if</span>(map.get(target))  <span class="keyword">return</span> target; </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (isObject(target)) &#123; </span><br><span class="line">    map.set(target, <span class="literal">true</span>); </span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123; </span><br><span class="line">      <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123; </span><br><span class="line">          cloneTarget[prop] = deepClone(target[prop],map); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> cloneTarget; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> target; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map 和 a一直是强引用的关系， 在程序结束之前，a 所占的内存空间一直不会被释放。</span></span><br><span class="line"><span class="comment">//弱引用的对象可以在任何时候被回收，而对于强引用来说，只要这个强引用还在，那么对象无法被回收。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6给我们提供了这样的数据结构，它的名字叫WeakMap,它是一种特殊的Map, 其中的键是弱引用的。`其键必须是对象`，而值可以是任意的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//稍微改造一下即可:</span></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(</span>)) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象转原始类型是根据什么流程运行的？"><a href="#对象转原始类型是根据什么流程运行的？" class="headerlink" title="对象转原始类型是根据什么流程运行的？"></a>对象转原始类型是根据什么流程运行的？</h3><p>对象转原始类型，会优先调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</p>
<p>如果Symbol.toPrimitive()方法，优先调用再返回<br/><br>调用valueOf()，如果转换为原始类型，则返回<br/><br>调用toString()，如果转换为原始类型，则返回<br/><br>如果都没有返回原始类型，会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">3</span>,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'5'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="number">1</span>); <span class="comment">// 输出7</span></span><br></pre></td></tr></table></figure>

<h3 id="如何让if-a-1-amp-amp-a-2-条件成立？"><a href="#如何让if-a-1-amp-amp-a-2-条件成立？" class="headerlink" title="如何让if(a == 1 &amp;&amp; a == 2)条件成立？"></a>如何让if(a == 1 &amp;&amp; a == 2)条件成立？</h3><p>就是上面例子的应用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  value: <span class="number">0</span>,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">this</span>.value++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span>,a);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>


<h3 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h3><h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h4><p>javascript 对象的比较是比较坑爹的一件事，因为javascript对象比较的是引用地址，当两个引用地址相同的对象总是相等的,或者两个完全一样的对象也是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> object1=&#123;</span><br><span class="line">    name:<span class="string">"1234 "</span>,</span><br><span class="line">    code:<span class="number">123</span>,</span><br><span class="line">    test:<span class="string">"321"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> object2=&#123;</span><br><span class="line">    name:<span class="string">"1234 "</span>,</span><br><span class="line">    code:<span class="number">123</span>,</span><br><span class="line">    test:<span class="string">"321"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object1===object2)   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>解决方法使用hashcode</p>
<p>这里只是简单的走个流程，详细的请查看<code>js-hash-code</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashCode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hash = <span class="number">0</span>, i, chr, len;</span><br><span class="line">  <span class="keyword">if</span> (str.length === <span class="number">0</span>) <span class="keyword">return</span> hash;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, len = str.length; i &lt; len; i++) &#123;</span><br><span class="line">    chr   = str.charCodeAt(i);</span><br><span class="line">    hash  = ((hash &lt;&lt; <span class="number">5</span>) - hash) + chr;</span><br><span class="line">    hash |= <span class="number">0</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&lt;是移位符 </span><br><span class="line"></span><br><span class="line">移位运算就是对二进制进行有规律低移位。移位运算可以设计很多奇妙的效果，在图形图像编程中应用广泛。</span><br><span class="line"></span><br><span class="line">|&#x3D; 按位或．然后赋值．</span><br><span class="line"></span><br><span class="line">i&#x3D;1;&#x2F;&#x2F;二进制为0001</span><br><span class="line">i|2;&#x2F;&#x2F;2的二进制为0010 两个按位或为0011也就是3</span><br><span class="line">i|&#x3D;2等价于i&#x3D;i|2;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(object1===object2);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test1=hashCode(<span class="built_in">JSON</span>.stringify(object1));</span><br><span class="line"><span class="keyword">var</span> test2=hashCode(<span class="built_in">JSON</span>.stringify(object2));</span><br><span class="line"><span class="built_in">console</span>.log(test1,test2,test1===test2);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 判断对象相等的步骤：</span></span><br><span class="line"><span class="comment">1.先判断两者是不是对象</span></span><br><span class="line"><span class="comment">2.对象的键值对数量是否相等</span></span><br><span class="line"><span class="comment">3.判断两个对象的所有key值是否相等相同</span></span><br><span class="line"><span class="comment">4.判断两个对象的相应的key对应的值是否相同</span></span><br><span class="line"><span class="comment">来一个递归判断里面的对象循环1-4步骤代码如下</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isEqual = <span class="function">(<span class="params">obj1, obj2</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> isObj1 = obj1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>;</span><br><span class="line">   <span class="keyword">let</span> isObj2 = obj2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>;</span><br><span class="line">   <span class="keyword">if</span> (!isObj1 || !isObj2) <span class="keyword">return</span> <span class="built_in">Object</span>.is(obj1, obj2);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> kyes1 = <span class="built_in">Object</span>.keys(obj1);</span><br><span class="line">   <span class="keyword">let</span> kyes2 = <span class="built_in">Object</span>.keys(obj2);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (kyes1.length !== kyes2.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> kyes1) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!kyes2.includes(kyes1[item])) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">       <span class="keyword">let</span> t1 = obj1[attr] <span class="keyword">instanceof</span> <span class="built_in">Object</span>;</span><br><span class="line">       <span class="keyword">let</span> t2 = obj2[attr] <span class="keyword">instanceof</span> <span class="built_in">Object</span>;</span><br><span class="line">       <span class="keyword">if</span> (t1 &amp;&amp; t2) &#123;</span><br><span class="line">           <span class="keyword">return</span> isEqual(obj1[attr], obj2[attr]);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj1[attr] !== obj2[attr]) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">MDN OBJECT</a></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>Object的方法简单整理</category>
      </categories>
  </entry>
  <entry>
    <title>String的方法简单整理</title>
    <url>/2018/01/17/workspace/Js/string/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>String的方法简单整理</strong></p>
<p>[[toc]]</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a><code>indexOf()</code></h4><ul>
<li>str.indexOf(searchValue, fromIndex?)<ul>
<li>方法返回调用它的 String 对象中第一次出现的指定值的索引，从 fromIndex 处进行搜索。如果未找到该值，则返回 -1。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;Blue&quot;);     &#x2F;&#x2F; 返回  0</span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;Blute&quot;);    &#x2F;&#x2F; 返回 -1</span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;Whale&quot;, 0); &#x2F;&#x2F; 返回  5</span><br><span class="line"></span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;Whale&quot;, 5); &#x2F;&#x2F; 返回  5</span><br><span class="line"></span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;&quot;, -1);     &#x2F;&#x2F; 返回 0</span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;&quot;, 9);      &#x2F;&#x2F; 返回  9</span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;&quot;, 10);     &#x2F;&#x2F; 返回 10</span><br><span class="line"></span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;&quot;, 11);     &#x2F;&#x2F; 返回 10  </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;检测字符串是否存在</span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;Blue&quot;) !&#x3D;&#x3D; -1; &#x2F;&#x2F; true</span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;Bloe&quot;) !&#x3D;&#x3D; -1; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h4 id="substring"><a href="#substring" class="headerlink" title="substring()"></a><code>substring()</code></h4><ul>
<li>返回被截取的字符串，不改变原来的，传入参数是<strong>起始位置和结束位置</strong>。(不包含结束位置)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">'hzf'</span>;</span><br><span class="line">str.substring(<span class="number">1</span>)<span class="comment">//zf</span></span><br></pre></td></tr></table></figure>

<h4 id="substr"><a href="#substr" class="headerlink" title="substr()"></a><code>substr()</code></h4><ul>
<li>返回被截取的字符串，不改变原来的，，传入参数是<strong>起始位置和要截取的长度</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">'hzf'</span>;</span><br><span class="line">str.substring(<span class="number">1</span>,<span class="number">1</span>)<span class="comment">//z</span></span><br></pre></td></tr></table></figure>


<h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a><code>slice()</code></h4><ul>
<li>跟 <code>substring()</code>用户相同</li>
<li>当为负值的时候不同，还是看例子吧</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =  <span class="string">'abcdefg'</span> </span><br><span class="line"></span><br><span class="line">a.slice(<span class="number">1</span>,<span class="number">-1</span>) <span class="comment">//"bcdef"  相当于 a.slice(1, a.length-1 )   有负值统一用length减去当前的负值来截取</span></span><br><span class="line">a.substring(<span class="number">1</span>,<span class="number">-1</span>) <span class="comment">//a    相当于 a.substring(0,1) 参数最小为0，小于0自动默认为0，参数小的为第一个参数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>toLowerCase()</code> 将整个字符串转成小写字母。</li>
<li><code>toUpperCase()</code> 将整个字符串转成大写字母。</li>
</ul>
<h3 id="Es6新方法"><a href="#Es6新方法" class="headerlink" title="Es6新方法"></a>Es6新方法</h3><h4 id="padStart"><a href="#padStart" class="headerlink" title="padStart()"></a>padStart()</h4><ul>
<li>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<ul>
<li><code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。padStart()和padStart()一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//必须是字符串</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)  <span class="comment">//"0123456abc"</span></span><br></pre></td></tr></table></figure>

<h4 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h4><ul>
<li><code>trim()</code>是两边的空格 <code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">'  abc  '</span>;</span><br><span class="line"></span><br><span class="line">s.trim() <span class="comment">// "abc"</span></span><br><span class="line">s.trimStart() <span class="comment">// "abc  "</span></span><br><span class="line">s.trimEnd() <span class="comment">// "  abc"</span></span><br></pre></td></tr></table></figure>

<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><ul>
<li><code>repeat(n)</code>方法返回一个新字符串，表示将原字符串重复n次。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>) <span class="comment">// "nana"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="literal">Infinity</span>)<span class="comment">// RangeError</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">-0.9</span>) <span class="comment">// ""</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="literal">NaN</span>) <span class="comment">// ""</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) <span class="comment">// "nanana"</span></span><br></pre></td></tr></table></figure>
<h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><ul>
<li><strong>includes(), startsWith(), endsWith()</strong><ul>
<li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li>
<li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'!'</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank" rel="noopener">MDN STRING</a></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>String的方法简单整理</category>
      </categories>
  </entry>
  <entry>
    <title>WebSocket &amp; socket.io</title>
    <url>/2018/01/16/workspace/Js/socket/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>WebSocket &amp; socket.io</strong></p>
<p>[[toc]]</p>
<p><strong>前言</strong></p>
<p>大家参与的项目里多少都会有web server与browser需要长连接互联的场景，<br>比如即时通讯、即时报价等，为了解决这个问题，便出现了 WebSocket 协议，实现了客户端和服务端双向通信的能力。<br>介绍 WebSocket 之前，还是让我们先了解下轮询实现推送的方式。</p>
<h3 id="短轮询（Polling）"><a href="#短轮询（Polling）" class="headerlink" title="短轮询（Polling）"></a>短轮询（Polling）</h3><p>短轮询的实现思路就是浏览器端每隔几秒钟向服务器端发送 HTTP 请求，服务端在收到请求后，<br>不论是否有数据更新，都直接进行响应。在服务端响应完成，就会关闭这个 TCP 连接，<br>代码实现也最简单，就是利用 XHR ， 通过 setInterval 定时向后端发送请求，以获取最新的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fetch(url).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// success code</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：实现简单。</li>
<li>缺点：会造成数据在一小段时间内不同步和大量无效的请求，安全性差、浪费资源。</li>
</ul>
<h3 id="长轮询（Long-Polling）"><a href="#长轮询（Long-Polling）" class="headerlink" title="长轮询（Long-Polling）"></a>长轮询（Long-Polling）</h3><p>当服务器收到客户端发来的请求后,服务器端不会直接进行响应，而是先将这个请求挂起，<br>然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。<br>客户端JavaScript响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fetch(url).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        queryData()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：比 Polling 做了优化，有较好的时效性。</li>
<li>缺点：保持连接挂起会消耗资源，服务器没有返回有效数据，程序超时。</li>
</ul>
<p>轮询与长轮询都是基于HTTP的，两者本身存在着缺陷:<code>轮询需要更快的处理速度；长轮询则更要求处理并发的能力</code>;<br>两者都是“被动型服务器”的体现:服务器不会主动推送信息，而是在客户端发送ajax请求后进行返回的响应。<br>而理想的模型是”在服务器端数据有了变化后，可以主动推送给客户端”,这种”主动型”服务器是解决这类问题的很好的方案。Web Sockets就是这样的方案。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket是Html5定义的一个新协议，与传统的http协议不同，该协议可以实现服务器与客户端之间全双工通信。简单来说，首先需要在客户端和服务器端建立起一个连接，这部分需要http。<br>连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。</p>
<p>当客户端要和服务端建立 WebSocket 连接时，在客户端和服务器的握手过程中，客户端首先会向服务端发送一个 HTTP 请求，<br>包含一个<strong>Upgrade 请求头</strong> 来告知服务端客户端想要建立一个 WebSocket 连接。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: ZUip34t+bCjhkvxxwhmdEOyx9hE=</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>

<p>WebSocket的优点是实现了双向通信，缺点是服务器端的逻辑非常复杂。现在针对不同的后台语言有不同的插件可以使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useEffect&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Index = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:9000'</span>);</span><br><span class="line">    <span class="comment">// 监听连接成功</span></span><br><span class="line">    ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'连接服务端WebSocket成功'</span>);</span><br><span class="line">        </span><br><span class="line">        ws.send(<span class="built_in">JSON</span>.stringify(msgData));	<span class="comment">// send 方法给服务端发送消息</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务端消息(接收消息)</span></span><br><span class="line">    ws.onmessage = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> message = <span class="built_in">JSON</span>.parse(msg.data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'收到的消息：'</span>, message)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接失败</span></span><br><span class="line">    ws.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'连接失败，正在重连...'</span>);</span><br><span class="line">        connectWebsocket();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接关闭</span></span><br><span class="line">    ws.onclose = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'连接关闭'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index;</span><br></pre></td></tr></table></figure>

<h4 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h4><p>在实际使用 WebSocket 中，长时间不通消息可能会出现一些连接不稳定的情况，这些未知情况导致的连接中断会影响客户端与服务端之前的通信，</p>
<p>为了防止这种的情况的出现，有一种心跳保活的方法：客户端就像心跳一样每隔固定的时间发送一次 ping ，<br>来告诉服务器，我还活着，而服务器也会返回 pong ，来告诉客户端，服务器还活着。ping/pong,<br>其实是一条与业务无关的假消息，也称为心跳包。</p>
<p>可以在连接成功之后，每隔一个固定时间发送心跳包，比如 60s:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ws.send(<span class="string">'这是一条心跳包消息'</span>);</span><br><span class="line">&#125;, <span class="number">60000</span>)</span><br></pre></td></tr></table></figure>


<img style="border: .3em solid #e0dfcc;border-radius: 1em;width：98%"  src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H2ca9851f8d104b37bfe96f78b39e34966.png">

<p>其中<code>绿色</code>箭头表示<code>发出</code>的消息，<code>红色</code>箭头表示<code>收到</code>的消息。</p>
<h3 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a>Socket.IO</h3><ul>
<li>可靠性，Socker.IO基于engine.io实现，先建立长轮询连接后再升级为基于websocket全双工的长连接</li>
<li>自动重连与断连检查</li>
<li>多路传输/多种数据格式传输（这个和websocket特性一样)</li>
<li>广播机制（这个用法在开发上还是很方便的，开发同学不需要做太多额外的工作，broadcast函数即可，不用像自己实现websocket服务端一样要做topic和连接管理及并发推送的处理）</li>
</ul>
<p>Socket.io允许你触发或响应自定义的事件，除了connect，message，disconnect这些事件的名字不能使用之外，你可以触发任何<code>自定义</code>的事件名称。</p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = &#123;</span><br><span class="line">    admin_id: adminid().id,</span><br><span class="line">    scenic_id: scenicid().id</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>.socket = io(scenicAnalysis, &#123;</span><br><span class="line">    transports: [<span class="string">'websocket'</span>, <span class="string">'xhr-polling'</span>, <span class="string">'jsonp-polling'</span>],</span><br><span class="line">    query</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">this</span>.socket.on(<span class="string">'connect'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = <span class="keyword">this</span>.socket;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'连接成功,'</span>, id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="消息收发"><a href="#消息收发" class="headerlink" title="消息收发"></a>消息收发</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"> <span class="keyword">this</span>.socket.emit(<span class="string">`一般是后端定义的字段`</span>, data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="keyword">this</span>.socket.on(<span class="string">`一般是后端定义的字段`</span>, (data) =&gt; &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//断开</span></span><br><span class="line"><span class="keyword">this</span>.socket.close();</span><br><span class="line"><span class="keyword">this</span>.socket=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测是否断开</span></span><br><span class="line"><span class="keyword">this</span>.socket.on(<span class="string">'disconnect'</span>, (msg: any) =&gt; <span class="built_in">console</span>.log(msg));</span><br><span class="line"><span class="comment">//失败捕获</span></span><br><span class="line"><span class="keyword">this</span>.socket.on(<span class="string">'error'</span>, (err: any) =&gt; <span class="built_in">console</span>.log(<span class="string">'error'</span>, <span class="keyword">new</span> <span class="built_in">Error</span>(err)))</span><br></pre></td></tr></table></figure>


<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>只从两个方面分析：</p>
<p><strong>易用性:</strong> Socket.IO的易用性更好，对于前端开发来说，没有太多心智负担，比如需要关心重连、push转polling等容错逻辑; 服务端上也没有太多的连接管理的设计，Socker.IO已经打包处理了。</p>
<p><strong>灵活性:</strong> 个人觉得websocket的灵活性更高一些，不管是前端还是后端，可以做更多的设计与优化，比如连接管理，容错重连，用户认证等，至少在提升技术能力上还是很有帮助。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.im/post/5cbd154be51d456e442ff348" target="_blank" rel="noopener">基于 socket.io 快速实现一个实时通讯应用</a></p>
<p><a href="https://blog.csdn.net/u013243347/article/details/86661778" target="_blank" rel="noopener">engine.io 原理详解</a></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>WebSocket &amp; socket.io</category>
      </categories>
  </entry>
  <entry>
    <title>Promise &amp; async</title>
    <url>/2018/01/16/workspace/Js/promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Promise &amp; async</strong></p>
<p>[[toc]]</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li>主要用于异步计算</li>
<li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果</li>
<li>可以在对象之间传递和操作promise，帮助我们处理队列</li>
</ul>
<p><strong>实现一个 Promise</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  resolvePromise = <span class="function">(<span class="params">promise2,x,resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断x的类型 来处理promise2是成功还是失败</span></span><br><span class="line">    <span class="comment">// 所有的promise都遵循这个规范，不同的人写的promise可能会混用</span></span><br><span class="line">    <span class="comment">// 尽可能考虑的周全 要考虑别人promise可能出错的情况</span></span><br><span class="line">    <span class="keyword">if</span>(promise2 === x)&#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断x是不是一个promise  ,这个x 可能不是自己的promise 所以为了安全 需要在进行校验，放置调一起用成功和失败</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> x === <span class="string">'function'</span> || (<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>))&#123;</span><br><span class="line">        <span class="comment">// 尝试取当前x的then方法, 这个then方法可能别人定义的时候 用的Object.defineProperty</span></span><br><span class="line">        <span class="keyword">let</span> called;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> then = x.then; <span class="comment">// 如果取then方法出错 那就用错误拒绝promise2</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">'function'</span>)&#123; <span class="comment">// 我就认为他是一个promise</span></span><br><span class="line">                then.call(x,y=&gt;&#123; <span class="comment">// 让当前的promise执行 ，不用多次取then方法了</span></span><br><span class="line">                    <span class="comment">// y 有可能还是一个promise , 继续调用resolvePromise方法，直到解析出一个常量为止，最终把常量传递下去</span></span><br><span class="line">                    <span class="keyword">if</span>(called) <span class="keyword">return</span>; <span class="comment">// 放置此方法多次被调用</span></span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    resolvePromise(promise2,y,resolve,reject);</span><br><span class="line">                &#125;,r=&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(called) <span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    reject(r); <span class="comment">// 让当前的promise变成失败态即可</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// x就是一个普通的对象 并没有then方法</span></span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// x肯定一个常量</span></span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.reason;</span><br><span class="line">        <span class="keyword">this</span>.resolveCallbacks = []; <span class="comment">// 当then是pending 我希望吧成功的方法都放到数组中</span></span><br><span class="line">        <span class="keyword">this</span>.rejectCallbacks = [];</span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 如果是promise就调用这个promise的then方法</span></span><br><span class="line">            <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">                <span class="comment">// 不停的解析 等待着解析出一个常量 传递给下面</span></span><br><span class="line">                <span class="keyword">return</span> value.then(resolve,reject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="string">'pending'</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span>;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.resolveCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn()); <span class="comment">// 发布</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.status = <span class="string">'rejected'</span>;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="keyword">this</span>.rejectCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            executor(resolve,reject);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onfulfilled,onrejected)&#123; <span class="comment">// onfulfilled,onrejected 是两个可选参数</span></span><br><span class="line">        onfulfilled = <span class="keyword">typeof</span> onfulfilled === <span class="string">'function'</span>?onfulfilled:<span class="function"><span class="params">val</span>=&gt;</span>val;</span><br><span class="line">        onrejected = <span class="keyword">typeof</span> onrejected === <span class="string">'function'</span>?onrejected:<span class="function"><span class="params">r</span>=&gt;</span>&#123;<span class="keyword">throw</span> r&#125;</span><br><span class="line">        <span class="keyword">let</span> promise2;</span><br><span class="line">        promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>)&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onfulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                        <span class="comment">// x是普通值还是promise 如果是普通值 直接调用promise2的resolve</span></span><br><span class="line">                        <span class="comment">// 如果是promise  那应该让x这个promise执行 x.then</span></span><br><span class="line">                        resolvePromise(promise2,x,resolve,reject);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'rejected'</span>)&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onrejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                        resolvePromise(promise2,x,resolve,reject);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.resolveCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onfulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                            resolvePromise(promise2,x,resolve,reject);</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,<span class="number">0</span>)</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">this</span>.rejectCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onrejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                            resolvePromise(promise2,x,resolve,reject);</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,<span class="number">0</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(rejectFunc)&#123;<span class="comment">// catch的实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>,rejectFunc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 暴露一个方法这个方法需要返回一个对象 对象上需要有 promise resolve reject 三个属性</span></span><br><span class="line"><span class="comment">// 减少嵌套</span></span><br><span class="line"><span class="built_in">Promise</span>.defer = <span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;</span><br><span class="line">    dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 产生成功的promise</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 产生一个失败的promise</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">values</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> results = []; <span class="comment">// 结果数组</span></span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> processData = <span class="function">(<span class="params">value,index</span>)=&gt;</span>&#123;</span><br><span class="line">            results[index] = value;</span><br><span class="line">            <span class="comment">// 当成功的个数 和 当前的参数个数相等就把结果抛出去</span></span><br><span class="line">            <span class="keyword">if</span>(++i === values.length)&#123;</span><br><span class="line">                resolve(results);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i&lt; values.length;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> current = values[i]; <span class="comment">// 拿到数组中每一项</span></span><br><span class="line">            <span class="comment">// 判断是不是一个promise</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">typeof</span> current === <span class="string">'object'</span> &amp;&amp;  current !==<span class="literal">null</span>)|| <span class="keyword">typeof</span> current == <span class="string">'function'</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果是promise</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">typeof</span> current.then == <span class="string">'function'</span>)&#123;</span><br><span class="line">                    <span class="comment">// 就调用这个promise的then方法，把结果和索引对应上,如果任何一个失败了返回的proimise就是一个失败的promise</span></span><br><span class="line">                    current.then(<span class="function"><span class="params">y</span>=&gt;</span>&#123;</span><br><span class="line">                        processData(y,i);</span><br><span class="line">                    &#125;,reject);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    processData(current,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                processData(current,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// race的原理</span></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">values</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i&lt; values.length;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> current = values[i];</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">typeof</span> current === <span class="string">'object'</span> &amp;&amp;  current !==<span class="literal">null</span>)|| <span class="keyword">typeof</span> current == <span class="string">'function'</span>)&#123;</span><br><span class="line">                <span class="keyword">let</span> then = current.then;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">typeof</span> then == <span class="string">'function'</span>)&#123; <span class="comment">// 比较哪个promise比较快，谁快用快</span></span><br><span class="line">                    then.call(current,resolve,reject)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(current);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                resolve(current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul>
<li>generator也是为了解决地狱回调问题的，和promise一样都是为了实现异步编程，本质还是各种回调；</li>
<li>generator为es6中新定义的数据类型，这种数据类型和函数很像，每个函数只能返回一个结果，即只能return一次，<br>如果在某些函数中没有看到return，其实质在函数结尾是存在一个隐藏的return undefined 的，而generator不同，可以返回多次</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"结束"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">//每间隔500ms执行一次g.next()，执行7次，并在控制台打印</span></span><br><span class="line">      i++;</span><br><span class="line">      <span class="built_in">console</span>.log(g.next()); <span class="comment">//执行gen函数</span></span><br><span class="line">      <span class="keyword">if</span>(i&gt;<span class="number">7</span>)&#123;</span><br><span class="line">          clearInterval(timer);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  g.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test1'</span>))</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子 可以看出generator 遇到yleld就会暂停，只有当调用<code>generator.next()</code>才会向下执行，<br>调用这个方法会返回<code>{value: x, done: true/false}</code>,这个对象中value是yield的返回值，<br>done表示generator是否执行结束，只有当执行到return时，这个对象中的done才会变成true，说明执行结束</p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>原理就是利用 generator（生成器）分割代码片段。然后我们使用一个函数让其自迭代，每一个yield 用 promise 包裹起来。执行下一步的时机由 promise 来控制</p>
<p>而且相较于Promise,async的优越性就是把每次异步返回的结果从then中拿到最外层的方法中，不需要链式调用，只要用同步的写法就可以了。<br>更加直观而且，更适合处理并发调用的问题。但是async必须以一个Promise对象开始 ，所以async通常是和Promise结合使用的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_asyncToGenerator</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 将返回值promise化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取迭代器实例</span></span><br><span class="line">      <span class="keyword">var</span> gen = fn.apply(self, args);</span><br><span class="line">      <span class="comment">// 执行下一步</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class="string">'next'</span>, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 抛出异常</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">_throw</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class="string">'throw'</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 第一次触发</span></span><br><span class="line">      _next(<span class="literal">undefined</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncGeneratorStep</span>(<span class="params">gen, resolve, reject, _next, _throw, key, arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> info = gen[key](arg);</span><br><span class="line">    <span class="keyword">var</span> value = info.value;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (info.done) &#123;</span><br><span class="line">    <span class="comment">// 迭代器完成</span></span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// -- 这行代码就是精髓 --</span></span><br><span class="line">    <span class="comment">// 将所有值promise化</span></span><br><span class="line">    <span class="comment">// 比如 yield 1</span></span><br><span class="line">    <span class="comment">// const a = Promise.resolve(1) a 是一个 promise</span></span><br><span class="line">    <span class="comment">// const b = Promise.resolve(a) b 是一个 promise</span></span><br><span class="line">    <span class="comment">// 可以做到统一 promise 输出</span></span><br><span class="line">    <span class="comment">// 当 promise 执行完之后再执行下一步</span></span><br><span class="line">    <span class="comment">// 递归调用 next 函数，直到 done == true</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolve(value).then(_next, _throw);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>await</strong><br>每次遇到await都会中断此次进程，然后去执行外面的同步代码，然后再进来，根据上次保存的next值，继续执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">121212</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">121212</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _foo = _asyncToGenerator(</span><br><span class="line">        regeneratorRuntime.mark(<span class="function"><span class="keyword">function</span> <span class="title">_callee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> regeneratorRuntime.wrap(<span class="function"><span class="keyword">function</span> <span class="title">_callee$</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (_context.prev = _context.next) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                            _context.next = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="number">121212</span>);</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                             <span class="built_in">console</span>.log(<span class="number">121212</span>);</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">"end"</span>:</span><br><span class="line">                            <span class="keyword">return</span> _context.stop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, _callee);</span><br><span class="line">        &#125;));</span><br><span class="line">    <span class="keyword">return</span> _foo.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncFunc = _asyncToGenerator(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> e = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'e'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="string">'a'</span>);</span><br><span class="line">  <span class="keyword">const</span> d = <span class="keyword">yield</span> <span class="string">'d'</span>;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="string">'b'</span>);</span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="string">'c'</span>);</span><br><span class="line">  <span class="keyword">return</span> [a, b, c, d, e];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncFunc().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>总的来说，async和generator函数主要就是为了解决异步的并发调用使用的 ，直接将参数从then里取出来，相比promise的链式调用，传参更加方便，异步顺序更加清晰</p>
<h4 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h4><p><strong>try catch</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fn()</span><br><span class="line"> &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'err is -&gt;'</span>, err)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>单个还好，多个await就显得麻烦了</p>
<p><strong>利用promise</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"> <span class="keyword">const</span> [err, data] = <span class="keyword">await</span> fn().then(<span class="function"><span class="params">data</span> =&gt;</span> [<span class="literal">null</span>, data] ).catch(<span class="function"><span class="params">err</span> =&gt;</span> [err, <span class="literal">null</span>])</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽离成公共方法</span></span><br><span class="line"><span class="keyword">const</span> awaitWrap = <span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">   .then(<span class="function"><span class="params">data</span> =&gt;</span> [<span class="literal">null</span>, data])</span><br><span class="line">   .catch(<span class="function"><span class="params">err</span> =&gt;</span> [err, <span class="literal">null</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [err, data] = <span class="keyword">await</span> awaitWrap(fn())</span><br></pre></td></tr></table></figure>

<h4 id="async函数Generator函数的区别"><a href="#async函数Generator函数的区别" class="headerlink" title="async函数Generator函数的区别"></a>async函数Generator函数的区别</h4><p>1.内置执行器。<br/><br>Generator 函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。如果你是从上面顺着看下来的，这里的执行器就是Generator和Iterator的yield和next机制，不用怀疑！</p>
<p>2.更好的语义。<br/><br>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>
<p>3.正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</p>
<p>4.返回值是 Promise。<br/><br>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p>
]]></content>
      <categories>
        <category>JS</category>
        <category>Promise &amp; async</category>
      </categories>
  </entry>
  <entry>
    <title>RegExp正则</title>
    <url>/2018/01/16/workspace/Js/reg/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>RegExp正则</strong></p>
<p>[[toc]]</p>
<h3 id="正则方法"><a href="#正则方法" class="headerlink" title="正则方法"></a>正则方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reg.test(str)  <span class="comment">//检验 </span></span><br><span class="line"><span class="comment">//字符串中有没有正则能匹配到的内容，返回值: true false</span></span><br><span class="line">reg.exec(str)  <span class="comment">//捕获 </span></span><br><span class="line"><span class="comment">//方法用于检索字符串中的正则表达式的匹配。 </span></span><br><span class="line"><span class="comment">//返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</span></span><br><span class="line">str.match(reg) <span class="comment">// 把匹配到的字符放入到数组中，不匹配返回null</span></span><br><span class="line">str.replace( reg ,<span class="string">""</span>替换成什么 | callback（替换成什么）)</span><br></pre></td></tr></table></figure>

<h3 id="正则的修饰符、元字符"><a href="#正则的修饰符、元字符" class="headerlink" title="正则的修饰符、元字符"></a>正则的修饰符、元字符</h3><h4 id="量词元字符"><a href="#量词元字符" class="headerlink" title="量词元字符"></a>量词元字符</h4><table>
<thead>
<tr>
<th align="left"><span style='display: block;text-align: left;'> 常用指令    </span></th>
<th align="left"><span style='display: block;text-align: left;'> 描述</span></th>
</tr>
</thead>
<tbody><tr>
<td align="left">\n</td>
<td align="left">在js中表示换行</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left"><code>表示出现0次到多次</code></td>
</tr>
<tr>
<td align="left">？</td>
<td align="left"><code>表示出现0次或1次</code></td>
</tr>
<tr>
<td align="left">+</td>
<td align="left"><code>表示至少出现一次</code></td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">表示出现n次</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">表示至少出现n次</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left"><code>最小是n，最大是m，（n，m都是一个非负整数</code></td>
</tr>
</tbody></table>
<p><code>中文的范围：[ \u4e00 - \u9fa5 ]</code> （记忆：有事100，有酒罚我）</p>
<h4 id="修饰符有三种"><a href="#修饰符有三种" class="headerlink" title="修饰符有三种"></a>修饰符有三种</h4><table>
<thead>
<tr>
<th align="left"><span style='display: block;text-align: left;'>修饰符</span></th>
<th align="left"><span style='display: block;text-align: left;'> 说明</span></th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">忽略大小写匹配</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">全局匹配，即是匹配一个后继续匹配，直到结束</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">多行匹配，即是遇到换行后不停止匹配，直到结束</td>
</tr>
</tbody></table>
<h4 id="特殊元字符"><a href="#特殊元字符" class="headerlink" title="特殊元字符"></a>特殊元字符</h4><table>
<thead>
<tr>
<th align="left"><span style='display: block;text-align: left;'>字符</span></th>
<th align="left"><span style='display: block;text-align: left;'> 说明</span></th>
</tr>
</thead>
<tbody><tr>
<td align="left">\d</td>
<td align="left">匹配0-9中任意一个数字</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">除了0-9以外的任意一个字符</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">数字、字母、下划线中任意一个字符</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">除了数字、字母、下划线以外任意一个字符</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配一个空白符（空格；制表符（tab）\t ；\n换行符 ；\r回车…）</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">除了空白符以外任意一个字符</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配单词边界（边界字母和非字母连接的地方）</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">匹配一个换行符</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">除换行符\n以外任意一个字符</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">转义符，把有特殊意义的字符转义为普通字符</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">(读作caret）表示以某个元字符开头</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">表示以某个元字符结尾</td>
</tr>
<tr>
<td align="left">x|y</td>
<td align="left">表示x/y中任意一个</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">表示匹配[ ]中任意一个字符</td>
</tr>
<tr>
<td align="left">[xyz]</td>
<td align="left">表示x/y/z中任意一个</td>
</tr>
<tr>
<td align="left">[a-z]</td>
<td align="left">表示匹配a-z中的任意一个小写字母</td>
</tr>
<tr>
<td align="left">[A-Z]</td>
<td align="left">表示匹配A-Z中的任意一个大写字母</td>
</tr>
<tr>
<td align="left">[0-9]</td>
<td align="left">表示匹配0-9中的任意一个数字，等价于\d</td>
</tr>
<tr>
<td align="left">[^abc]</td>
<td align="left">表示除了a、b、c以外的任意一个字符</td>
</tr>
<tr>
<td align="left">()</td>
<td align="left">正则分组</td>
</tr>
<tr>
<td align="left">(?: )</td>
<td align="left">表示当前分组只匹配不捕获（取消分组捕获）</td>
</tr>
<tr>
<td align="left">(?=)</td>
<td align="left">正向预查</td>
</tr>
<tr>
<td align="left">(?!)</td>
<td align="left">负向预查</td>
</tr>
</tbody></table>
<h4 id="正向预查、负向预查"><a href="#正向预查、负向预查" class="headerlink" title="正向预查、负向预查"></a>正向预查、负向预查</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/x(?=y)/</span> <span class="comment">// 表示匹配x，并且仅当x后紧跟着一个y（匹配紧跟着y的x）</span></span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="regexp">/x(?!y)/</span> <span class="comment">// 表示匹配x，并且仅当x后没有y（匹配后面没有y的x）</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数方式"><a href="#构造函数方式" class="headerlink" title="构造函数方式"></a>构造函数方式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\d'</span>, <span class="string">'gi'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="字面量方式"><a href="#字面量方式" class="headerlink" title="字面量方式"></a>字面量方式</h3><p>两个斜线内为正则的内容，后面可以跟修饰符，与第一种构造函数方式相比更简洁，缺点是正则内容<code>不能拼接</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'aBcd efg'</span>.match(<span class="regexp">/[a-z]+/</span>);<span class="comment">// ["a"]</span></span><br><span class="line"><span class="string">'aBcd efg'</span>.match(<span class="regexp">/[a-z]+/i</span>);<span class="comment">// ["aBcd"]</span></span><br><span class="line"><span class="string">'aBcd efg'</span>.match(<span class="regexp">/[a-z]+/g</span>);<span class="comment">// ["a", "cd", "efg"]</span></span><br><span class="line"><span class="string">'aBcd efg'</span>.match(<span class="regexp">/[a-z]+/gi</span>);<span class="comment">// ["aBcd", "efg"]</span></span><br><span class="line"><span class="string">'aB\ncd\n efg'</span>.match(<span class="regexp">/^[a-z]+/m</span>);<span class="comment">// ["a"]</span></span><br><span class="line"><span class="string">'aB\ncd\n efg'</span>.match(<span class="regexp">/^[a-z]+/g</span>);<span class="comment">// ["a"]</span></span><br><span class="line"><span class="string">'aB\ncd\n efg'</span>.match(<span class="regexp">/^[a-z]+/gm</span>);<span class="comment">// ["a", "cd"]</span></span><br><span class="line"><span class="comment">// 注意不是 ["a", "cd", "efg"]</span></span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><code>手机号*过滤</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'123567905849'</span>.replace(<span class="regexp">/^(\d&#123;3&#125;)(\d*?)(\d&#123;4&#125;)$/</span>, <span class="string">'$1****$3'</span>)  <span class="comment">// 扩展性好</span></span><br><span class="line"><span class="string">'123567905849'</span>.substr(<span class="number">0</span>, <span class="number">3</span>) + <span class="string">'****'</span> + <span class="string">'123567905849'</span>.substr(<span class="number">7</span>, <span class="number">11</span>)  <span class="comment">// 快</span></span><br></pre></td></tr></table></figure>

<p><code>用正则写一个验证23-68中的数字</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg6 = <span class="regexp">/[23-68]/</span> <span class="comment">// 不是表示23-68；而是表示2或3-6或8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将范围拆分为23-29；30-59；60-68 */</span></span><br><span class="line"><span class="keyword">let</span> reg7 = <span class="regexp">/^(2[3-9]|[3-5]\d|6[0-8])$/</span></span><br></pre></td></tr></table></figure>

<p><code>写一个正则，匹配第二个字母和第四个字母相同</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//\数字 表示(引用)数字代表的分组的内容</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[a-z]([a-z])[a-z]\1$/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">'data'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">'java'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">'fear'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>数据类型检测</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.isTypeOf = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 给传进来的val进行数据类型检测</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.prototype.toString.call(val)</span><br><span class="line">    <span class="comment">// 2. 用一个正则把需要的代表类型的字符串获取到</span></span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/^\[object ([a-zA-Z]+)\]$/</span></span><br><span class="line">    <span class="keyword">let</span> [,catches] = reg.exec(result) <span class="comment">// 从捕获结果中把类型字符串解构出来</span></span><br><span class="line">    <span class="comment">// 3. 把上一步得到的代表类型的字符串返回</span></span><br><span class="line">    <span class="keyword">return</span> catches</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isTypeOf(<span class="number">1</span>)) <span class="comment">// Number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isTypeOf(<span class="literal">true</span>)) <span class="comment">// Boolean</span></span><br></pre></td></tr></table></figure>
<p><code>url查询参数序列化</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 方便理解但方法繁杂</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">'https://www.baidu.com/s?name=mars&amp;age=18&amp;address=hebei'</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/([^?=&amp;]+)=([^?=&amp;]+)/ig</span></span><br><span class="line"><span class="keyword">let</span> urlAry = url.match(reg)</span><br><span class="line"><span class="keyword">let</span> params = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; urlAry.length ; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = urlAry[i]</span><br><span class="line">    <span class="keyword">let</span> itemAry = item.split(<span class="string">'='</span>) <span class="comment">// 按照=把字符串拆分成一个数组，数组的第一项就是key，第二项就是value</span></span><br><span class="line">    params[itemAry[<span class="number">0</span>]] = itemAry[<span class="number">1</span>] <span class="comment">// 位params添加对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(params)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 不容易理解但方法简洁</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">'https://www.baidu.com/s?name=mars&amp;age=18&amp;address=hebei'</span></span><br><span class="line"><span class="keyword">let</span> params = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/([^?=&amp;]+)=([^?=&amp;]+)/ig</span>;</span><br><span class="line">url.replace(reg, (str, key, value) =&gt; params[key] = value);</span><br><span class="line"><span class="built_in">console</span>.log(params);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 方便理解2的</span></span><br><span class="line"><span class="keyword">const</span> queryURLParameter=<span class="function">(<span class="params">url</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> regParam = <span class="regexp">/([^?&amp;=#]+)=?([^?&amp;=#]+)?/ig</span>,</span><br><span class="line">    obj = &#123;&#125;;</span><br><span class="line">    url.replace(regParam, (...arg) =&gt; &#123;</span><br><span class="line">        obj[arg[<span class="number">1</span>]] = arg[<span class="number">2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://github.com/any86/any-rule" target="_blank" rel="noopener">正则大全</a></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>RegExp正则</category>
      </categories>
  </entry>
  <entry>
    <title>Fetch和Axios的区别</title>
    <url>/2018/01/16/workspace/Js/xhr/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Fetch和Axios的区别</strong></p>
<p>[[toc]]</p>
<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>; <span class="comment">// 添加cookie</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> keyText = xhr.responseText;</span><br><span class="line">        <span class="built_in">console</span>.log(keyText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.position); <span class="comment">//进度条</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.totalSize);<span class="comment">//数据的字节</span></span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Authorization"</span>, <span class="string">`UpToken <span class="subst">$&#123;uptoken&#125;</span>`</span>);</span><br><span class="line">xhr.send(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">xhr.abort()<span class="comment">//终止请求</span></span><br></pre></td></tr></table></figure>

<h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p><strong>【 -version:0.19.0】</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局的一些配置</span></span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/json;charset=UTF-8'</span>;</span><br><span class="line">axios.defaults.headers.put[<span class="string">'Content-Type'</span>] = <span class="string">'application/json'</span>;</span><br><span class="line">axios.defaults.headers.delete[<span class="string">'Content-Type'</span>] = <span class="string">'application/json'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//axios.defaults.baseURL = 'https://xxxxx.xx.cn;</span></span><br><span class="line"><span class="comment">//axios.defaults.headers.Authorization = `$&#123;getCookie('token')&#125;`;   //这里添加这个可能导致出现options导致跨域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数用法</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    url: baseUrl,</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    params: params, <span class="comment">//如果不是get请求用 data</span></span><br><span class="line">    onDownloadProgress: <span class="function">(<span class="params">progress</span>) =&gt;</span> &#123;<span class="comment">//进度条</span></span><br><span class="line">         <span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(progress.loaded / progress.total * <span class="number">100</span>) + <span class="string">'%'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">`application/octet-stream`</span>,</span><br><span class="line">        <span class="string">'Authorization'</span>: <span class="string">`UpToken `</span>  <span class="comment">//这里可以修改默认的token</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通用法</span></span><br><span class="line"><span class="keyword">const</span> baseUrl = <span class="string">`<span class="subst">$&#123;DEVURL&#125;</span>/shop/<span class="subst">$&#123;id&#125;</span>/productOrders`</span>;</span><br><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line">axios.post(baseUrl, &#123;</span><br><span class="line">    data,</span><br><span class="line">    timeout: <span class="number">3000</span>,</span><br><span class="line">    onUploadProgress:<span class="function">(<span class="params">progress</span>)=&gt;</span>&#123;<span class="comment">//进度条</span></span><br><span class="line">        <span class="comment">// total 字节大小</span></span><br><span class="line">        <span class="comment">// loaded 加载的字节</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(progress.loaded / progress.total * <span class="number">100</span>) + <span class="string">'%'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="params">cancel</span>=&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//cancel就是CancelToken构造函数里面自带的取消请求的函数，参数会在reject里面拿到</span></span><br><span class="line">            <span class="built_in">console</span>.log(cancel(<span class="string">'取消请求'</span>));</span><br><span class="line">        &#125;, <span class="number">100</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改token</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">`<span class="subst">$&#123;url&#125;</span>`</span></span><br><span class="line">&#125;);</span><br><span class="line">instance.defaults.headers.common[<span class="string">'Authorization'</span>] = <span class="string">`Bearer <span class="subst">$&#123;getCookie(<span class="string">'token'</span>)&#125;</span>`</span>;</span><br><span class="line">axios.post(baseUrl,&#123;<span class="attr">data</span>:&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>配置axios</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加响应器</span></span><br><span class="line">axios.interceptors.response.use(<span class="literal">undefined</span>, (err)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;config, code, response, message&#125; = err;</span><br><span class="line">    <span class="comment">// 超时再次请求数据</span></span><br><span class="line">    <span class="keyword">if</span> (code === <span class="string">'ECONNABORTED'</span> &amp;&amp; message.indexOf(<span class="string">'timeout'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        notification[<span class="string">'error'</span>](&#123;</span><br><span class="line">            message: <span class="string">'连接超时'</span>,</span><br><span class="line">            description: <span class="string">'正在重新为您请求数据！'</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> axios.request(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (message === <span class="string">'取消请求'</span>) &#123;</span><br><span class="line">        notification[<span class="string">'error'</span>](&#123;</span><br><span class="line">            message: <span class="string">'已取消'</span>,</span><br><span class="line">            description: <span class="string">'已您经取消此次提交！'</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123;status, <span class="attr">data</span>: &#123;<span class="attr">error</span>: msg&#125;&#125; = response;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">        notification[<span class="string">'error'</span>](&#123;</span><br><span class="line">            message: status,</span><br><span class="line">            description: (response &amp;&amp; msg) || HTTP_ERROR[status]</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'http://xxxxx/xx.cn'</span>, </span><br><span class="line">     &#123; </span><br><span class="line">        method: <span class="string">"POST"</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">           <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        body: <span class="string">"q=参数q"</span>,</span><br><span class="line">        cache?: RequestCache;</span><br><span class="line">        credentials?: RequestCredentials;</span><br><span class="line">        integrity?: string;</span><br><span class="line">        keepalive?: boolean;</span><br><span class="line">        mode?: RequestMode;</span><br><span class="line">        redirect?: RequestRedirect;</span><br><span class="line">        referrer?: string;</span><br><span class="line">        referrerPolicy?: ReferrerPolicy;</span><br><span class="line">        signal?: AbortSignal | <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">window</span>?: any;</span><br><span class="line">     &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="Fetch-vs-Axios"><a href="#Fetch-vs-Axios" class="headerlink" title="Fetch vs Axios"></a>Fetch vs Axios</h3><h4 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h4><p><code>Fetch暂时不支持所有版本的IE</code><br/><br>与成熟的XHR对象相比，Fetch API较新，预计未来几年会进行一定的维护工作,可能后期会返工。</p>
<p>你也可以选择将Fetch polyfill与Promise polyfill结合使用，以便在IE中执行Fetch代码</p>
<h4 id="Fetch默认无Cookie"><a href="#Fetch默认无Cookie" class="headerlink" title="Fetch默认无Cookie"></a>Fetch默认无Cookie</h4><p>与XMLHttpRequest不同,<code>Fetch并不会默认发送Cookie</code>，因此应用的身份验证可能会失败,可以通过更改第二个参数中传递的初始值来解决此问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'http://xxxxx/xx.cn'</span>, </span><br><span class="line">     &#123; </span><br><span class="line">        method: <span class="string">'GET'</span>, </span><br><span class="line">        credentials: <span class="string">'same-origin'</span> </span><br><span class="line">     &#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<h4 id="错误不会被拒绝"><a href="#错误不会被拒绝" class="headerlink" title="错误不会被拒绝"></a>错误不会被拒绝</h4><p>HTTP错误（例如404 500）不会导致 Fetch返回的Promise标记为reject，.catch()也不会被执行。<br>想要精确的判断fetch是否成功，需要包含 promise.resolved 的情况，此时再判断 response.ok是不是为 true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> fetch(<span class="string">'http://xxxxx/xx.cn'</span>, &#123;<span class="attr">method</span>: <span class="string">'GET'</span>&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.ok) &#123; <span class="comment">//这里添加一个判断</span></span><br><span class="line">        <span class="keyword">return</span> response.json();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Network response was not ok.'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">json</span> =&gt;</span> <span class="built_in">console</span>.log(json)).catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'error:'</span>, error));</span><br></pre></td></tr></table></figure>
<p>仅当请求无法完成时才触发reject，例如网络故障或请求被阻止。这会使错误捕获更加复杂。</p>
<h4 id="不支持超时"><a href="#不支持超时" class="headerlink" title="不支持超时"></a>不支持超时</h4><p>Fetch不支持超时，只要浏览器允许，请求将继续。解决方法是可以将Fetch包装在一个 Promise中，例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchTimeout = <span class="function">(<span class="params">url, init, timeout = <span class="number">3000</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fetch(url, init).then(resolve).catch(reject);</span><br><span class="line">        setTimeout(reject, timeout);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>或者 Promise.race([])</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchTimeout = <span class="function">(<span class="params">url, init, timeout = <span class="number">30</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.race(</span><br><span class="line">        [</span><br><span class="line">            fetch(url, init),</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, timeout))  <span class="comment">//想要更具体的捕获这次超时，需要加具体的判断</span></span><br><span class="line">        ]</span><br><span class="line">    ).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json()); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="中止Fetch"><a href="#中止Fetch" class="headerlink" title="中止Fetch"></a>中止Fetch</h4><p>通过xhr.abort()很容易结束一个XHR请求，另外也可以通过xhr.onabort函数监测事件解决。</p>
<p>之前一直无法中止一个Fetch请求，但是现在实现了AbortController API的浏览器可以支持它。这将触发一个信号，该信号可以传递给Fetch启动对象：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchController" target="_blank" rel="noopener">AbortController接口代表一个控制器对象，允许你在需要时中止一个或多个DOM请求</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> AbortController();</span><br><span class="line">fetch(<span class="string">'http://xxxx/xx.cn'</span>, &#123;</span><br><span class="line">    method: <span class="string">'GET'</span>,</span><br><span class="line">    signal: controller.signal</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">  .then(<span class="function"><span class="params">json</span> =&gt;</span> <span class="built_in">console</span>.log(json))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error:'</span>, error));</span><br></pre></td></tr></table></figure>
<p>可以通过调用 <strong>controller.abort()</strong> 来中止,Promise被标记reject后，会调用.catch()函数。</p>
<h4 id="没有-progress"><a href="#没有-progress" class="headerlink" title="没有 progress"></a>没有 progress</h4><p>到目前为止Fetch仍不支持进度事件，因此，不可能显示文件上传或大型表单提交的进度状态。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.sitepoint.com/xmlhttprequest-vs-the-fetch-api-whats-best-for-ajax-in-2019/" target="_blank" rel="noopener">文档</a></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>Fetch和Axios的区别</category>
      </categories>
  </entry>
  <entry>
    <title>Jenkins自动化部署</title>
    <url>/2020/01/16/workspace/Jenkins/base/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Jenkins自动化部署</strong></p>
<p>[[toc]]</p>
<p><strong>Jenkins学习记录</strong></p>
<p>学前了解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux  shell</span><br><span class="line">jenkins</span><br><span class="line">jdk tomcat </span><br><span class="line">Java Development Kit是整个Java核心，包括Java运行环境、Java工具和Java基础类库。JDK作为JAVA开发的环境，不管做JAVA开发还是做安卓开发，都必须在电脑上安装JDK</span><br><span class="line">tomcat:由Apache组织提供的一种Web服务器,提供对jsp和Servlet的支持。它是一种轻量级的javaWeb容器(服务器),也是当前应用最广的JavaWeb服务器(免费)</span><br><span class="line"></span><br><span class="line">node npm</span><br><span class="line">ssh</span><br><span class="line">git github</span><br><span class="line">docker</span><br></pre></td></tr></table></figure>



<h3 id="Why-Jenkins"><a href="#Why-Jenkins" class="headerlink" title="Why Jenkins"></a>Why Jenkins</h3><p><code>是业界流行开源的持续集成的工具，广泛用于项目开发，具有自动化构建，测试，部署等功能</code></p>
<p> CI 持续集成</p>
<p> CD 持续部署</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/jenkins.jpeg'/>

<h3 id="配置jdk安装Java环境"><a href="#配置jdk安装Java环境" class="headerlink" title="配置jdk安装Java环境"></a>配置jdk安装Java环境</h3><p><code>jenkins是java编写的，所以需要先安装jdk</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src &#x2F;&#x2F;选择下载目录</span><br><span class="line"></span><br><span class="line">wget https:&#x2F;&#x2F;download.oracle.com&#x2F;otn&#x2F;java&#x2F;jdk&#x2F;8u221-b11&#x2F;230deb18db3e4014bb8e3e8324f81b43&#x2F;jdk-8u221-linux-x64.tar.gz</span><br><span class="line">wget http:&#x2F;&#x2F;img.zhufengpeixun.cn&#x2F;jdk1.8.0_211.tar.gz  &#x2F;&#x2F;下载目录备份</span><br><span class="line"></span><br><span class="line">tar -xzvf [name] &#x2F;&#x2F;解压</span><br><span class="line"></span><br><span class="line">mkdir &#x2F;usr&#x2F;java &#x2F;&#x2F;创建Java的目录</span><br><span class="line"></span><br><span class="line">cp -r [name]   &#x2F;usr&#x2F;java &#x2F;&#x2F;copy</span><br><span class="line"></span><br><span class="line">ln -s  &#x2F;usr&#x2F;java&#x2F;[name]&#x2F;bin&#x2F;java &#x2F;usr&#x2F;bin&#x2F;java   &#x2F;&#x2F;创建一个软连接 or 创建全局变量</span><br><span class="line"></span><br><span class="line">java -version &#x2F;&#x2F;查看版本号是否成功</span><br></pre></td></tr></table></figure>

<h3 id="配置-启动-Jenkins"><a href="#配置-启动-Jenkins" class="headerlink" title="配置/启动 Jenkins"></a>配置/启动 Jenkins</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d</span><br><span class="line"></span><br><span class="line">wget http:<span class="comment">//pkg.jenkins.io/redhat/jenkins.repo   //安装源</span></span><br><span class="line"></span><br><span class="line">rpm --<span class="keyword">import</span> http:<span class="comment">//pkg.jenkins.io/redhat/jenkins.io.key//导入验证的key</span></span><br><span class="line"></span><br><span class="line">yum install -y jenkins     <span class="comment">//yum安装</span></span><br><span class="line"></span><br><span class="line">service jenkins start/stop/restart</span><br><span class="line"></span><br><span class="line">打开 <span class="string">`http://120.79.229.197:8080`</span>  <span class="comment">//打开jenkins</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//ip/exit //关闭jenkins服务.</span></span><br><span class="line">http:<span class="comment">//ip/reload //重新加载配置信息</span></span><br><span class="line">http:<span class="comment">//ip/restart //重启</span></span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line">systemctl start  mysqld.service</span><br><span class="line">systemctl start  docker</span><br><span class="line">docker ps -a</span><br><span class="line">docker start  [name]</span><br></pre></td></tr></table></figure>
<h4 id="如果是wget-安装的话"><a href="#如果是wget-安装的话" class="headerlink" title="如果是wget 安装的话"></a>如果是wget 安装的话</h4><p><code>启动jenkins</code><br/><br>java -jar jenkins.war –httpPort=8081</p>
<p><code>如果想要在linux后台一直运行，则要开始加nohup，在末尾加&amp;号</code><br/><br>nohup java -jar jenkins.war –httpPort=8081 &amp;</p>
<p>启动后 会生成一个nohup.out输出，需要的话，可以tail -f nohup.out实时查看日志</p>
<p><code>列出jenkins的所有进程</code><br/><br>ps -aux|grep jenkins</p>
<p><code>杀死这个进程</code><br/><br>kill -9 [PID]</p>
<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>账号：admin <br/><br>密码：<code>cat /var/lib/jenkins/secrets/initialAdminPassword</code>（初始密码）</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>首先重置安装源，切换到中国的镜像</p>
<p>系统管理-&gt;插件管理-&gt;高级-&gt;升级的站点</p>
<p><code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</code> 清华大学的站点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Generic Webhook Trigger  <span class="comment">//web触发器</span></span><br><span class="line"></span><br><span class="line">Publish Over SSH  <span class="comment">//通过ssh部署服务器</span></span><br><span class="line"></span><br><span class="line">nvm wrapper   <span class="comment">//提供node环境 </span></span><br><span class="line"></span><br><span class="line">Role-based Authorization Strategy<span class="comment">//增加用户的权限管理</span></span><br></pre></td></tr></table></figure>

<h4 id="手动下载jenkins插件"><a href="#手动下载jenkins插件" class="headerlink" title="手动下载jenkins插件"></a>手动下载jenkins插件</h4><p>插件下载地址：<code>http://updates.jenkins-ci.org/download/plugins/</code></p>
<p>如果有插件一直安装失败的情况，可以从jenkins官网下载插件，然后导入到jenkins。</p>
<p>示例：我从官方下载gitlab-plugin插件到本地，然后导入到jenkins中。</p>
<p>在jenkins<code>插件管理-&gt;高级</code>选择上传插件进行安装。</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/plugin.png'/>


<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置开机启用防火墙：systemctl enable firewalld.service</span><br><span class="line">设置开机禁用防火墙：systemctl disable firewalld.service</span><br><span class="line">启动防火墙：systemctl start firewalld</span><br><span class="line">关闭防火墙：systemctl stop firewalld.service</span><br><span class="line">检查防火墙状态：systemctl status firewalld</span><br></pre></td></tr></table></figure>

<h3 id="添加项目"><a href="#添加项目" class="headerlink" title="添加项目"></a>添加项目</h3><p>新建一个任务[name]-&gt;构架一个自由风格的项目-&gt;确定</p>
<p>源代码-&gt;git-&gt;<a href="https://github.com/hzfvictory/weapp.git-&gt;添加权限【git" target="_blank" rel="noopener">https://github.com/hzfvictory/weapp.git-&gt;添加权限【git</a> 的用户名和密码】-&gt;构建触发器(Generic Webhook Trigger)-&gt;应用保存</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/addGit.png'/>

<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/trigger.png'/>

<h3 id="配置webhook"><a href="#配置webhook" class="headerlink" title="配置webhook"></a>配置webhook</h3><p>此时可以构建了，但是需要在还给Git中添加Webhooks，否则不能自动化构建</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/webhooks.png'/>

<p><code>http://JENKINS_URL/generic-webhook-trigger/invoke</code> </p>
<p>JENKINS_URL格式为 <code>用户名:token@ip:8080</code></p>
<p><strong>token生成的位置</strong><br/><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/token.png'/></p>
<p>admin<br/><br>1108c27bdd32e70d8ba6ba7893bcf57450<br/><br>120.79.229.197:8080<br/><br><a href="http://admin:1108c27bdd32e70d8ba6ba7893bcf57450@120.79.229.197:8080/generic-webhook-trigger/invoke" target="_blank" rel="noopener">http://admin:1108c27bdd32e70d8ba6ba7893bcf57450@120.79.229.197:8080/generic-webhook-trigger/invoke</a></p>
<h3 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h3><p>手动触发，查看日志是否成功<br/><br>代码默认目录,在控制台查看  cd /var/lib/jenkins/workspace/[name]</p>
<p>也可以Git提交一版代码触发看是否成功</p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>下拉任务名字-&gt;配置-&gt;构建环境（选中Run the build in an NVM managed environment，【我们自己下载的插件提供node环境】）-&gt;<br>输入node的版本号-&gt;构建-&gt;选择shell</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/nvm.png'/>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $GIT_BRANCH</span><br><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm install -g yarn </span><br><span class="line">yarn config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">yarn install</span><br><span class="line">yarn global add @tarojs&#x2F;cli@1.3.14</span><br><span class="line">yarn build:h5</span><br><span class="line">tar -czvf dist.tar.gz dist&#x2F;h5</span><br></pre></td></tr></table></figure>

<h3 id="添加服务器的私钥"><a href="#添加服务器的私钥" class="headerlink" title="添加服务器的私钥"></a>添加服务器的私钥</h3><p>系统管理-&gt;系统设置-&gt;Publish over SSH</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/ssh.png'/>

<h3 id="配置免费登录（同一台也要）"><a href="#配置免费登录（同一台也要）" class="headerlink" title="配置免费登录（同一台也要）"></a>配置免费登录（同一台也要）</h3><p>ssh-keygen -t rsa</p>
<p>ssh-copy-id 120.79.229.197</p>
<p><code>这里不配置免登录，在部署的时候，找不到要部署的服务器</code></p>
<h3 id="构建后操作"><a href="#构建后操作" class="headerlink" title="构建后操作"></a>构建后操作</h3><p>下拉任务名字-&gt;配置-&gt;构建后操作-&gt;Send build artifacts over SSH<br><br/><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/deploy.png'/></p>
<h3 id="邮件提醒"><a href="#邮件提醒" class="headerlink" title="邮件提醒"></a>邮件提醒</h3><p>1.系统管理-&gt;系统设置-&gt;Jenkins Location(系统管理员邮件地址) <a href="mailto:feng960106@163.com">feng960106@163.com</a></p>
<p>2.系统管理-&gt;系统设置-&gt;Extended E-mail Notification</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/email.png'/>

<p>3.系统管理-&gt;系统设置-&gt;邮件通知</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/nextEmail.png'/>

<p>4.拉任务名字-&gt;配置-&gt;构建后操作-&gt;Editable Email Notification</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/nextDeployEmail.png'/>
<br/>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/always.png'/>

<blockquote>
<p>优化jenkins运行内存 vim /etc/sysconfig/jenkins</p>
</blockquote>
<h3 id="Jenkins权限设置错误"><a href="#Jenkins权限设置错误" class="headerlink" title="Jenkins权限设置错误"></a>Jenkins权限设置错误</h3><h4 id="修改config-xml"><a href="#修改config-xml" class="headerlink" title="修改config.xml"></a>修改config.xml</h4><p>先查看目录 find / -name jenkins</p>
<ul>
<li>cd /var/lib/jenkins</li>
</ul>
<p>先备份 cp config.xml hzf.xml</p>
<p>删除以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;authorizationStrategy <span class="class"><span class="keyword">class</span></span>=<span class="string">"hudson.security.ProjectMatrixAuthorizationStrategy"</span>&gt; </span><br><span class="line">  ...</span><br><span class="line">&lt;<span class="regexp">/authorizationStrategy&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;securityRealm class="hudson.security.HudsonPrivateSecurityRealm"&gt;</span></span><br><span class="line"><span class="regexp">&lt;disableSignup&gt;true&lt;/</span>disableSignup&gt;</span><br><span class="line">&lt;enableCaptcha&gt;<span class="literal">false</span>&lt;<span class="regexp">/enableCaptcha&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>securityRealm&gt;</span><br></pre></td></tr></table></figure>

<p><strong>启动jenkins</strong></p>
<p>service jenkins restart</p>
<p><strong>再次访问Jenkins后，首先要设置登录认证。</strong></p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src='/assets/img/security.png'/>


<h3 id="Jenkins调优"><a href="#Jenkins调优" class="headerlink" title="Jenkins调优"></a>Jenkins调优</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看物理CPU个数</span><br><span class="line">cat &#x2F;proc&#x2F;cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line"></span><br><span class="line"># 查看每个物理CPU中core的个数(即核数)</span><br><span class="line">cat &#x2F;proc&#x2F;cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line"></span><br><span class="line"># 限制jenkins 启动占用内存</span><br><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;jenkins</span><br><span class="line">JENKINS_JAVA_OPTIONS&#x3D;&quot;-XX:MaxPermSize&#x3D;512m -Djava.awt.headless&#x3D;true&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd /usr/mongodb/bin</span><br><span class="line">./mongod  --config /usr/local/mongodb/mongodb.conf</span><br><span class="line"></span><br><span class="line">pm2 start /home/admin/fenggeServer/bin/www --name=<span class="string">'fenggezaoxing'</span></span><br><span class="line">pm2 start /home/admin/workplaceServer/bin/www --name=<span class="string">'workplace'</span></span><br><span class="line">pm2 start /home/admin/transition/bin/www --name=<span class="string">'transition'</span></span><br><span class="line">pm2 start /home/admin/wangyiyunServer/app.js --name=<span class="string">'wangyiyunServer'</span></span><br></pre></td></tr></table></figure>

<h3 id="卸载jenkins"><a href="#卸载jenkins" class="headerlink" title="卸载jenkins"></a>卸载jenkins</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">service jenkins stop</span><br><span class="line"> </span><br><span class="line">yum clean all</span><br><span class="line"> </span><br><span class="line">yum -y remove jenkins</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Other</category>
        <category>Jenkins自动化部署</category>
      </categories>
      <tags>
        <tag>自动化部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Worker</title>
    <url>/2018/01/16/workspace/Js/webWorker/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Web Worker</strong></p>
<p>[[toc]]</p>
<p>JavaScript 语言采用的是<code>单线程模型</code>，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p>
<p>Web Worker 的作用，就是为 JavaScript <code>创造多线程环境</code>，允许主线程创建 Worker 线程，将一些任务分配给后者运行。<br>在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。<br>这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。<br>这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<h4 id="Web-Worker-有以下几个使用注意点"><a href="#Web-Worker-有以下几个使用注意点" class="headerlink" title="Web Worker 有以下几个使用注意点"></a>Web Worker 有以下几个使用注意点</h4><p>(1)<strong>同源限制</strong><br/><br>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
<p>(2)<strong>DOM 限制</strong><br/><br>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用<code>document、window、parent</code>这些对象。<br>但是，Worker 线程可以<code>navigator对象和location</code>对象。</p>
<p>(3)<strong>通信联系</strong><br/><br>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>
<p>(4)<strong>脚本限制</strong><br/><br>Worker 线程不能执行<code>alert()</code>方法和<code>confirm()</code>方法，但可以使用 <code>XMLHttpRequest</code> 对象发出 AJAX 请求。</p>
<p>(5)<strong>文件限制</strong><br/><br>Worker 线程无法读取本地文件，即不能打开本机的文件系统（<code>file://</code>），它所加载的脚本，必须来自网络。</p>
<h4 id="Worker用法"><a href="#Worker用法" class="headerlink" title="Worker用法"></a>Worker用法</h4><p>通常情况下，Worker 载入的是一个<code>单独的 JavaScript 脚本文件</code>，但是也可以载入与主线程在同一个网页的代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"worker"</span> <span class="attr">type</span>=<span class="string">"app/worker"</span>&gt;</span></span><br><span class="line"><span class="actionscript">      addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        postMessage(<span class="string">'some message'</span>);</span></span><br><span class="line"><span class="actionscript">      &#125;, <span class="literal">false</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面是一段嵌入网页的脚本，注意必须指定script标签的type属性是一个浏览器不认识的值，上例是<code>app/worker</code>。</p>
<p>然后，读取这一段嵌入页面的脚本，用 Worker 来处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">document</span>.querySelector(<span class="string">'#worker'</span>).textContent]);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(url);</span><br><span class="line"></span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// e.data === 'some message'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。</p>
<p><code>可以配合webpack 使用worker-loader 方便其操作</code></p>
<h4 id="主线程初始化WebWorker"><a href="#主线程初始化WebWorker" class="headerlink" title="主线程初始化WebWorker"></a>主线程初始化WebWorker</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一 同页面的 Web Worker</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebWorker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(worker) &#123;</span><br><span class="line">        <span class="keyword">const</span> code = worker.toString();</span><br><span class="line">        <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([<span class="string">'('</span> + code + <span class="string">')()'</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Worker(URL.createObjectURL(blob));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.worker = <span class="keyword">new</span> WebWorker(worker,&#123;<span class="attr">name</span>:<span class="string">'这是worker的名称  self.name能获取出来'</span>&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二 worker.js放到public目录</span></span><br><span class="line"><span class="keyword">this</span>.worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="主线程向Worker发消息"><a href="#主线程向Worker发消息" class="headerlink" title="主线程向Worker发消息"></a>主线程向Worker发消息</h4><p>然后，<code>主线程调用worker.postMessage()</code>方法，向 Worker 发消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> params = &#123;</span><br><span class="line">    users,</span><br><span class="line">    types:<span class="string">'users'</span>  <span class="comment">//这里加个类型，方便子线程判断  【e.data.types】</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.worker.postMessage(params);</span><br></pre></td></tr></table></figure>
<p>worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是<code>各种数据类型</code>，包括二进制数据。</p>
<h4 id="子线程发回处理后的数据"><a href="#子线程发回处理后的数据" class="headerlink" title="子线程发回处理后的数据"></a>子线程发回处理后的数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//worker.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">    self.addEventListener(<span class="string">'message'</span>, e =&gt; &#123; <span class="comment">// eslint-disable-line no-restricted-globals</span></span><br><span class="line">        <span class="keyword">if</span> (!e) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">let</span> &#123;users,types&#125; = e.data;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; users.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; users.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (users[i].id &gt; users[j].id) &#123;</span><br><span class="line">                    <span class="keyword">const</span> t = users[i];</span><br><span class="line">                    users[i] = users[j];</span><br><span class="line">                    users[j] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        postMessage(users);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//self代表子线程自身，即子线程的全局对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里可以添加判断，调用不同的方法</span></span><br><span class="line"><span class="keyword">let</span> &#123;types,user&#125; = e.data;</span><br><span class="line"><span class="keyword">switch</span> (types) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'users'</span>:</span><br><span class="line">        self.postMessage(user);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程内部关闭自身。</span></span><br><span class="line">self.close()</span><br></pre></td></tr></table></figure>

<h4 id="主线程接收数据"><a href="#主线程接收数据" class="headerlink" title="主线程接收数据"></a>主线程接收数据</h4><p>接着，<code>主线程通过worker.onmessage</code>指定监听函数，接收子线程发回来的消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">this</span>.worker.addEventListener(<span class="string">'message'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> sortedList = event.data;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        users: sortedList,</span><br><span class="line">        isSorting: <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="关闭Worker"><a href="#关闭Worker" class="headerlink" title="关闭Worker"></a>关闭Worker</h4><p>Worker 完成任务以后，<code>主线程</code>就可以把它关掉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.worker.terminate();</span><br></pre></td></tr></table></figure>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.worker.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>子线程内部也可以监听error事件。</p>
<h4 id="Worker线程完成轮询"><a href="#Worker线程完成轮询" class="headerlink" title="Worker线程完成轮询"></a>Worker线程完成轮询</h4><p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebWorker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(worker) &#123;</span><br><span class="line">        <span class="keyword">const</span> code = worker.toString();</span><br><span class="line">        <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([<span class="string">'('</span> + code + <span class="string">')()'</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Worker(URL.createObjectURL(blob));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pollingWorker = WebWorker( <span class="function">(<span class="params">e</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cache;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">new, old</span>) </span>&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    fetch(<span class="string">'/my-api-endpoint'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> data = res.json();</span><br><span class="line">      <span class="comment">//如果不一致</span></span><br><span class="line">      <span class="keyword">if</span> (!compare(data, cache)) &#123;</span><br><span class="line">        cache = data;</span><br><span class="line">        self.postMessage(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//主进程</span></span><br><span class="line">worker.addEventListener(<span class="string">'message'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> sortedList = event.data;</span><br><span class="line">    .....</span><br><span class="line">&#125;);</span><br><span class="line">pollingWorker.postMessage(<span class="string">'success'</span>);</span><br></pre></td></tr></table></figure>
<p>Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p><strong>主线程</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myWorker = <span class="keyword">new</span> Worker(jsUrl, options);</span><br></pre></td></tr></table></figure>

<p>Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且<code>只能加载JS脚本</code>，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是<code>指定Worker的名称</code>，用来区分多个Worker线程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">let</span> myWorker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>, &#123; <span class="attr">name</span> : <span class="string">'myWorker'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 线程</span></span><br><span class="line">self.name <span class="comment">// myWorker</span></span><br></pre></td></tr></table></figure>

<p>Worker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。</p>
<p><strong>主线程对象的属性和方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Worker.onerror：指定 error 事件的监听函数。</span><br><span class="line">Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。</span><br><span class="line">Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</span><br><span class="line">Worker.postMessage()：向 Worker 线程发送消息。</span><br><span class="line">Worker.terminate()：立即终止 Worker 线程。</span><br></pre></td></tr></table></figure>

<p><strong>Worker 线程</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.name： Worker 的名字。该属性只读，由构造函数指定。</span><br><span class="line">self.onmessage：指定message事件的监听函数。</span><br><span class="line">self.onmessageerror：指定messageerror事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</span><br><span class="line">self.close()：关闭Worker线程。</span><br><span class="line">self.postMessage()：向主线程发送消息。</span><br><span class="line">self.importScripts()：加载JS脚本。</span><br></pre></td></tr></table></figure>

<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>webWorker解决的是js中数据处理导致的UI线程阻塞</p>
<ul>
<li>计算量数据大的，不能控制在毫秒级内的运算都可以考虑放在web worker中执行。</li>
<li>高频的用户交互根据用户的输入习惯、历史记录以及缓存等信息来协助用户完成输入的纠错、校正功能等类似场景，用户频繁输入的响应处理同样可以考虑放在web worker中执行</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>Web Worker</category>
      </categories>
  </entry>
  <entry>
    <title>简易封装Cookie</title>
    <url>/2018/01/16/workspace/Project/cookie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>简易封装Cookie</strong></p>
<p>[[toc]]</p>
<p>Cookie不仅仅有名字和值两个属性，还有域（domain）、路径（path）等属性。其中，不同的域、不同的路径下可以存在同样名字的cookie。<br>一般我们设置cookie的方法是用一个同样名字、一个值。这时就一定要搞清楚你要设置的cookie的域和路径，否则就会产生问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成过期时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number|Infinity&#125;</span> </span>day 过期天数 默认 Infinity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">generateExpires</span>(<span class="params">day</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> getDay = day || <span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">const</span> getNow = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> getYearNumber = getNow.getFullYear();</span><br><span class="line">    <span class="keyword">const</span> getMonthNumber = getNow.getMonth() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> getDateNumber = getNow.getDate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> getFullToday = <span class="string">`<span class="subst">$&#123;getYearNumber&#125;</span>-<span class="subst">$&#123;getMonthNumber&#125;</span>-<span class="subst">$&#123;getDateNumber&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    getNow.setTime(<span class="keyword">new</span> <span class="built_in">Date</span>(getFullToday).getTime() + (getDay * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getNow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 Cookie</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>name Cookie 名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String|Number|Boolean&#125;</span> </span>value Cookie 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>expires 过期时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires = generateExpires(Infinity</span>)) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.cookie = <span class="string">`<span class="subst">$&#123;name&#125;</span>=<span class="subst">$&#123;value&#125;</span>; expires=<span class="subst">$&#123;expires.toUTCString()&#125;</span>; path=/`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 Cookie</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>name 名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cname = <span class="string">`<span class="subst">$&#123;name&#125;</span>=`</span>;</span><br><span class="line">    <span class="keyword">const</span> Cookie = <span class="built_in">document</span>.cookie.split(<span class="string">';'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; Cookie.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> item = Cookie[i];</span><br><span class="line">        <span class="keyword">while</span> (item.charAt(<span class="number">0</span>) === <span class="string">' '</span>) item = item.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (item.indexOf(cname) === <span class="number">0</span>) <span class="keyword">return</span> item.substring(cname.length, item.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除 Cookie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>name 名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">removeCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!name) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'请输入Cookie名'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> expires = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        expires.setTime(expires.getTime() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> value = getCookie(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            setCookie(name, value, expires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Project</category>
        <category>简易封装Cookie</category>
      </categories>
  </entry>
  <entry>
    <title>实现JS复制内容到剪贴板</title>
    <url>/2019/03/19/workspace/Project/copy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>实现JS复制内容到剪贴板</strong></p>
<p>[[toc]]</p>
<p><strong>实现JS复制内容到剪贴板</strong></p>
<p>(1):<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">第三方库：clipboard.js</a></p>
<p>(2):<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand" target="_blank" rel="noopener">原生方法：document.execCommand()</a></p>
<ul>
<li>execCommand()允许运行命令来操作可编辑区域的内容，注意是<code>可编辑区域</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bool = <span class="built_in">document</span>.execCommand(aCommandName, aShowDefaultUI, aValueArgument)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法返回一个 Boolean 值，表示操作是否成功。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//aCommandName ：表示命令名称，比如： copy, cut 等</span></span><br><span class="line"><span class="comment">//aShowDefaultUI：是否展示用户界面，一般情况下都是 false；</span></span><br><span class="line"><span class="comment">//aValueArgument：有些命令需要额外的参数，一般用不到；</span></span><br></pre></td></tr></table></figure>

<p>execCommand()方法的定义中提到，它只能操作可编辑区域，也就是意味着除了 <code>&lt;input&gt;、&lt;textarea&gt;</code>这样的输入域以外，是无法使用这个方法的。</p>
<p><code>曲线救国</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">clipboard = <span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> copyText = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line"> copyText.setAttribute(<span class="string">'readonly'</span>, <span class="string">'readonly'</span>);<span class="comment">//防止在移动端默认获取焦点，使键盘弹起</span></span><br><span class="line"> copyText.setAttribute(<span class="string">'value'</span>, text);</span><br><span class="line"> <span class="built_in">document</span>.body.appendChild(copyText);</span><br><span class="line"> copyText.select();</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>)) &#123;</span><br><span class="line">     <span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>);</span><br><span class="line">     alert(<span class="string">'复制成功'</span>);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     alert(<span class="string">'请手动复制'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">document</span>.body.removeChild(copyText);<span class="comment">//删除节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Project</category>
        <category>实现JS复制内容到剪贴板</category>
      </categories>
  </entry>
  <entry>
    <title>seamless-immutable</title>
    <url>/2019/03/19/workspace/Project/immutable/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>seamless-immutable</strong></p>
<p>[[toc]]</p>
<p>React在减少重复渲染方面确实是有一套独特的处理办法，那就是虚拟DOM，但显然在首次渲染的时候React绝无可能超越原生的速度，或者一定能将其它的框架比下去。<br>但是每次数据变动都会执行render，大大影响了性能，特别是在移动端。</p>
<p>JavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。如 foo={a: 1}; bar=foo; bar.a=2 你会发现此时 foo.a 也被改成了 2。虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。</p>
<p>seamless-immutable 与immutable功能类似，通过共享现有嵌套对象来提高深度复制大型嵌套对象时的速度。seamless-immutable中通过Object.freeze防止对象被修改，并定义了一系列API来实现对不可变数据结构的操作。(仅限于数组和对象)</p>
<p>与 Immutable.js 学院派的风格不同，seamless-immutable 并没有实现完整的 Persistent Data Structure，<br>而是使用 Object.defineProperty（因此只能在 IE9 及以上使用）扩展了 JavaScript 的 Array 和 Object 对象来实现，<br>只支持 Array 和 Object 两种数据类型，API 基于与 Array 和 Object 操持不变。代码库非常小，<strong>压缩后下载只有 2K。而 Immutable.js 压缩后下载有 16K</strong>。</p>
<p>Object.freeze() 方法可以冻结一个对象，冻结的对象不能添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。尝试修改会静默失败或抛出TypeError类型的错误。相关函数还包括：<br>Object.isExtensible()<br>Object.seal()<br>Object.freeze和Object.defineProperty均为ES5中定义的方法，因此使用seamless-immutable需保证浏览器中这些方法存在</p>
<p>与 Object.freeze、const 区别</p>
<p>Object.freeze 和 ES6 中新加入的 const 都可以达到防止对象被篡改的功能，但它们是 shallowCopy 的。对象层级一深就要特殊处理了。</p>
<hr>
<ul>
<li><strong>开始使用</strong></li>
<li>yarn add seamless-immutable</li>
<li>import Immutable from “seamless-immutable”</li>
</ul>
<h1 id="Immutable-Array"><a href="#Immutable-Array" class="headerlink" title="Immutable Array"></a>Immutable Array</h1><hr>
<h3 id="from-type"><a href="#from-type" class="headerlink" title="from(type)"></a>from(type)</h3><ul>
<li>type：array | object</li>
<li>设置成 Immutable 对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> code1 = Immutable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"> <span class="keyword">let</span> code2 = Immutable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">//同 from()</span></span><br><span class="line"> <span class="built_in">console</span>.log(code1);<span class="comment">//Immutable([1, 2, 3])</span></span><br><span class="line"> <span class="built_in">console</span>.log(code2);<span class="comment">//Immutable([1, 2, 3])</span></span><br></pre></td></tr></table></figure>

<h3 id="flatMap-obj-fun"><a href="#flatMap-obj-fun" class="headerlink" title="flatMap(obj,fun)"></a>flatMap(obj,fun)</h3><ul>
<li>obj： immutable</li>
<li>fun : function</li>
<li>循环 immutable 对象， 返回 一个新的 immutable 对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = Immutable([<span class="string">'AA'</span>, <span class="string">'BB'</span>, <span class="string">'CC'</span>]);</span><br><span class="line"><span class="keyword">let</span> newarr = Immutable.flatMap(array, str =&gt; <span class="string">'hello '</span> + str);</span><br><span class="line"><span class="built_in">console</span>.log(newarr); <span class="comment">//Immutable(["hello AA", "hello BB", "hello CC"])</span></span><br></pre></td></tr></table></figure>


<h3 id="isImmutable-type"><a href="#isImmutable-type" class="headerlink" title="isImmutable(type)"></a>isImmutable(type)</h3><ul>
<li><p>type：array | object | immutable</p>
</li>
<li><p>判断是否是 Immutable 对象</p>
</li>
<li><p>注：参数如果是 int string bool,undefined,null 返回 true</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> code1=Immutable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> code2= &#123;<span class="attr">a</span>: <span class="number">12</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Immutable.isImmutable(code1)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Immutable.isImmutable(code2)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h1 id="Immutable-Object-Array"><a href="#Immutable-Object-Array" class="headerlink" title="Immutable Object || Array"></a>Immutable Object || Array</h1></li>
</ul>
<hr>
<h3 id="asMutable-obj-type"><a href="#asMutable-obj-type" class="headerlink" title="asMutable(obj,type)"></a>asMutable(obj,type)</h3><ul>
<li>obj： immutable</li>
<li>type：默认是{deep:false}</li>
<li>返回数组的可变副本,对于深度可变的副本需设置 {deep:true}</li>
<li><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutableArray = immutable.asMutable(banner,&#123;<span class="attr">deep</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">    mutableArray.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item.victory=<span class="string">'victory'</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(mutableArray,banner);<span class="comment">//可改变</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Immutable-Object"><a href="#Immutable-Object" class="headerlink" title="Immutable Object"></a>Immutable Object</h1><hr>
<h3 id="merge-obj1-obj2-type"><a href="#merge-obj1-obj2-type" class="headerlink" title="merge (obj1,obj2,type)"></a>merge (obj1,obj2,type)</h3><ul>
<li>obj1 immutable</li>
<li>obj2 : object| array</li>
<li>type: object 默认是{deep:false}</li>
<li></li>
<li>返回合并后的 Immutable,对于深度可变的副本需设置 {deep:true}</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//code1:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">a</span>: <span class="string">'AA'</span>, <span class="attr">b</span>: <span class="string">'BB'</span>, <span class="attr">c</span>: <span class="string">'CC'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> newobj = Immutable.merge(obj, &#123;<span class="attr">c</span>: <span class="string">'CC'</span>, <span class="attr">d</span>: <span class="string">'DD'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newobj); <span class="comment">// Immutable(&#123;a: "AA", b: "BB", c: "CC", d: "DD"&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//code2:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">status</span>: <span class="string">'ok'</span>, <span class="attr">data</span>: &#123;<span class="attr">a</span>: <span class="string">'AA'</span>, <span class="attr">b</span>: <span class="string">'BB'</span>&#125;&#125;);</span><br><span class="line"><span class="keyword">let</span> newsobj = Immutable.merge(obj, [&#123;<span class="attr">status</span>: <span class="string">'error'</span>, <span class="attr">data</span>: &#123;<span class="attr">c</span>: <span class="string">'CC'</span>&#125;&#125;, &#123;<span class="attr">data</span>: &#123;<span class="attr">a</span>: <span class="string">'AAAA'</span>&#125;&#125;], &#123;<span class="attr">deep</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newsobj); <span class="comment">//Immutable(&#123;status: "error", &#123;a: "AAAA", b: "BB", c: "CC"&#125;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//code3:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> code1 = Immutable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">//Array无效</span></span><br><span class="line"><span class="keyword">let</span> code2 = Immutable.merge(code1, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(code2); <span class="comment">//Immutable([1,2,3])</span></span><br></pre></td></tr></table></figure>

<h3 id="replace-obj1-obj2-type"><a href="#replace-obj1-obj2-type" class="headerlink" title="replace(obj1,obj2,type)"></a>replace(obj1,obj2,type)</h3><ul>
<li><p>obj1 immutable</p>
</li>
<li><p>obj2 : object</p>
</li>
<li><p>type: object 默认是{deep:false}</p>
</li>
<li><p>返回替换后的 Immutable,对于深度可变的副本需设置 {deep:true}</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = Immutable(&#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="string">'test'</span>&#125;, <span class="attr">c</span>: <span class="string">'test'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> obj2 = Immutable.replace(obj1, &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="string">'test'</span>&#125;, <span class="attr">d</span>: <span class="string">'ok'</span>&#125;, &#123;<span class="attr">deep</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);<span class="comment">//Immutable(&#123;a: &#123;b: 'test'&#125;, d: 'ok'&#125;)</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2); <span class="comment">//  false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.a === obj2.a); <span class="comment">//  true。</span></span><br></pre></td></tr></table></figure>

<h3 id="set-obj-key-value-type"><a href="#set-obj-key-value-type" class="headerlink" title="set(obj,key,value,type)"></a>set(obj,key,value,type)</h3><ul>
<li>obj1 immutable</li>
<li>key : string</li>
<li>value : any</li>
<li>type: object 默认是{deep:false}</li>
<li>设置 immutable 对象制定的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">a</span>: <span class="string">'AA'</span>, <span class="attr">b</span>: <span class="string">'BB'</span>, <span class="attr">c</span>: &#123;<span class="attr">d</span>: <span class="string">'DD'</span>&#125;&#125;);</span><br><span class="line"><span class="keyword">let</span> newobj = Immutable.set(obj, <span class="string">'b'</span>, <span class="string">'BBB'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Immutable(&#123;a: 'AA', b: 'BB', c: &#123;d: 'DD'&#125;&#125;)</span></span><br><span class="line"><span class="built_in">console</span>.log(newobj); <span class="comment">// Immutable(&#123;a: 'AA', b: 'BBB', c: &#123;d: 'DD'&#125;&#125;)</span></span><br></pre></td></tr></table></figure>


<h3 id="setIn-obj-key-value-type"><a href="#setIn-obj-key-value-type" class="headerlink" title="setIn (obj,key,value,type)"></a>setIn (obj,key,value,type)</h3><ul>
<li>obj1 immutable</li>
<li>key : string</li>
<li>value : any</li>
<li>type: object 默认是{deep:false}</li>
<li>深度设置 immutable 对象制定的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">a</span>: <span class="string">'AA'</span>, <span class="attr">b</span>: <span class="string">'BB'</span>, <span class="attr">c</span>: &#123;<span class="attr">d</span>: <span class="string">'DD'</span>&#125;&#125;);</span><br><span class="line"><span class="keyword">let</span> newobj = Immutable.setIn(obj, [<span class="string">'c'</span>, <span class="string">'d'</span>], <span class="string">'DDDD'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//Immutable(&#123;a: 'AA', b: 'BB', c: &#123;d: 'DD'&#125;)</span></span><br><span class="line"><span class="built_in">console</span>.log(newobj); <span class="comment">//Immutable(&#123;a: 'AA', b: 'BB', c: &#123;d: 'DDDD'&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="getIn-ob-arr-default"><a href="#getIn-ob-arr-default" class="headerlink" title="getIn(ob,arr,default)"></a>getIn(ob,arr,default)</h3><ul>
<li>obj： immutable</li>
<li>key : array</li>
<li>default : 如果返回值为空则返回默认值</li>
<li>获取 immutable 对象指定的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="string">'BB'</span>, <span class="attr">c</span>: <span class="string">'CC'</span>&#125;, <span class="attr">d</span>: <span class="string">'DD'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> code1 = Immutable.getIn(obj, [<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"><span class="keyword">let</span> code2 = Immutable.getIn(obj, [<span class="string">'a'</span>, <span class="string">'c'</span>], <span class="string">'EE'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(code1); <span class="comment">//BB</span></span><br><span class="line"><span class="built_in">console</span>.log(code2); <span class="comment">//CC</span></span><br></pre></td></tr></table></figure>

<h3 id="update-obj-key-fun-parmas"><a href="#update-obj-key-fun-parmas" class="headerlink" title="update(obj,key,fun,parmas)"></a>update(obj,key,fun,parmas)</h3><ul>
<li>obj： immutable</li>
<li>key : string</li>
<li>fun : function</li>
<li>parmas：any，回调函数的参数</li>
<li>修改 immutable 对象的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//code1:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="params">x</span> =&gt;</span> x + x;</span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">a</span>: <span class="string">'AA'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> newobj = Immutable.update(obj, <span class="string">'a'</span>, fun);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//Immutable(&#123;a: 'AA'&#125;)</span></span><br><span class="line"><span class="built_in">console</span>.log(newobj); <span class="comment">// Immutable(&#123;a: 'AAAA'&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//code 2 :</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + <span class="string">' '</span> + y;</span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">a</span>: <span class="string">'hello'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> newobj = Immutable.update(obj, <span class="string">'a'</span>, add, <span class="string">'world'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//Immutable(&#123;a: 'hello'&#125;)</span></span><br><span class="line"><span class="built_in">console</span>.log(newobj); <span class="comment">//Immutable(&#123;a: 'hello world'&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="updateIn-obj-key-fun-parmas"><a href="#updateIn-obj-key-fun-parmas" class="headerlink" title="updateIn(obj,key,fun,parmas)"></a>updateIn(obj,key,fun,parmas)</h3><ul>
<li>obj： immutable</li>
<li>key : array</li>
<li>fun : function</li>
<li>parmas：any，回调函数的参数</li>
<li>深度修改 immutable 对象的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;);</span><br><span class="line"><span class="keyword">let</span> newobj = Immutable.updateIn(obj, [<span class="string">'a'</span>, <span class="string">'b'</span>], add, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);workspace</span><br><span class="line"><span class="built_in">console</span>.log(newobj); workspace</span><br></pre></td></tr></table></figure>

<h3 id="without-obj-key"><a href="#without-obj-key" class="headerlink" title="without(obj,key)"></a>without(obj,key)</h3><ul>
<li>obj： immutable</li>
<li>key : array | string |function</li>
<li>删除 immutable 对象的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//code 1:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">a</span>: <span class="string">'AA'</span>, <span class="attr">b</span>: <span class="string">'BB'</span>, <span class="attr">c</span>: <span class="string">'CC'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> obj1 = Immutable.without(obj, <span class="string">'b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// Immutable(&#123;a: 'AA', c: 'CC'&#125;)</span></span><br><span class="line"></span><br><span class="line">code <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">a</span>: <span class="string">'AA'</span>, <span class="attr">b</span>: <span class="string">'BB'</span>, <span class="attr">c</span>: <span class="string">'CC'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> obj2 = Immutable.without(obj, [<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// Immutable(&#123; c: 'CC'&#125;)</span></span><br><span class="line"></span><br><span class="line">code <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">a</span>: <span class="string">'AA'</span>, <span class="attr">b</span>: <span class="string">'BB'</span>, <span class="attr">c</span>: <span class="string">'CC'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> obj3 = Immutable.without(obj, <span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj3); <span class="comment">// Immutable(&#123; c: 'CC'&#125;)</span></span><br><span class="line"></span><br><span class="line">code <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">a</span>: <span class="string">'AA'</span>, <span class="attr">b</span>: <span class="string">'BB'</span>, <span class="attr">c</span>: <span class="string">'CC'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> obj4 = Immutable.without(obj, (value, key) =&gt; key === <span class="string">'a'</span> || value === <span class="string">'BB'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj4); <span class="comment">// Immutable(&#123; c: 'CC'&#125;)</span></span><br></pre></td></tr></table></figure>


<h3 id="asObject-obj-fun"><a href="#asObject-obj-fun" class="headerlink" title="asObject(obj,fun)"></a>asObject(obj,fun)</h3><ul>
<li>obj： immutable</li>
<li>fun : function</li>
<li>迭代器函数将返回两个元素的数组 - 第一个表示键，另一个表示值。然后返- 回由这些键和值构成的不可变对象。</li>
</ul>
<pre><code class="javascript">
<span class="comment">//code1</span>

 <span class="keyword">var</span> array = immutable([<span class="string">"hey"</span>, <span class="string">"you"</span>]);
    <span class="keyword">var</span> tempAry = immutable.asObject(array, <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>{
      <span class="keyword">return</span> [str,str]
    });
  <span class="built_in">console</span>.log(tempAry);   <span class="comment">//{hey: "hey", you: "you"}</span>

<span class="comment">//code2</span>
,
<span class="keyword">var</span> array = Immutable([<span class="string">'aa'</span>, <span class="string">'bb'</span>]);
<span class="keyword">let</span> newobj = Immutable.asObject(array, str =&gt; {
    <span class="keyword">return</span> [str, str.toUpperCase()];
});
<span class="built_in">console</span>.log(newobj); <span class="comment">//Immutable({aa: "AA", bb: "BB"})</span>
</code></pre>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
  </entry>
  <entry>
    <title>leetCode</title>
    <url>/2019/03/19/workspace/Project/leetcode/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>leetCode</strong></p>
<p>[[toc]]</p>
<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><strong>示例：</strong></p>
<pre><code>给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> obj=&#123;&#125;;</span><br><span class="line">   <span class="keyword">const</span> len=nums.length;</span><br><span class="line">   <span class="keyword">if</span>(len&lt;<span class="number">2</span>)<span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> otherNum=target-nums[i]</span><br><span class="line">      <span class="keyword">if</span>(otherNum <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> [obj[otherNum],i]</span><br><span class="line">      &#125;</span><br><span class="line">      obj[nums[i]]=i</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> diff = target - nums[i]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] === diff) &#123;</span><br><span class="line">        <span class="keyword">return</span> [i, j]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-5-8…求第一百个数"><a href="#1-2-3-5-8…求第一百个数" class="headerlink" title="1,2,3,5,8…求第一百个数"></a>1,2,3,5,8…求第一百个数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findIndexNum</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ary = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">    <span class="keyword">if</span>(ary.length&gt;=n)&#123;</span><br><span class="line">     <span class="keyword">return</span> ary[n<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(n<span class="number">-4</span>), (key, index) =&gt; index).forEach(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> len =ary.length;</span><br><span class="line">      <span class="keyword">let</span> sum = ary[len<span class="number">-2</span>]+ary[len<span class="number">-1</span>]</span><br><span class="line">      ary.push(sum)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ary[n<span class="number">-1</span>]    </span><br><span class="line">&#125;</span><br><span class="line">findIndexNum(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="求数组中连续数最大个数"><a href="#求数组中连续数最大个数" class="headerlink" title="求数组中连续数最大个数"></a>求数组中连续数最大个数</h3><pre><code>给定一个数组, 里面的元素全部由0和1组成, 计算其中最大连续1的个数

输入: [1,1,0,1,1,1]
输出: 3
解释: 开头的两位和最后的三位都是连续1, 所以最大连续1的个数是3</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBiggest</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> arg = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] !== arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      arg.push(count);</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合总和-III"><a href="#组合总和-III" class="headerlink" title="组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">组合总和 III</a></h3><p>示例 1:</p>
<p>输入: k = 3, n = 7<br>输出: [[1,2,4]]<br>示例 2:</p>
<p>输入: k = 3, n = 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]</p>
<ol>
<li>先找出来能组成的所有数组，然后在根据长度和和找出适合的数组</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> k = <span class="number">4</span>, n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> combinationSum3 = <span class="function"><span class="keyword">function</span> (<span class="params">k, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number = [[]];</span><br><span class="line">  <span class="keyword">let</span> ary = []</span><br><span class="line">  <span class="keyword">let</span> numbers = [...Array(<span class="number">9</span>)].map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> index + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> turn = number.map(<span class="function"><span class="params">v</span> =&gt;</span> [...v, numbers[i]])</span><br><span class="line">    number = number.concat(turn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; number.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (number[i].length === k) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sum(number[i]) === n) &#123;</span><br><span class="line">        ary.push(number[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ary;ary</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev + curr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(combinationSum3(k,n))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>回溯+剪纸</li>
</ol>
<p>如果当前组合数组的长度超过了题目给定的k，那么没有必要继续回溯，进行剪纸<br>由于遍历[start, 9]的过程中，我们是从小到大排序的，那么如果当前的组合总和sum加上了[start, 9]中的某个数字num后，使得sum + num &gt; n，这里假设num的下标是i，那么很明显，[i, 9]区间的数字就没有必要再遍历回溯了，因为什么组合的和都会大于n，进行剪纸。<br>于是可以写出代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> k = <span class="number">3</span>, n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ans;</span><br><span class="line"><span class="keyword">let</span> combinationSum3 = <span class="function"><span class="keyword">function</span> (<span class="params">k, n</span>) </span>&#123;</span><br><span class="line">  ans = [];</span><br><span class="line">  back(k, n, [], <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @params &#123;Array&#125; nowArr 当前回溯组合</span></span><br><span class="line"><span class="comment">* @params &#123;number&#125; sum 当前回溯组合的总和</span></span><br><span class="line"><span class="comment">* @params &#123;number&#125; start 下次回溯的起点坐标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">back</span>(<span class="params">k, n, nowArr, sum, start</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 符合双重条件</span></span><br><span class="line">  <span class="keyword">if</span> (nowArr.length === k &amp;&amp; sum === n) &#123;</span><br><span class="line">    <span class="keyword">return</span> ans.push(nowArr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归找到合适的数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum + i &gt; n || nowArr.length &gt; k) <span class="keyword">break</span>;</span><br><span class="line">    back(k, n, [...nowArr, i], sum + i, i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(combinationSum3(k, n));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Project</category>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>shell &amp; ssh</title>
    <url>/2019/03/19/workspace/Project/linux/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>shell &amp; ssh</strong></p>
<p>[[toc]]</p>
<h3 id="日常用到的Shell命令"><a href="#日常用到的Shell命令" class="headerlink" title="日常用到的Shell命令"></a>日常用到的Shell命令</h3><table>
<thead>
<tr>
<th>命令名</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>clear</td>
<td>清除屏幕或窗口内容</td>
</tr>
<tr>
<td>env</td>
<td>显示当前所有设置过的环境变量</td>
</tr>
<tr>
<td>date</td>
<td>显示系统的当前日期和时间</td>
</tr>
<tr>
<td>cal</td>
<td>显示日历</td>
</tr>
<tr>
<td>vi 修改文件</td>
<td>dd删除一行 A编辑选中的最后一行代码 ，</td>
</tr>
<tr>
<td>:set nu</td>
<td>加索引</td>
</tr>
<tr>
<td>touch</td>
<td>创建文件</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建文件夹</td>
</tr>
<tr>
<td>du -ha [文件名称]</td>
<td>查看目录/文件占用空间大小</td>
</tr>
<tr>
<td>ls -lh</td>
<td>看文件大小</td>
</tr>
<tr>
<td>ll</td>
<td>等价 ls -al</td>
</tr>
<tr>
<td>netstat -nltp</td>
<td>grep 443</td>
</tr>
<tr>
<td>mv</td>
<td>修改文件名 移动文件 mv  index.html  .bash_profile</td>
</tr>
<tr>
<td>cat</td>
<td>查看内容</td>
</tr>
<tr>
<td>sudo vim /etc/hosts</td>
<td>ws破解</td>
</tr>
<tr>
<td>ssh -p 2289 <a href="mailto:root@182.92.117.162">root@182.92.117.162</a></td>
<td>登录ssh</td>
</tr>
<tr>
<td>chattr +i .user.ini</td>
<td>重新恢复文件不可更动属性</td>
</tr>
<tr>
<td>chmod -R 777 pet_07</td>
<td>赋权限</td>
</tr>
<tr>
<td>r：可读<br/>w：可写<br/>x：可执行<br/><br/>-rw——- (600) – 只有属主有读写权限。<br/>-rw-r–r– (644) – 只有属主有读写权限；而属组用户和其他用户只有读权限。<br/>-rwx—— (700) – 只有属主有读、写、执行权限。<br/><strong>-rwxr-xr-x (755) – 属主有读、写、执行权限；别的用户组只有读、执行权限。</strong><br/>-rwx–x–x (711) – 属主有读、写、执行权限；而属组用户和其他用户只有执行权限。<br/>-rw-rw-rw- (666) – 所有用户都有文件读、写权限。这种做法不可取。<br/>-rwxrwxrwx (777) – 所有用户都有读、写、执行权限。更不可取的做法。<br/></td>
<td>参数解释</td>
</tr>
<tr>
<td>sudo chown -R $(whoami) or【你的用户名】  /Users/hzf/Desktop/projectSvelte</td>
<td>更改某个目录或文件的用户名和用户组</td>
</tr>
<tr>
<td>yarn version –new-version 1.0.0</td>
<td>更改版本号</td>
</tr>
<tr>
<td>curl <a href="http://www.jing999.cn:8000/banner" target="_blank" rel="noopener">http://www.jing999.cn:8000/banner</a></td>
<td>http命令行工具</td>
</tr>
<tr>
<td>ping <a href="http://www.jing999.cn" target="_blank" rel="noopener">www.jing999.cn</a></td>
<td>ping</td>
</tr>
<tr>
<td>kill -9 PID</td>
<td>杀死这个进程</td>
</tr>
<tr>
<td>npx browser-sync start -s . -f .</td>
<td>静态页面动态刷新</td>
</tr>
<tr>
<td>browser-sync start –server –files .</td>
<td>静态页面动态刷新</td>
</tr>
<tr>
<td>rm -rf node_modules/.cache/babel-loader</td>
<td>umi的bug</td>
</tr>
<tr>
<td>nginx -s reload</td>
<td>重启nginx</td>
</tr>
<tr>
<td>tar -czvf dist.tar.gz dist</td>
<td>dist 压缩</td>
</tr>
<tr>
<td>tar -xzvf dist.tar.gz</td>
<td>解压</td>
</tr>
<tr>
<td>-c: 建立压缩档案<br/>-x：解压<br/>-z：有gzip属性的<br/>-v：显示所有过程<br/>-r：向压缩归档文件末尾追加文件<br/>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。<br/></td>
<td>参数解释</td>
</tr>
<tr>
<td>find / -name jenkins</td>
<td>查看安装目录</td>
</tr>
<tr>
<td>find . “(“ -name “<em>.m” -or -name “</em>.mm” <br/> -or -name “<em>.jsx” -or -name “</em>.tsx” <br/> -or -name “<em>.css” -or -name “</em>.less” <br/> -or -name “<em>.scss” -or -name “</em>.js” <br/> -or -name “<em>.ts” -or -name “</em>.rss” “)” -print | xargs wc -l</td>
<td>看一共写了多少行的代码</td>
</tr>
<tr>
<td>sed -i ‘’ “s/666/777/g” config</td>
<td>修改文字 666换成777</td>
</tr>
</tbody></table>
<h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><ul>
<li>临时有效<ul>
<li>export PATH=$(pwd)/bin:$PATH</li>
</ul>
</li>
<li>软连接  /usr/local/bin/就是环境变量目录<ul>
<li>ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/</li>
</ul>
</li>
<li>用户主目录下的.bashrc 或.profile文件（推荐）<ul>
<li>export PATH=/Users/hzf/mongodb/bin:$PATH<ul>
<li>执行source ~/.bashrc, 立即生效</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h3><p><strong>批量注释</strong></p>
<p>从需要被注释的第一行开始，将光标移动到行首，</p>
<p>按下  <code>Ctrl + v</code></p>
<p>接着按下<code>方向键</code>下，一直移动到需要被注释的最后一行，</p>
<p>这时可以看到，这些需要被注释的行的行首第一个字符已经全部被选中</p>
<p>然后按下  <code>Shift + i</code>，批量插入，</p>
<p>这时光标会跳到第一行的行首，不用管，继续按下<code>Shift + 3</code>，也就是  <code>#</code>键</p>
<p>最后按下  <code>Esc</code> 键，就可以看到刚才被选中的行的行首都会加多一个<code>#</code>号</p>
<p>批量注释完毕</p>
<p><strong>去注释</strong></p>
<p>对于一大段被注释的代码，需要去掉注释的时候，也可以一次性操作完</p>
<p>不用一个一个去删，具体操作如下：</p>
<p>光标移到需要去除注释的第一行的行首，跟上面的一样，</p>
<p>按下 ·<code>Ctrl + v</code></p>
<p>接着按下<code>方向键</code>下，一直移动到需要被注释的最后一行，</p>
<p>这时候可以看到，行首的第一个字符<code>#</code>已经被选中了，</p>
<p>然后按下<code>d</code>键就可以全部删掉行首的<code>#</code>字符了。</p>
<h3 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run: sh depoly.sh 123 123</span></span><br><span class="line"><span class="comment"># 变量定义</span></span><br><span class="line">str=<span class="string">'test'</span> <span class="comment"># 注意赋值不需要空格</span></span><br><span class="line">str2=<span class="string">"this is <span class="variable">$str</span>"</span> <span class="comment"># 双引号可以直接写入变量</span></span><br><span class="line">str3=<span class="string">"this is <span class="variable">$&#123;str&#125;</span>"</span></span><br><span class="line">arr=(<span class="string">'1'</span> <span class="string">'2'</span>) <span class="comment"># 数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo打印</span></span><br><span class="line"><span class="built_in">echo</span> this is <span class="built_in">test</span> <span class="comment"># this is test # 被默认为字符串，不会报错</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> <span class="comment"># test # 变量引用需要家$符号</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str2</span> <span class="comment"># this is test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str3</span> <span class="comment"># this is test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[1]&#125;</span> <span class="comment"># 2 # 数组切割</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if判断</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$str</span> == <span class="string">"test"</span> ] <span class="comment"># if条件需要在方括号中，并且注意需要空格</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'successed'</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">'10'</span></span><br><span class="line">b=<span class="string">'20'</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a 不等于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> <span class="comment"># 123 #第一个参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span> <span class="comment"># 2 # 参数个数</span></span><br><span class="line"><span class="built_in">echo</span> $* <span class="comment"># 123 123 所有参数</span></span><br></pre></td></tr></table></figure>

<h3 id="针对jenkins总结的"><a href="#针对jenkins总结的" class="headerlink" title="针对jenkins总结的"></a>针对jenkins总结的</h3><p><code>启动jenkins</code><br/><br>java -jar jenkins.war –httpPort=8081</p>
<p><code>如果想要在linux后台一直运行，则要开始加nohup，在末尾加&amp;号</code><br/><br>nohup java -jar jenkins.war –httpPort=8081 &amp;</p>
<p>启动后 会生成一个nohup.out输出，需要的话，可以tail -f nohup.out实时查看日志</p>
<p><code>列出jenkins的所有进程</code><br/><br>ps -aux|grep jenkins</p>
<p><code>杀死这个进程</code><br/><br>kill -9 [PID]</p>
<p><code>启动jenkins的另外方式</code><br/><br>service jenkins start/stop/restart/status</p>
<p>systemctl start jenkins.service</p>
<p><code>查看运行的后台进程</code><br/><br>jobs -l<br/><br>jobs命令只看当前终端生效的，关闭终端后，在另一个终端jobs已经无法看到后台跑得程序了，此时利用ps（进程查看命令）<br/><br>ps -ef<br/><br>ps -aux|grep jenkins</p>
<p><strong>查看使用某端口的进程</strong><br/><br><code>lsof -i:3000</code> <br/><br>kill -9  [pid]</p>
<h3 id="ssh-不能登录服务器"><a href="#ssh-不能登录服务器" class="headerlink" title="ssh 不能登录服务器"></a>ssh 不能登录服务器</h3><p>提示警告信息如下：</p>
<p>arnold@WSN:~$ ssh 120.79.229.197</p>
<p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br>Someone could be eavesdropping on you right now (man-in-the-middle attack)!<br>It is also possible that the RSA host key has just been changed.<br>The fingerprint for the RSA key sent by the remote host is<br>08:98:a9:cc:f8:37:20:6b:b4:b1:6c:3a:15:b9:a9:92.<br>Please contact your system administrator.<br>Add correct host key in /home/arnold/.ssh/known_hosts to get rid of this message.<br>Offending key in /home/arnold/.ssh/known_hosts:2<br>RSA host key for 10.18.46.111 has changed and you have requested strict checking.<br>Host key verification failed.</p>
<p>原因分析：</p>
<p>It is also possible that a host key has just been changed.</p>
<p>我之前对ssh服务器重装了系统，导致所有与原系统建立过ssh连接的系统都无法再建立连接，因为在于原系统建立首次连接时，双方相互记录了对方的公钥（ssh基于非对称密钥技术），在ssh服务主机重装系统后，公钥改变了，任以旧版本公钥的主机自然是无法与新系统连接的。</p>
<p>网上还有分析为ssh主机被人黑了，并在消除入侵记录时对known_hosts文件做了改动。当然也不排除这种可能，但我估计我是没那个福气了：）</p>
<p>解决方案：</p>
<p>删除 <code>~/.ssh/known_hosts</code>文件，或者<code>如果你可以判断出known_hosts中原ssh服务器的公钥，删去那部分</code>，</p>
<p>然后后再次建立新的连接，即可获得新的公钥。</p>
<h3 id="关于sshpass使用举例"><a href="#关于sshpass使用举例" class="headerlink" title="关于sshpass使用举例"></a>关于sshpass使用举例</h3><p><code>使用-p参数指定登录密码</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 免密码登录</span><br><span class="line">$ sshpass -p password ssh username@host</span><br><span class="line"></span><br><span class="line"># 远程执行命令</span><br><span class="line">$ sshpass -p password ssh username@host &lt;cmd&gt;</span><br><span class="line"></span><br><span class="line"># 通过scp上传文件</span><br><span class="line">$ sshpass -p password scp local_file root@host:remote_file </span><br><span class="line"></span><br><span class="line"># 通过scp下载文件</span><br><span class="line">$ sshpass -p password scp root@host:remote_file local_file</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#把本地的source.txt文件拷贝到192.168.0.10机器上的&#x2F;home&#x2F;work目录下</span><br><span class="line">scp &#x2F;home&#x2F;work&#x2F;source.txt root@192.168.0.10:&#x2F;home&#x2F;work&#x2F; </span><br><span class="line"></span><br><span class="line">#把120.79.229.197机器上的hzf.gif文件拷贝到本地的&#x2F;Users&#x2F;zhenfeng&#x2F;tempData&#x2F;目录下</span><br><span class="line">scp root@120.79.229.197:&#x2F;tmp&#x2F;hzf.gif &#x2F;Users&#x2F;zhenfeng&#x2F;tempData&#x2F;  </span><br><span class="line"></span><br><span class="line">#把192.168.0.10机器上的source.txt文件拷贝到192.168.0.11机器的&#x2F;home&#x2F;work目录下</span><br><span class="line">scp root@192.168.0.10:&#x2F;home&#x2F;work&#x2F;source.txt root@192.168.0.11:&#x2F;home&#x2F;work&#x2F; </span><br><span class="line"></span><br><span class="line">#拷贝文件夹，加-r参数</span><br><span class="line">scp -r &#x2F;home&#x2F;work&#x2F;sourcedir root@192.168.0.10:&#x2F;home&#x2F;work&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env bash</span><br><span class="line">tar -czvf &#39;$1&#39; | sshpass -p password ssh root@host &#39;cd &#x2F;home -rf;tar -xzvf -&#39;</span><br></pre></td></tr></table></figure>

<p><code>脚本用env启动的原因，是因为脚本解释器在linux中可能被安装于不同的目录，env可以在系统的PATH目录中查找。同时，env还规定一些系统环境变量。</code></p>
]]></content>
      <categories>
        <category>Project</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>base64上传七云获取key</title>
    <url>/2019/03/19/workspace/Project/qiyunniu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>base64上传七云获取key</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上传到七云牛 base64 转化为 key(原生的ajax)</span></span><br><span class="line"> putb64 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*picUrl用来存储返回来的url*/</span></span><br><span class="line">        <span class="keyword">let</span> picBase = base64图片;</span><br><span class="line">        <span class="comment">/*把头部的data:image/png;base64,去掉。（注意：base64后面的逗号也去掉）*/</span></span><br><span class="line">        picBase = picBase.substring(<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*通过base64编码字符流计算文件流大小函数*/</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fileSize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> fileSize,</span><br><span class="line">                indexOf = str.indexOf(<span class="string">'='</span>);</span><br><span class="line">            <span class="keyword">if</span> (indexOf &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                str = str.substring(<span class="number">0</span>, indexOf);<span class="comment">//把末尾的’=‘号去掉</span></span><br><span class="line">            &#125;</span><br><span class="line">            fileSize = <span class="built_in">parseInt</span>(str.length - (str.length / <span class="number">8</span>) * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> fileSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//https://upload-z2.qiniu.com/putb64/ 只适用于七牛云华南空间</span></span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`https://upload-z2.qiniup.com/putb64/<span class="subst">$&#123;fileSize(picBase)&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> keyText = xhr.responseText;</span><br><span class="line">                <span class="built_in">console</span>.log(keyText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</span><br><span class="line">        xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>);</span><br><span class="line">        xhr.setRequestHeader(<span class="string">"Authorization"</span>, <span class="string">`UpToken <span class="subst">$&#123;<span class="keyword">this</span>.state.uptoken&#125;</span>`</span>);</span><br><span class="line">        xhr.send(picBase);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Project</category>
        <category>base64上传七云获取key</category>
      </categories>
  </entry>
  <entry>
    <title>用到的方法</title>
    <url>/2019/03/19/workspace/Project/method/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>用到的方法</strong></p>
<p>[[toc]]</p>
<h3 id="获取给定范围的随机数"><a href="#获取给定范围的随机数" class="headerlink" title="获取给定范围的随机数"></a>获取给定范围的随机数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span>  getRand= <span class="function">(<span class="params">min, max</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * range + min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="吸顶"><a href="#吸顶" class="headerlink" title="吸顶"></a>吸顶</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//titleFixed是className的名字</span></span><br><span class="line"><span class="keyword">let</span> offsetTop =[dom].getBoundingClientRect().top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (offsetTop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.titleFixed = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.titleFixed = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改成三元</span></span><br><span class="line">(offsetTop &lt; <span class="number">0</span>) ? <span class="keyword">this</span>. titleFixed = <span class="literal">true</span> : <span class="keyword">this</span>. titleFixed = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//我们发现条件块里面的赋值情况是布尔值，所以可以更简单</span></span><br><span class="line"><span class="keyword">this</span>. titleFixed = offsetTop &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原生js获取到顶部-左侧的距离</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOffset</span>(<span class="params">obj, direction</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> offsetL = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">let</span> offsetT = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>( obj !== <span class="built_in">window</span>. document.body &amp;&amp; obj !== <span class="literal">null</span> )&#123;</span><br><span class="line">		offsetL += obj.offsetLeft;</span><br><span class="line">		offsetT += obj.offsetTop;</span><br><span class="line">		obj = obj.offsetParent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(direction === <span class="string">'left'</span>)&#123;</span><br><span class="line">	    <span class="keyword">return</span> offsetL;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	   <span class="keyword">return</span> offsetT</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串去空"><a href="#字符串去空" class="headerlink" title="字符串去空"></a>字符串去空</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去空 默认是两边的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>str 需要进行去空格的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>is_global 是否全部去除空格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> trim = <span class="function">(<span class="params">str, is_global</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    result = str.replace(<span class="regexp">/(^\s+)|(\s+$)/g</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (is_global.toLowerCase() === <span class="string">"g"</span>) &#123;</span><br><span class="line">        result = result.replace(<span class="regexp">/\s/g</span>, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="经常用到的一些小正则"><a href="#经常用到的一些小正则" class="headerlink" title="经常用到的一些小正则"></a>经常用到的一些小正则</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配8-16位数字和字母密码的正则表达式</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;8,16&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配身份证号码</span></span><br><span class="line"><span class="keyword">let</span> reg=<span class="regexp">/(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配中文</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[\u4e00-\u9fa5]*$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配手机号</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^1\d&#123;10&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配括号里面的文字 </span></span><br><span class="line"><span class="keyword">let</span> reg =<span class="regexp">/\(([^)]*)\)/g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配千分位</span></span><br><span class="line"><span class="keyword">let</span> reg =<span class="regexp">/^(-)?\d&#123;1,3&#125;(,\d&#123;3&#125;)*(.\d+)?$/</span></span><br></pre></td></tr></table></figure>

<h3 id="单击和双击同时存在"><a href="#单击和双击同时存在" class="headerlink" title="单击和双击同时存在"></a>单击和双击同时存在</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> dbJumpHome = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.clickTimer) &#123;</span><br><span class="line">        <span class="built_in">window</span>.clearTimeout(<span class="keyword">this</span>.clickTimer);</span><br><span class="line">        <span class="keyword">this</span>.clickTimer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jumpTo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.clickTimer) &#123;</span><br><span class="line">        <span class="built_in">window</span>.clearTimeout(<span class="keyword">this</span>.clickTimer);</span><br><span class="line">        <span class="keyword">this</span>.clickTimer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.clickTimer = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//执行代码</span></span><br><span class="line">    &#125;, <span class="number">200</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="同时调取多个接口"><a href="#同时调取多个接口" class="headerlink" title="同时调取多个接口"></a>同时调取多个接口</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Promise 请求多个接口</span></span><br><span class="line"><span class="keyword">const</span> createSource = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([queryWxapps(scenicid()[<span class="string">'id'</span>]), queryWxapps(scenicid()[<span class="string">'id'</span>]), queryWxapps(scenicid()[<span class="string">'id'</span>])])</span><br><span class="line"><span class="built_in">console</span>.log(createSource);<span class="comment">//[&#123;&#125;,&#123;&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//axios请求多个接口</span></span><br><span class="line">axios.all([queryWxapps(scenicid()[<span class="string">'id'</span>]), queryWxapps(scenicid()[<span class="string">'id'</span>]), queryWxapps(scenicid()[<span class="string">'id'</span>]).then(axios.spread(<span class="function">(<span class="params">user, aside</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">  <span class="built_in">console</span>.log(aside);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="移动端兼容性问题"><a href="#移动端兼容性问题" class="headerlink" title="移动端兼容性问题"></a>移动端兼容性问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解决ios键盘弹起取消后留空白的现象</span></span><br><span class="line">;<span class="function">(<span class="params"><span class="regexp">/iphone|ipod|ipad/i</span>.test(navigator.appVersion</span>)) &amp;&amp; <span class="params">document</span>.<span class="params">addEventListener</span>(<span class="params"><span class="string">'blur'</span>, (e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 这里加了个类型判断，因为a等元素也会触发blur事件</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  [<span class="string">'input'</span>, <span class="string">'textarea'</span>].includes(e.target.localName)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// document.body.scrollIntoViewIfNeeded();</span></span><br><span class="line">  <span class="comment">// document.activeElement.scrollIntoViewIfNeeded();</span></span><br><span class="line">  <span class="built_in">document</span>.body.scrollIntoView(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取滚动条的高度"><a href="#获取滚动条的高度" class="headerlink" title="获取滚动条的高度"></a>获取滚动条的高度</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ScollPostion</span>(<span class="params"></span>) </span>&#123;<span class="comment">//滚动条位置</span></span><br><span class="line"><span class="keyword">let</span> t, l, w, h;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.documentElement &amp;&amp; <span class="built_in">document</span>.documentElement.scrollTop) &#123;</span><br><span class="line">        t = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">        l = <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line">        w = <span class="built_in">document</span>.documentElement.scrollWidth;</span><br><span class="line">        h = <span class="built_in">document</span>.documentElement.scrollHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.body) &#123;</span><br><span class="line">        t = <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">        l = <span class="built_in">document</span>.body.scrollLeft;</span><br><span class="line">        w = <span class="built_in">document</span>.body.scrollWidth;</span><br><span class="line">        h = <span class="built_in">document</span>.body.scrollHeight;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="attr">top</span>: t, <span class="attr">left</span>: l, <span class="attr">width</span>: w, <span class="attr">height</span>: h &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.pageYOffset == <span class="built_in">window</span>.scrollY; <span class="comment">// 总是返回 true</span></span><br><span class="line"><span class="keyword">var</span> supportPageOffset = <span class="built_in">window</span>.pageXOffset !== <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// document.compatMode;　　//可以用来判断是否声明了DTD; 值为"BackCompat"：未声明DTD;    值为"CSS1Compat"：已声明DTD;</span></span><br><span class="line"><span class="keyword">var</span> isCSS1Compat = ((<span class="built_in">document</span>.compatMode || <span class="string">""</span>) === <span class="string">"CSS1Compat"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = supportPageOffset ? <span class="built_in">window</span>.pageXOffset : isCSS1Compat ? <span class="built_in">document</span>.documentElement.scrollLeft : <span class="built_in">document</span>.body.scrollLeft;</span><br><span class="line"><span class="keyword">var</span> y = supportPageOffset ? <span class="built_in">window</span>.pageYOffset : isCSS1Compat ? <span class="built_in">document</span>.documentElement.scrollTop : <span class="built_in">document</span>.body.scrollTop;</span><br></pre></td></tr></table></figure>

<h3 id="URL的编码解码"><a href="#URL的编码解码" class="headerlink" title="URL的编码解码"></a>URL的编码解码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="comment">//;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号,会被十六进制的转义序列替换</span></span><br><span class="line"><span class="built_in">encodeURIComponent</span>(URIstring)</span><br><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">",/?:@&amp;=+$#"</span>)<span class="comment">//%2C%2F%3F%3A%40%26%3D%2B%24%23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="built_in">decodeURIComponent</span>(URIstring)</span><br><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="string">"%2C%2F%3F%3A%40%26%3D%2B%24%23"</span>)<span class="comment">//,/?:@&amp;=+$#</span></span><br></pre></td></tr></table></figure>

<h3 id="获取图片的原始尺寸"><a href="#获取图片的原始尺寸" class="headerlink" title="获取图片的原始尺寸"></a>获取图片的原始尺寸</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImgNaturalDimensions</span>(<span class="params">oImg, callback</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> nWidth, nHeight;</span><br><span class="line">　　<span class="keyword">if</span> (!oImg.naturalWidth) &#123; <span class="comment">// 现代浏览器</span></span><br><span class="line"></span><br><span class="line">　　　　nWidth = oImg.naturalWidth;</span><br><span class="line">　　　　nHeight = oImg.naturalHeight;</span><br><span class="line">　　　　callback(&#123;<span class="attr">w</span>: nWidth, <span class="attr">h</span>:nHeight&#125;);</span><br><span class="line"></span><br><span class="line">　　&#125; <span class="keyword">else</span> &#123; <span class="comment">// IE6/7/8</span></span><br><span class="line">　　　　<span class="keyword">var</span> nImg = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">        nImg.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="keyword">var</span> nWidth = nImg.width,</span><br><span class="line">                 nHeight = nImg.height;</span><br><span class="line">           callback(&#123;<span class="attr">w</span>: nWidth, <span class="attr">h</span>:nHeight&#125;);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　nImg.src = oImg.src;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">"oImg"</span>);</span><br><span class="line">getImgNaturalDimensions(img, <span class="function"><span class="keyword">function</span>(<span class="params">dimensions</span>)</span>&#123;</span><br><span class="line">　　<span class="built_in">console</span>.log(dimensions.w);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Project</category>
        <category>Methods</category>
      </categories>
  </entry>
  <entry>
    <title>会用到的插件</title>
    <url>/2019/03/19/workspace/Project/more/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>会用到的插件</strong></p>
<ul>
<li><p><a href="https://github.com/daneden/animate.css" target="_blank" rel="noopener">animate.css</a></p>
</li>
<li><p><a href="https://github.com/buildo/react-placeholder" target="_blank" rel="noopener">骨架屏</a></p>
</li>
<li><p><a href="https://github.com/dwqs/blog/issues/72" target="_blank" rel="noopener">react-virtualized</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html" target="_blank" rel="noopener">indexedDB</a></p>
</li>
<li><p><a href="http://graphql.cn/learn/" target="_blank" rel="noopener">GraphQL</a></p>
</li>
<li><p>移动端滚动</p>
<ul>
<li><a href="https://github.com/ustbhuangyi/better-scroll" target="_blank" rel="noopener">better-scroll</a>强大</li>
<li><a href="https://github.com/yiminghe/zscroller" target="_blank" rel="noopener">zscroller</a> antm内置的</li>
<li><a href="https://zynga.github.io/scroller" target="_blank" rel="noopener">scroller</a> zscroller就是基于这个</li>
</ul>
</li>
<li><p><a href="https://tylermcginnis.com/react-higher-order-components/" target="_blank" rel="noopener">高阶函数</a></p>
</li>
<li><p><a href="https://juejin.im/post/5c1a506d5188253ff1477d6f?utm_source=gold_browser_extension" target="_blank" rel="noopener">webpack</a></p>
</li>
<li><p><a href="http://www.typescriptlang.org/play/index.html" target="_blank" rel="noopener">typescript</a></p>
</li>
<li><p><a href="https://github.com/Tencent/vConsole/blob/dev/README_CN.md" target="_blank" rel="noopener">vConsole</a> 它是微信团队开源的一个轻量、可拓展、针对手机网页的前端开发者调试面板，</p>
<ul>
<li>主要操作可以查看官方<a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">文档</a>,它有一下特性：</li>
<li>查看console日志</li>
<li>查看网络请求</li>
<li>查看element结构</li>
<li>查看Cookies和localStorage</li>
<li>手动执行JS命令行</li>
<li>自定义插件</li>
</ul>
</li>
<li><p><a href="https://github.com/dimsemenov/PhotoSwipe" target="_blank" rel="noopener">移动端查看大图</a></p>
</li>
<li><p><a href="http://fengyuanchen.github.io/cropper/" target="_blank" rel="noopener">cropper组件，用于图片上传裁剪</a></p>
</li>
<li><p><a href="https://github.com/jamiebuilds/react-loadable?utm_source=gold_browser_extension" target="_blank" rel="noopener">react-loadable</a>-主要实现异步加载（也可以预加载）</p>
</li>
<li><p><a href="https://www.cnblogs.com/alan2kat/p/7754846.html" target="_blank" rel="noopener">React-Router4 按需加载的4种实现</a></p>
</li>
<li><p><a href="https://eggjs.org/zh-cn/tutorials/typescript.html" target="_blank" rel="noopener">egg后台应用框架</a></p>
</li>
<li><p><a href="https://koa.bootcss.com/" target="_blank" rel="noopener">koa</a></p>
</li>
<li><p><a href="http://mongoosejs.net/docs/schematypes.html" target="_blank" rel="noopener">mongoosejs</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
  </entry>
  <entry>
    <title>全屏实现方案</title>
    <url>/2019/03/19/workspace/Project/screenfull/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>全屏实现方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;button onclick=<span class="string">"fullScreen()"</span>&gt;现代浏览器全屏&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        &lt;button onclick="exitScreen()"&gt;现代浏览器退出&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onclick=<span class="string">"iefull()"</span>&gt;低版本ie全屏&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="comment">//全屏</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fullScreen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> el = <span class="built_in">document</span>.documentElement;</span><br><span class="line">            <span class="keyword">var</span> rfs = el.requestFullScreen || el.webkitRequestFullScreen || el.mozRequestFullScreen || el.msRequestFullscreen;      </span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">typeof</span> rfs != <span class="string">"undefined"</span> &amp;&amp; rfs) &#123;</span><br><span class="line">                    rfs.call(el);</span><br><span class="line">                &#125;;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出全屏</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">exitScreen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">document</span>.exitFullscreen) &#123;  </span><br><span class="line">                <span class="built_in">document</span>.exitFullscreen();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.mozCancelFullScreen) &#123;  </span><br><span class="line">                <span class="built_in">document</span>.mozCancelFullScreen();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.webkitCancelFullScreen) &#123;  </span><br><span class="line">                <span class="built_in">document</span>.webkitCancelFullScreen();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.msExitFullscreen) &#123;  </span><br><span class="line">                <span class="built_in">document</span>.msExitFullscreen();  </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> cfs != <span class="string">"undefined"</span> &amp;&amp; cfs) &#123;</span><br><span class="line">                cfs.call(el);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ie低版本的全屏，退出全屏都这个方法</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">iefull</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> el = <span class="built_in">document</span>.documentElement;</span><br><span class="line">            <span class="keyword">var</span> rfs =  el.msRequestFullScreen;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">window</span>.ActiveXObject != <span class="string">"undefined"</span>) &#123;</span><br><span class="line">                <span class="comment">//这的方法 模拟f11键，使浏览器全屏</span></span><br><span class="line">                <span class="keyword">var</span> wscript = <span class="keyword">new</span> ActiveXObject(<span class="string">"WScript.Shell"</span>);</span><br><span class="line">                <span class="keyword">if</span>(wscript != <span class="literal">null</span>) &#123;</span><br><span class="line">                    wscript.SendKeys(<span class="string">"&#123;F11&#125;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注：ie调用ActiveX控件，需要在ie浏览器安全设置里面把 ‘未标记为可安全执行脚本的ActiveX控件初始化并执行脚本’ 设置为启用</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Project</category>
        <category>全屏实现方案</category>
      </categories>
  </entry>
  <entry>
    <title>toFixed方法的bug</title>
    <url>/2019/03/19/workspace/Project/toFixed/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>toFixed方法的bug</strong></p>
<p>最近在工作过程中碰到一个隐藏的bug，经调试发现竟然是toFixed函数不可靠的结果引起的。在处理价格比较的时候，用foFixed进行价格的四舍五入之后，竟然发现比较的结果有问题；<br>大家都知道，Number类型的变量有个toFixed方法，该方法将Number四舍五入为指定小数位数的数字，以<code>字符串</code>返回。</p>
<p><strong>IE</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.6</span> .toFixed(<span class="number">0</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="number">1.6</span> .toFixed(<span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">( <span class="number">0.035</span> ).toFixed( <span class="number">2</span> ); <span class="comment">// 0.04</span></span><br><span class="line">( <span class="number">0.045</span> ).toFixed( <span class="number">2</span> ); <span class="comment">// 0.05</span></span><br></pre></td></tr></table></figure>

<p><strong>Chrome</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.6</span> .toFixed(<span class="number">0</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="number">1.6</span> .toFixed(<span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">( <span class="number">0.035</span> ).toFixed( <span class="number">2</span> ); <span class="comment">// 0.04</span></span><br><span class="line">( <span class="number">0.045</span> ).toFixed( <span class="number">2</span> ); <span class="comment">// 0.04</span></span><br></pre></td></tr></table></figure>

<p>结论 ：<strong>toFixed()函数靠不住，如果有需要精确控制的情况，特别是<code>金钱</code>的计算时，还是自己写个方法比较好。</strong> 比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保留两位小数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>val 需要进行操作的数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> returnFloat = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">Math</span>.round(<span class="built_in">parseFloat</span>(val) * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">let</span> xsd = value.toString().split(<span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">if</span> (xsd.length === <span class="number">1</span>) &#123;</span><br><span class="line">        value = value.toString() + <span class="string">".00"</span>;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (xsd.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xsd[<span class="number">1</span>].length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            value = value.toString() + <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Project</category>
        <category>toFixed方法的bug</category>
      </categories>
  </entry>
  <entry>
    <title>yarn &amp; npm</title>
    <url>/2019/03/19/workspace/Project/yarn/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>yarn &amp; npm</strong></p>
<p>[[toc]]</p>
<h3 id="node升级"><a href="#node升级" class="headerlink" title="node升级"></a>node升级</h3><pre><code>1、window系统升级node就只有到node官网下载window安装包来覆盖之前的node
2、mac升级node版本
   npm i -g n 
   n 12.9.1 //指定版本升级
   n latest //安装最新版本
   n stable //安装最稳定的版本</code></pre><h3 id="升级包"><a href="#升级包" class="headerlink" title="升级包"></a>升级包</h3><p><code>1</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check    <span class="comment">//安装全局的包</span></span><br><span class="line">npm update &lt;name&gt; -g        <span class="comment">//全部安装不建议用</span></span><br><span class="line">npm update &lt;name&gt;           <span class="comment">//单个安装</span></span><br></pre></td></tr></table></figure>

<p><code>2</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn global add npm-check-updates  <span class="comment">//安装全局的包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ncu  查看所有可以安装的包</span></span><br><span class="line">sudo ncu -u &lt;name&gt;  <span class="comment">//这个只是改变package里面的版本 不会更新包</span></span><br><span class="line"><span class="comment">//所以要sudo ncu -u &lt;name&gt; &amp;&amp; sudo yarn</span></span><br></pre></td></tr></table></figure>


<p><code>3推荐</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn upgrade-interactive --latest <span class="comment">//需要手动选择升级的依赖包，按空格键选择，a 键切换所有，i 键反选选择</span></span><br></pre></td></tr></table></figure>


<p><code>4</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn upgrade react --latest <span class="comment">//yarn upgrade 更新依赖包时yarn.lock更新但package.json不同步更新版本信息,网上说会同步更新，我试了下，未更新，具体看你们</span></span><br></pre></td></tr></table></figure>


<h3 id="yarn-切换源"><a href="#yarn-切换源" class="headerlink" title="yarn 切换源"></a>yarn 切换源</h3><pre><code>1、`查看一下当前源`
yarn config get registry
2、`切换为淘宝源`
yarn config set registry https://registry.npm.taobao.org
3、`或者切换为自带的`
yarn config set registry https://registry.yarnpkg.com</code></pre><h3 id="npm-切换源"><a href="#npm-切换源" class="headerlink" title="npm 切换源"></a>npm 切换源</h3><pre><code>1、`全局配置切换到淘宝源`
 npm config set registry https://registry.npm.taobao.org  
2、`检测是否切换到了淘宝源`
 npm info underscore</code></pre><h3 id="你必须知道的yarn"><a href="#你必须知道的yarn" class="headerlink" title="你必须知道的yarn"></a>你必须知道的yarn</h3><p><a href="https://code.fb.com/web/yarn-a-new-package-manager-for-javascript/" target="_blank" rel="noopener">yarn的起源</a>已经解释了为什么要创建一个新的javascript包管理器，这里笔者也推荐大家从npm切换为yarn。npm4就不说了，速度太慢了，npm5借鉴了很多yarn的机制，比如简单的版本锁、重写cache模块等，减少了与yarn的差距。但依然有些地方做的不如yarn,<a href="https://jobs.stratsys.com/blog/posts/9244-npm5-vs-yarn-which-one-is-better" target="_blank" rel="noopener">这篇文章</a>记录了npm5和yarn的实验对比，结论是：在没有缓存时，yarn和npm5速度差不多；在有缓存时，yarn比npm5快2倍。</p>
<h4 id="yarn优势"><a href="#yarn优势" class="headerlink" title="yarn优势"></a>yarn优势</h4><p>以下针对npm5前:</p>
<ul>
<li><code>yarn 离线安装。</code><br>下载的时候 Yarn 缓存了所有的包以至于不需要再次从网络下载</li>
<li><code>yarn并行下载，使得时间更快。</code><br>通过并行操作最大限度地提高资源利用率，以至于再次下载的时候安装时间比之前更快。npm5之前是等上一个安装完后再执行下一个，串行下载。</li>
<li><code>yarn锁包yarn-lock，保证引用包正确。</code><br>yarn.lock 文件准确的锁定了所有被下载和项目依赖的包版本。通过这个文件，你能确定你的工程师团队的每一位成员都能安装准确的包，并且可以更容易的部署，而没有意外 bug出现。</li>
</ul>
<h4 id="yarn指令"><a href="#yarn指令" class="headerlink" title="yarn指令"></a>yarn指令</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">* <span class="string">`yarn bin`</span>, 打印出执行脚本的位置，可以被yarn run执行。相当于npm bin</span><br><span class="line">* <span class="string">`yarn login/yarn publish`</span> npm登录和发布。相当于npm login/npm publish</span><br><span class="line">* <span class="string">`yarn cache clean`</span>，清除缓存，相当于npm cache clean。</span><br><span class="line">* <span class="string">`yarn list`</span> 列出当前所有依赖的包</span><br><span class="line">* <span class="string">`yarn config list`</span> 显示所有配置设置</span><br></pre></td></tr></table></figure>

<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://auth0.com/blog/five-things-you-can-do-with-yarn/" target="_blank" rel="noopener">5 things you can do with Yarn</a></li>
<li><a href="https://yarnpkg.com/en/docs/cli/" target="_blank" rel="noopener">Yarn - CLI Introduction</a></li>
<li><a href="https://mp.weixin.qq.com/s/XdOPPay8fpNBiH2ExW_EyQ" target="_blank" rel="noopener">Node.js 中的依赖管理</a></li>
</ul>
]]></content>
      <categories>
        <category>Project</category>
        <category>Yarn</category>
      </categories>
  </entry>
  <entry>
    <title>云服务器配置</title>
    <url>/2019/09/15/workspace/Server/lnmp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>云服务器配置</strong></p>
<p>[[toc]]</p>
<h3 id="装机"><a href="#装机" class="headerlink" title="装机"></a>装机</h3><p><a href="https://lnmp.org/faq/lnmp-vhost-add-howto.html" target="_blank" rel="noopener">LNMP文档</a></p>
<h3 id="添加、删除虚拟主机使用教程"><a href="#添加、删除虚拟主机使用教程" class="headerlink" title="添加、删除虚拟主机使用教程"></a>添加、删除虚拟主机使用教程</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加</span></span><br><span class="line"><span class="comment"># 如果输入有错误需要删除时，可以按住Ctrl再按Backspace键进行删除。</span></span><br><span class="line"><span class="attribute">lnmp</span> vhost add </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">nmp vhost list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除网站会先列出当前已有虚拟主机，按提示输入要删除的虚拟主机域名 回车确认。</span></span><br><span class="line"><span class="comment"># 这里只是删除虚拟主机配置文件，网站文件并不会删除需要自己删除。</span></span><br><span class="line">lnmp vhost del</span><br></pre></td></tr></table></figure>



<h4 id="LNMP相关软件安装目录"><a href="#LNMP相关软件安装目录" class="headerlink" title="LNMP相关软件安装目录"></a>LNMP相关软件安装目录</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Nginx 目录</span></span><br><span class="line">/usr/local/nginx/</span><br><span class="line"><span class="comment"># 默认网站目录 : 0.9版本为 </span></span><br><span class="line">/home/wwwroot/</span><br><span class="line"><span class="comment">#1.0及以后版本为 </span></span><br><span class="line">/home/wwwroot/default/</span><br><span class="line"><span class="comment"># Nginx日志目录</span></span><br><span class="line">/home/wwwlogs/</span><br></pre></td></tr></table></figure>

<h4 id="LNMP相关配置文件位置"><a href="#LNMP相关配置文件位置" class="headerlink" title="LNMP相关配置文件位置"></a>LNMP相关配置文件位置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Nginx主配置(默认虚拟主机)文件</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line"># 虚拟主机配置文件</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;vhost&#x2F;域名.conf</span><br><span class="line"># MySQL配置文件</span><br><span class="line">&#x2F;etc&#x2F;my.cnf</span><br></pre></td></tr></table></figure>
<h3 id="修改linux-root-后面的别名"><a href="#修改linux-root-后面的别名" class="headerlink" title="修改linux root@后面的别名"></a>修改linux root@后面的别名</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vi</span> /etc/hostname  <span class="comment"># 重启服务器</span></span><br></pre></td></tr></table></figure>

<h3 id="Operation-Not-Permitted-错误问题"><a href="#Operation-Not-Permitted-错误问题" class="headerlink" title="Operation Not Permitted 错误问题"></a>Operation Not Permitted 错误问题</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">chattr</span> -i [name]</span><br><span class="line">rm -rf [name]</span><br></pre></td></tr></table></figure>

<h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">yum</span> install -y node </span><br><span class="line">node -v  <span class="comment"># v6.17.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本升级</span></span><br><span class="line">npm i -g n</span><br><span class="line">rm -rf /usr/bin/node</span><br><span class="line">n stable  <span class="comment"># 最稳定的版本</span></span><br><span class="line">ln -s /usr/local/bin/node /usr/bin/node</span><br><span class="line">node -v  <span class="comment"># v12.14.0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Server</category>
      </categories>
  </entry>
  <entry>
    <title>Object vs object vs {}</title>
    <url>/2019/06/11/workspace/Typescript/ts-object-type-interface/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Object vs object vs {}</strong></p>
<p>[[toc]]</p>
<p>TypeScript 2.2 引入了被称为 <code>object</code> 类型的新类型，它用于表示非原始类型。在 JavaScript 中以下类型被视为原始类型：<code>string</code>、<code>boolean</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>、<code>null</code> 和 <code>undefined</code>。</p>
<p>所有其他类型均被视为非基本类型。新的 <code>object</code> 类型表示如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// All primitive types</span></span><br><span class="line">type Primitive = string </span><br><span class="line"> | boolean | number </span><br><span class="line"> | bigint | symbol </span><br><span class="line"> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All non-primitive types</span></span><br><span class="line">type NonPrimitive = object;</span><br></pre></td></tr></table></figure>

<p>让我们看看 <code>object</code> 类型，如何让我们编写更精确的类型声明。</p>
<h3 id="一、使用-object-类型进行类型声明"><a href="#一、使用-object-类型进行类型声明" class="headerlink" title="一、使用 object 类型进行类型声明"></a>一、使用 object 类型进行类型声明</h3><p>随着 TypeScript 2.2 的发布，标准库的类型声明已经更新，以使用新的对象类型。例如，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener"><code>Object.create()</code></a> 和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener"><code>Object.setPrototypeOf()</code></a> 方法，现在需要为它们的原型参数指定 <code>object | null</code> 类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node_modules/typescript/lib/lib.es5.d.ts</span></span><br><span class="line">interface ObjectConstructor &#123;</span><br><span class="line">  create(o: object | <span class="literal">null</span>): any;</span><br><span class="line">  setPrototypeOf(o: any, <span class="attr">proto</span>: object | <span class="literal">null</span>): any;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将原始类型作为原型传递给 <code>Object.setPrototypeOf()</code> 或 <code>Object.create()</code> 将导致在运行时抛出类型错误。TypeScript 现在能够捕获这些错误，并在编译时提示相应的错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.create(proto);     <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>);      <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="number">1337</span>);      <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">true</span>);      <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="string">"oops"</span>);    <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p><code>object</code> 类型的另一个用例是作为 ES2015 的一部分引入的 WeakMap 数据结构。它的键必须是对象，不能是原始值。这个要求现在反映在类型定义中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface <span class="built_in">WeakMap</span>&lt;K extends object, V&gt; &#123;</span><br><span class="line">  <span class="keyword">delete</span>(key: K): boolean;</span><br><span class="line">  <span class="keyword">get</span>(key: K): V | undefined;</span><br><span class="line">  has(key: K): boolean;</span><br><span class="line">  <span class="keyword">set</span>(key: K, value: V): this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、Object-vs-object-vs"><a href="#二、Object-vs-object-vs" class="headerlink" title="二、Object vs object vs {}"></a>二、Object vs object vs {}</h3><p>也许令人困惑的是，TypeScript 定义了几个类型，它们有相似的名字，但是代表不同的概念：</p>
<ul>
<li><code>object</code></li>
<li><code>Object</code></li>
<li><code>{}</code></li>
</ul>
<p>我们已经看到了上面的新对象类型。现在让我们讨论 <code>Object</code> 和 <code>{}</code> 表示什么。</p>
<h4 id="2-1-Object-类型"><a href="#2-1-Object-类型" class="headerlink" title="2.1 Object 类型"></a>2.1 Object 类型</h4><p>TypeScript 定义了另一个与新的 <code>object</code> 类型几乎同名的类型，那就是 <code>Object</code> 类型。该类型是所有 Object 类的实例的类型。它由以下两个接口来定义：</p>
<ul>
<li>Object 接口定义了 Object.prototype 原型对象上的属性；</li>
<li>ObjectConstructor 接口定义了 Object 类的属性。</li>
</ul>
<p>下面我们来看一下上述两个接口的相关定义：</p>
<p>1、<code>Object</code> 接口定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node_modules/typescript/lib/lib.es5.d.ts</span></span><br><span class="line"></span><br><span class="line">interface <span class="built_in">Object</span> &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Function;</span><br><span class="line">  toString(): string;</span><br><span class="line">  toLocaleString(): string;</span><br><span class="line">  valueOf(): Object;</span><br><span class="line">  hasOwnProperty(v: PropertyKey): boolean;</span><br><span class="line">  isPrototypeOf(v: Object): boolean;</span><br><span class="line">  propertyIsEnumerable(v: PropertyKey): boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<code>ObjectConstructor</code> 接口定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node_modules/typescript/lib/lib.es5.d.ts</span></span><br><span class="line"></span><br><span class="line">interface ObjectConstructor &#123;</span><br><span class="line">  <span class="comment">/** Invocation via `new` */</span></span><br><span class="line">  <span class="keyword">new</span>(value?: any): <span class="built_in">Object</span>;</span><br><span class="line">  <span class="comment">/** Invocation via function calls */</span></span><br><span class="line">  (value?: any): any;</span><br><span class="line"></span><br><span class="line">  readonly prototype: <span class="built_in">Object</span>;</span><br><span class="line"></span><br><span class="line">  getPrototypeOf(o: any): any;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="keyword">var</span> <span class="built_in">Object</span>: ObjectConstructor;</span><br></pre></td></tr></table></figure>

<p>Object 类的所有实例都继承了 Object 接口中的所有属性。我们可以看到，如果我们创建一个返回其参数的函数：</p>
<p>传入一个 Object 对象的实例，它总是会满足该函数的返回类型 —— 即要求返回值包含一个 toString() 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object: Provides functionality common to all JavaScript objects.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: Object</span>): </span>&#123; toString(): string &#125; &#123;</span><br><span class="line">  <span class="keyword">return</span> x; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>object</code> 类型，它用于表示非原始类型（undefined, null, boolean, number, bigint, string, symbol）。使用这种类型，我们不能访问值的任何属性。</p>
<h4 id="2-2-Object-vs-object"><a href="#2-2-Object-vs-object" class="headerlink" title="2.2 Object vs object"></a>2.2 Object vs object</h4><p>有趣的是，类型 <code>Object</code> 包括原始值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">x: Object</span>) </span>&#123; &#125;</span><br><span class="line">func1(<span class="string">'semlinker'</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>为什么？</p>
<p><code>Object.prototype</code> 的属性也可以通过原始值访问：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'semlinker'</span>.hasOwnProperty === <span class="built_in">Object</span>.prototype.hasOwnProperty</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>感兴趣的读者，可以自行了解一下 “JavaScript 装箱和拆箱” 的相关内容。</p>
</blockquote>
<p>相反，<code>object</code> 类型不包括原始值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params">x: object</span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Argument of type '"semlinker"' </span></span><br><span class="line"><span class="comment">// is not assignable to parameter of type 'object'.(2345)</span></span><br><span class="line">func2(<span class="string">'semlinker'</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，当对 Object 类型的变量进行赋值时，如果值对象属性名与 Object 接口中的属性冲突，则 TypeScript 编译器会提示相应的错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Type '() =&gt; number' is not assignable to type </span></span><br><span class="line"><span class="comment">// '() =&gt; string'.</span></span><br><span class="line"><span class="comment">// Type 'number' is not assignable to type 'string'.</span></span><br><span class="line"><span class="keyword">const</span> obj1: <span class="built_in">Object</span> = &#123; </span><br><span class="line">   toString() &#123; <span class="keyword">return</span> <span class="number">123</span> &#125; <span class="comment">// Error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而对于 object 类型来说，TypeScript 编译器不会提示任何错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2: object = &#123; </span><br><span class="line">  toString() &#123; <span class="keyword">return</span> <span class="number">123</span> &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外在处理 object 类型和字符串索引对象类型的赋值操作时，也要特别注意。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strictTypeHeaders: &#123; [key: string]: string &#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> header: object = &#123;&#125;;</span><br><span class="line">header = strictTypeHeaders; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Type 'object' is not assignable to type '&#123; [key: string]: string; &#125;'.</span></span><br><span class="line">strictTypeHeaders = header; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>在上述例子中，最后一行会出现编译错误，这是因为 <code>{ [key: string]: string }</code> 类型相比 <code>object</code> 类型更加精确。而 <code>header = strictTypeHeaders;</code> 这一行却没有提示任何错误，是因为这两种类型都是非基本类型，<code>object</code> 类型比 <code>{ [key: string]: string }</code> 类型更加通用。</p>
<h4 id="2-3-空类型"><a href="#2-3-空类型" class="headerlink" title="2.3 空类型 {}"></a>2.3 空类型 {}</h4><p>还有另一种类型与之非常相似，即空类型：<code>{}</code>。它描述了一个没有成员的对象。当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译时错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Type &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Property 'prop' does not exist on type '&#123;&#125;'.</span></span><br><span class="line">obj.prop = <span class="string">"semlinker"</span>;</span><br></pre></td></tr></table></figure>

<p>但是，你仍然可以使用在 Object 类型上定义的所有属性和方法，这些属性和方法可通过 JavaScript 的原型链隐式地使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Type &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "[object Object]"</span></span><br><span class="line">obj.toString();</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中创建一个表示二维坐标点的对象很简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pt = &#123;&#125;; </span><br><span class="line">pt.x = <span class="number">3</span>; </span><br><span class="line">pt.y = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>然而以上代码在 TypeScript 中，每个赋值语句都会产生错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pt = &#123;&#125;; <span class="comment">// (A)</span></span><br><span class="line"><span class="comment">// Property 'x' does not exist on type '&#123;&#125;'</span></span><br><span class="line">pt.x = <span class="number">3</span>; <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// Property 'y' does not exist on type '&#123;&#125;'</span></span><br><span class="line">pt.y = <span class="number">4</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>这是因为第 A 行中的 pt 类型是根据它的值 {} 推断出来的，你只可以对已知的属性赋值。这个问题怎么解决呢？有些读者可能会先想到接口，比如这样子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  x: number;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type '&#123;&#125;' is missing the following </span></span><br><span class="line"><span class="comment">// properties from type 'Point': x, y(2739)</span></span><br><span class="line"><span class="keyword">const</span> pt: Point = &#123;&#125;; <span class="comment">// Error</span></span><br><span class="line">pt.x = <span class="number">3</span>;</span><br><span class="line">pt.y = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>很可惜对于以上的方案，TypeScript 编译器仍会提示错误。那么这个问题该如何解决呢？其实我们可以直接通过对象字面量进行赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pt = &#123; </span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">  y: <span class="number">4</span>, </span><br><span class="line">&#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>而如果你需要一步一步地创建对象，你可以使用类型断言（as）来消除 TypeScript 的类型检查：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pt = &#123;&#125; <span class="keyword">as</span> Point; </span><br><span class="line">pt.x = <span class="number">3</span>;</span><br><span class="line">pt.y = <span class="number">4</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>但是更好的方法是声明变量的类型并一次性构建对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pt: Point = &#123; </span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">  y: <span class="number">4</span>, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外在使用 <code>Object.assign</code> 方法合并多个对象的时候，你可能也会遇到以下问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pt = &#123; <span class="attr">x</span>: <span class="number">666</span>, <span class="attr">y</span>: <span class="number">888</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> id = &#123; <span class="attr">name</span>: <span class="string">"semlinker"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> namedPoint = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(namedPoint, pt, id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Property 'name' does not exist on type '&#123;&#125;'.(2339)</span></span><br><span class="line">namedPoint.name; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>这时候你可以使用对象展开运算符 <code>...</code> 来解决上述问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pt = &#123; <span class="attr">x</span>: <span class="number">666</span>, <span class="attr">y</span>: <span class="number">888</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> id = &#123; <span class="attr">name</span>: <span class="string">"semlinker"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> namedPoint = &#123;...pt, ...id&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(property) name: string</span></span><br><span class="line">namedPoint.name <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure>

<h3 id="三、对象字面量类型-vs-接口类型"><a href="#三、对象字面量类型-vs-接口类型" class="headerlink" title="三、对象字面量类型 vs 接口类型"></a>三、对象字面量类型 vs 接口类型</h3><p>我们除了可以通过 Object 和 object 类型来描述对象之外，也可以通过对象的属性来描述对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object literal type</span></span><br><span class="line"><span class="keyword">let</span> obj3: &#123; <span class="attr">prop</span>: boolean &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface</span></span><br><span class="line">interface ObjectType &#123;</span><br><span class="line">  prop: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj4: ObjectType;</span><br></pre></td></tr></table></figure>

<p>在 TypeScript 中有两种定义对象类型的方法，它们非常相似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object literal type</span></span><br><span class="line">type ObjType1 = &#123;</span><br><span class="line">  a: boolean,</span><br><span class="line">  b: number;</span><br><span class="line">  c: string,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface</span></span><br><span class="line">interface ObjType2 &#123;</span><br><span class="line">  a: boolean,</span><br><span class="line">  b: number;</span><br><span class="line">  c: string,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，我们使用分号或逗号作为分隔符。尾随分隔符是允许的，也是可选的。好的，那么现在问题来了，对象字面量类型和接口类型之间有什么区别呢？下面我从以下几个方面来分析一下它们之间的区别：</p>
<h4 id="3-1-内联"><a href="#3-1-内联" class="headerlink" title="3.1 内联"></a>3.1 内联</h4><p>对象字面量类型可以内联，而接口不能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inlined object literal type:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">x: &#123; prop: number &#125;</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">x: ObjectInterface</span>) </span>&#123;&#125; <span class="comment">// referenced interface</span></span><br><span class="line">interface ObjectInterface &#123;</span><br><span class="line">  prop: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-名称重复"><a href="#3-2-名称重复" class="headerlink" title="3.2 名称重复"></a>3.2 名称重复</h4><p>含有重复名称的类型别名是非法的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @ts-ignore: Duplicate identifier 'PersonAlias'. (2300)</span></span><br><span class="line">type PersonAlias = &#123;<span class="attr">first</span>: string&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-ignore: Duplicate identifier 'PersonAlias'. (2300)</span></span><br><span class="line">type PersonAlias = &#123;<span class="attr">last</span>: string&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TypeScript 2.6 支持在 .ts 文件中通过在报错一行上方使用 <code>// @ts-ignore</code> 来忽略错误。</p>
<p><code>// @ts-ignore</code> 注释会忽略下一行中产生的所有错误。建议实践中在 <code>@ts-ignore</code>之后添加相关提示，解释忽略了什么错误。</p>
<p>请注意，这个注释仅会隐藏报错，并且我们建议你少使用这一注释。</p>
</blockquote>
<p>相反，含有重复名称的接口将会被合并：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface PersonInterface &#123;</span><br><span class="line">  first: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface PersonInterface &#123;</span><br><span class="line">  last: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sem: PersonInterface = &#123;</span><br><span class="line">  first: <span class="string">'Jiabao'</span>,</span><br><span class="line">  last: <span class="string">'Huang'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-映射类型"><a href="#3-3-映射类型" class="headerlink" title="3.3 映射类型"></a>3.3 映射类型</h4><p>对于映射类型（A行），我们需要使用对象字面量类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  x: number;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PointCopy1 = &#123;</span><br><span class="line">  [Key <span class="keyword">in</span> keyof Point]: Point[Key]; <span class="comment">// (A)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Syntax error:</span></span><br><span class="line"><span class="comment">// interface PointCopy2 &#123;</span></span><br><span class="line"><span class="comment">//   [Key in keyof Point]: Point[Key];</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-多态-this-类型"><a href="#3-4-多态-this-类型" class="headerlink" title="3.4 多态 this 类型"></a>3.4 多态 this 类型</h4><p>多态 this 类型仅适用于接口：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface AddsStrings &#123;</span><br><span class="line">  add(str: string): <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span> <span class="title">implements</span> <span class="title">AddsStrings</span> </span>&#123;</span><br><span class="line">  result = <span class="string">''</span>;</span><br><span class="line">  add(str: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.result += str;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>相信很多刚接触 TypeScript 的读者，看到 Object、object 和 {} 这几种类型时，也会感到疑惑。因为不知道它们之间的有什么区别，什么时候使用？为了让读者能更直观的了解到它们之间的区别，最后我们来做个总结：</p>
<h4 id="4-1-object-类型"><a href="#4-1-object-类型" class="headerlink" title="4.1 object 类型"></a>4.1 object 类型</h4><p>object 类型是：TypeScript 2.2 引入的新类型，它用于表示<strong>非原始类型。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node_modules/typescript/lib/lib.es5.d.ts</span></span><br><span class="line">interface ObjectConstructor &#123;</span><br><span class="line">  create(o: object | <span class="literal">null</span>): any;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proto = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.create(proto);     <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>);      <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="number">1337</span>);      <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">true</span>);      <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="string">"oops"</span>);    <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-Object-类型"><a href="#4-2-Object-类型" class="headerlink" title="4.2 Object 类型"></a>4.2 Object 类型</h4><p>Object 类型：它是所有 Object 类的实例的类型。它由以下两个接口来定义：</p>
<p>它由以下两个接口来定义：</p>
<ul>
<li>Object 接口定义了 Object.prototype 原型对象上的属性；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node_modules/typescript/lib/lib.es5.d.ts</span></span><br><span class="line"></span><br><span class="line">interface <span class="built_in">Object</span> &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Function;</span><br><span class="line">  toString(): string;</span><br><span class="line">  toLocaleString(): string;</span><br><span class="line">  valueOf(): Object;</span><br><span class="line">  hasOwnProperty(v: PropertyKey): boolean;</span><br><span class="line">  isPrototypeOf(v: Object): boolean;</span><br><span class="line">  propertyIsEnumerable(v: PropertyKey): boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ObjectConstructor 接口定义了 Object 类的属性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node_modules/typescript/lib/lib.es5.d.ts</span></span><br><span class="line"></span><br><span class="line">interface ObjectConstructor &#123;</span><br><span class="line">  <span class="comment">/** Invocation via `new` */</span></span><br><span class="line">  <span class="keyword">new</span>(value?: any): <span class="built_in">Object</span>;</span><br><span class="line">  <span class="comment">/** Invocation via function calls */</span></span><br><span class="line">  (value?: any): any;</span><br><span class="line"></span><br><span class="line">  readonly prototype: <span class="built_in">Object</span>;</span><br><span class="line"></span><br><span class="line">  getPrototypeOf(o: any): any;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="keyword">var</span> <span class="built_in">Object</span>: ObjectConstructor;</span><br></pre></td></tr></table></figure>

<p>Object 类的所有实例都继承了 Object 接口中的所有属性。</p>
<h4 id="4-3-类型"><a href="#4-3-类型" class="headerlink" title="4.3 {} 类型"></a>4.3 {} 类型</h4><p>{} 类型：它描述了一个没有成员的对象。当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译时错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Type &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Property 'prop' does not exist on type '&#123;&#125;'.</span></span><br><span class="line">obj.prop = <span class="string">"semlinker"</span>;</span><br></pre></td></tr></table></figure>

<p>但是，你仍然可以使用在 Object 类型上定义的所有属性和方法。</p>
<p>在我看来就是<code>Object</code>包含<code>object</code>和<code>{}</code>对等，只不过<code>{}</code>，可以添加一些别的属性，拓展性更强，范围更广。</p>
<h3 id="五、参考资源"><a href="#五、参考资源" class="headerlink" title="五、参考资源"></a>五、参考资源</h3><ul>
<li><a href="https://mariusschulz.com/blog/the-object-type-in-typescript" target="_blank" rel="noopener">the-object-type-in-typescript</a></li>
<li><a href="https://2ality.com/2020/01/typing-objects-typescript.html" target="_blank" rel="noopener">typing-objects-typescript</a></li>
<li><a href="https://stackoverflow.com/questions/49464634/difference-between-object-and-in-typescript" target="_blank" rel="noopener">difference-between-object-and-in-typescript</a></li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
        <category>TypeScript基础</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>tsconfig了解一下</title>
    <url>/2019/05/11/workspace/Typescript/tsConfig/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>tsconfig了解一下</strong></p>
<p>[[toc]]</p>
<h3 id="一些常用的配置"><a href="#一些常用的配置" class="headerlink" title="一些常用的配置"></a>一些常用的配置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>,                       <span class="comment">// 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'（"ESNext"表示最新的ES语法，包括还处在stage X阶段）</span></span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>,                  <span class="comment">// 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'</span></span><br><span class="line">    <span class="string">"lib"</span>: [],                             <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="string">"allowJs"</span>: <span class="literal">true</span>,                       <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="string">"checkJs"</span>: <span class="literal">true</span>,                       <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="string">"jsx"</span>: <span class="string">"preserve"</span>,                     <span class="comment">// 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'</span></span><br><span class="line">    <span class="string">"declaration"</span>: <span class="literal">true</span>,                   <span class="comment">// 生成相应的 '.d.ts' 文件</span></span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,                     <span class="comment">// 生成相应的 '.map' 文件</span></span><br><span class="line">    <span class="string">"outFile"</span>: <span class="string">"./"</span>,                       <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"./"</span>,                        <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="string">"rootDir"</span>: <span class="string">"./"</span>,                       <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="string">"removeComments"</span>: <span class="literal">true</span>,                <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="string">"noEmit"</span>: <span class="literal">true</span>,                        <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="string">"importHelpers"</span>: <span class="literal">true</span>,                 <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="string">"isolatedModules"</span>: <span class="literal">true</span>,               <span class="comment">// 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="string">"strict"</span>: <span class="literal">true</span>,                        <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>,                 <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="string">"strictNullChecks"</span>: <span class="literal">true</span>,              <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="string">"noImplicitThis"</span>: <span class="literal">true</span>,                <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="string">"alwaysStrict"</span>: <span class="literal">true</span>,                  <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="string">"noUnusedLocals"</span>: <span class="literal">true</span>,                <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="string">"noUnusedParameters"</span>: <span class="literal">true</span>,            <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="string">"noImplicitReturns"</span>: <span class="literal">true</span>,              <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="string">"noFallthroughCasesInSwitch"</span>: <span class="literal">true</span>,     <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line">    <span class="string">"allowUnreachableCode"</span>: <span class="literal">true</span>,           <span class="comment">//报告执行不到的代码错误。</span></span><br><span class="line">    <span class="string">"skipDefaultLibCheck"</span>: <span class="literal">false</span>,            <span class="comment">//忽略 库的默认声明文件的类型检查。</span></span><br><span class="line">    <span class="string">"skipLibCheck"</span>: <span class="literal">false</span>,                   <span class="comment">//忽略所有的声明文件（ *.d.ts）的类型检查。</span></span><br><span class="line">    <span class="string">"allowUnusedLabels"</span>: <span class="literal">false</span>,              <span class="comment">//不报告未使用的标签错误。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,            <span class="comment">// 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)。默认是classic</span></span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"./"</span>,                       <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="string">"paths"</span>: &#123;&#125;,                           <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="string">"rootDirs"</span>: [],                        <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="string">"typeRoots"</span>: [],                       <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="string">"types"</span>: [],                           <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="string">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>,  <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="string">"sourceRoot"</span>: <span class="string">"./"</span>,                    <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="string">"mapRoot"</span>: <span class="string">"./"</span>,                       <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="string">"inlineSourceMap"</span>: <span class="literal">true</span>,               <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="string">"inlineSources"</span>: <span class="literal">true</span>,                 <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,         <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="string">"emitDecoratorMetadata"</span>: <span class="literal">true</span>,          <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">    <span class="string">"strictFunctionTypes"</span>: <span class="literal">false</span>,           <span class="comment">// 禁用函数参数双向协变检查。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 指定编译文件或排除指定编译文件 */</span></span><br><span class="line">  <span class="string">"include"</span>: [</span><br><span class="line">      <span class="string">"src/**/*"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"exclude"</span>: [</span><br><span class="line">      <span class="string">"node_modules"</span>,</span><br><span class="line">      <span class="string">"**/*.spec.ts"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"files"</span>: [</span><br><span class="line">    <span class="string">"core.ts"</span>,</span><br><span class="line">    <span class="string">"sys.ts"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 从另一个配置文件里继承配置</span></span><br><span class="line">  <span class="string">"extends"</span>: <span class="string">"./config/base"</span>,</span><br><span class="line">  <span class="comment">// 让IDE在保存文件的时候根据tsconfig.json重新生成文件</span></span><br><span class="line">  <span class="string">"compileOnSave"</span>: <span class="literal">true</span> <span class="comment">// 支持这个特性需要Visual Studio 2015， TypeScript1.8.4以上并且安装atom-typescript插件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
        <category>tsconfig了解一下</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/2019/05/11/workspace/Typescript/ts/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>TypeScript</strong></p>
<p>[[toc]]</p>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>TypeScript 是 Microsoft 开发和维护的一种面向对象的编程语言。它是 JavaScript 的超集，包含了 JavaScript 的所有元素，可以载入 JavaScript 代码运行，并扩展了 JavaScript 的语法。</p>
<ul>
<li><p>TypeScript 具有以下特点：</p>
<ul>
<li>TypeScript 是 Microsoft 推出的开源语言，使用 Apache 授权协议</li>
<li>TypeScript <strong>增加了静态类型、类、模块、接口和类型注解</strong></li>
<li>TypeScript 可用于开发大型的应用</li>
<li>TypeScript 易学易于理解</li>
</ul>
</li>
<li><p>TypeScript 的优势：</p>
<ul>
<li>静态输入  开发环境下自动检查类型错误，以便写好更健壮的代码并对其进行维护，使得代码质量更好、更清晰。</li>
<li>大型的开发项目   使用TypeScript工具来进行重构更变的容易、快捷。（有时为了改进开发项目，需要对代码库进行小的增量更改。这些小小的变化可能会产生严重的、意想不到的后果，因此有必要撤销这些变化）</li>
<li>更好的协作</li>
<li>更强的生产力</li>
</ul>
</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><code>Boolean</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let isDone: boolean &#x3D; false;</span><br><span class="line">&#x2F;&#x2F; 编译通过</span><br><span class="line">&#x2F;&#x2F; 后面约定，未强调编译错误的代码片kk段，默认为编译通过</span><br><span class="line"></span><br><span class="line">let createdByNewBoolean: boolean &#x3D; new Boolean(1);</span><br><span class="line">&#x2F;&#x2F; index.ts(1,5): error TS2322: Type &#39;Boolean&#39; is not assignable to type &#39;boolean&#39;.</span><br><span class="line">&#x2F;&#x2F; 后面约定，注释中标出了编译报错的代码片段，表示编译未通过</span><br></pre></td></tr></table></figure>

<p><code>Number</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> notANumber: <span class="built_in">number</span> = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> infinityNumber: <span class="built_in">number</span> = <span class="literal">Infinity</span>;</span><br><span class="line"><span class="comment">//编译的结果</span></span><br><span class="line"><span class="keyword">var</span> decLiteral = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> hexLiteral = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">var</span> binaryLiteral = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">var</span> octalLiteral = <span class="number">484</span>;</span><br><span class="line"><span class="keyword">var</span> notANumber = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> infinityNumber = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure>

<p><code>String</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: <span class="built_in">string</span> = <span class="string">'Tom'</span>;</span><br></pre></td></tr></table></figure>

<p><code>Void</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertName</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    alert(<span class="string">'My name is Tom'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//能将它赋值为 undefined 和 null：</span></span><br><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><code>Null 和 Undefined</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：</span></span><br><span class="line"><span class="comment">// 这样不会报错</span></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">//而 void 类型的变量不能赋值给 number 类型的变量：</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = u;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,5): error TS2322: Type 'void' is not assignable to type 'number'.</span></span><br></pre></td></tr></table></figure>

<p><code>Any</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任意值（Any）用来表示允许赋值为任意类型。</span></span><br><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">any</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p><code>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象</code></p>
<p>定义一对值分别为 string 和 number 的元组：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>]; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">onsole.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)); <span class="comment">// Error, 'number' does not have 'substr'</span></span><br></pre></td></tr></table></figure>

<p><code>越界的元素</code></p>
<p>在 2.6 及之前版本中，超出规定个数的元素称作越界元素，但是只要越界元素的类型是定义的类型中的一种即可。<br>比如我们定义的类型有两种：string 和 number，越界的元素是 string 类型，属于联合类型，<br>所以没问题，联合类型的概念我们后面会讲到。string | number</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">'world'</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>
<p>在 2.6 之后的版本，去掉了这个越界元素是联合类型的子类型即可的条件，要求元组赋值必须类型和个数都对应。</p>
<p>在 2.6 之后的版本，[string, number] 元组类型的声明效果上可以看作等同于下面的声明：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Tuple <span class="keyword">extends</span> Array&lt;number | string&gt; &#123;<span class="number">0</span>: <span class="built_in">string</span>; <span class="number">1</span>: <span class="built_in">number</span>; length: <span class="number">2</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>如果元素个数超过 2 个时，它的 length 就不是 2 是大于 2 的数了，就不满足这个接口定义了，所以就会报错。</p>
<p><strong>如果你想要和 2.6 及之前版本一样的元组特性，那你可以这样定义接口：</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Tuple <span class="keyword">extends</span> Array&lt;number | string&gt; &#123;<span class="number">0</span>: <span class="built_in">string</span>; <span class="number">1</span>: <span class="built_in">number</span>;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><code>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</code></p>
<p><strong>普通枚举</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sun"</span>] === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Mon"</span>] === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Tue"</span>] === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sat"</span>] === <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">0</span>] === <span class="string">"Sun"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">1</span>] === <span class="string">"Mon"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">2</span>] === <span class="string">"Tue"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">6</span>] === <span class="string">"Sat"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123;Sun = <span class="number">7</span>, Mon = <span class="number">4</span>, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sun"</span>] === <span class="number">7</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Mon"</span>] === <span class="number">4</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Tue"</span>] === <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Thu"</span>] === <span class="number">7</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//未手动赋值的枚举项会接着上一个枚举项递增。</span></span><br><span class="line"><span class="comment">//如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的：</span></span><br><span class="line"><span class="comment">//所以使用的时候需要注意，最好不要出现这种覆盖的情况。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Days &#123;Sun = <span class="number">7</span>, Mon, Tue, Wed, Thu, Fri, Sat = &lt;<span class="built_in">any</span>&gt;<span class="string">"S"</span>&#125;;</span><br><span class="line"><span class="comment">//使用类型断言来让 tsc 无视类型检查</span></span><br></pre></td></tr></table></figure>

<p><strong>常数枚举</strong></p>
<p><code>常数枚举是使用 const enum 定义的枚举类型：</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br><span class="line"><span class="comment">//常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员(赋值)。</span></span><br><span class="line"><span class="comment">//上例的编译结果是：</span></span><br><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br></pre></td></tr></table></figure>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">    foo: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  loading:<span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> MyComponent <span class="keyword">extends</span> React.Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;span&gt;&#123;<span class="keyword">this</span>.props.foo&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p><code>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</code><br><br/><br>以下代码虽然没有指定类型，但是会在编译的时候报错：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure>
<p>事实上，它等价于：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：</span></span><br><span class="line"><span class="keyword">let</span> myFavoriteNumber;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>


<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p><code>联合类型（Union Types）表示取值可以为多种类型中的一种。</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 5</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 编译时报错,number么有length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型断言有两种形式。 其一是“尖括号”语法：</span></span><br><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br><span class="line"><span class="comment">//另一个为as语法：</span></span><br><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br><span class="line"><span class="comment">//两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。</span></span><br></pre></td></tr></table></figure>


<p><code>解决上面联合类型字符串和数字length的问题</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((&lt;<span class="built_in">string</span>&gt;something).length) &#123;</span><br><span class="line">        <span class="keyword">return</span> (&lt;<span class="built_in">string</span>&gt;something).length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Interfaces-接口"><a href="#Interfaces-接口" class="headerlink" title="Interfaces 接口"></a>Interfaces 接口</h3><p><code>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;<span class="comment">//可选属性</span></span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;<span class="comment">//任意属性</span></span><br><span class="line">    readonly id: <span class="built_in">number</span>;<span class="comment">//只读属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.</span></span><br><span class="line"><span class="comment">// index.ts(7,5): error TS2322: Type '&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//Index signatures are incompatible.</span></span><br><span class="line"><span class="comment">//Type 'string | number' is not assignable to type 'string'.</span></span><br><span class="line"><span class="comment">//Type 'number' is not assignable to type 'string'.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。</span></span><br></pre></td></tr></table></figure>
<p><strong><code>接口继承接口</code></strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">    penWidth: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>
<p><strong><code>混合类型</code></strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个对象可以同时做为函数和对象使用，并带有额外的属性。</span></span><br><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">    (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">    interval: <span class="built_in">number</span>;</span><br><span class="line">    reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123; &#125;;</span><br><span class="line">    counter.interval = <span class="number">123</span>;</span><br><span class="line">    counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>接口继承类</code></strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单</span></span><br><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">    z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123;x: <span class="number">1</span>, y: <span class="number">2</span>, z: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</span></span><br><span class="line"><span class="comment">//当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：</span></span><br><span class="line"><span class="keyword">class</span> Control &#123;</span><br><span class="line">    <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</span><br><span class="line">    select(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class="line"><span class="keyword">class</span> Image <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Location &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h3><p><code>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//「类型 + 方括号」表示法</span></span><br><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">               <span class="built_in">number</span>|<span class="built_in">string</span>[] = [<span class="string">'1'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组泛型</span></span><br><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">               <span class="built_in">Array</span>&lt;<span class="built_in">number</span>|<span class="built_in">string</span>&gt; = [<span class="string">'22'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">//              </span></span><br><span class="line"><span class="keyword">let</span> banners: <span class="built_in">Array</span>&lt;&#123; id: <span class="built_in">number</span>, name: <span class="built_in">string</span>, pic: <span class="built_in">string</span>, url: <span class="built_in">string</span> &#125;&gt;=[&#123;id: <span class="number">1</span>, name: <span class="string">"111"</span>, pic: <span class="string">"111"</span>, url: <span class="string">"111"</span>&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用接口表示数组</span></span><br><span class="line"><span class="keyword">interface</span> NumberArray &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">interface</span> NumberArray &#123;</span><br><span class="line">    id: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    pic: <span class="built_in">string</span>;</span><br><span class="line">    url: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> banners: NumberArray[] = [&#123;id: <span class="number">1</span>, name: <span class="string">"111"</span>, pic: <span class="string">"111"</span>, url: <span class="string">"111"</span>&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//any 在数组中的应用</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="string">'Xcat Liu'</span>, <span class="number">25</span>, &#123; website: <span class="string">'http://xcatliu.com'</span> &#125;];</span><br></pre></td></tr></table></figure>

<h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span> = 666, y?: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">	<span class="comment">//参数默认值</span></span><br><span class="line">	<span class="comment">//可选参数后面不允许再出现必须参数了</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这是可以通过编译的，不过事实上应该是这样：</span></span><br><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p><strong>默认为 <code>public</code></strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 public来做修饰；例如，C#要求必须明确地使用 public指定成员是可见的。 在TypeScript里，成员都默认为 public。</span></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">    <span class="keyword">public</span> move(distanceInMeters: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>理解 <code>private</code></strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员被标记成 private时，它就不能在声明它的类的外部访问。比如</span></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Animal(<span class="string">"Cat"</span>).name; <span class="comment">// 错误: 'name' 是私有的.</span></span><br></pre></td></tr></table></figure>

<p><strong>理解 <code>protected</code></strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在子类中仍然可以访问。例如：</span></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">protected</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Cat(<span class="string">'heshen'</span>).name</span><br><span class="line"><span class="comment">//构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee 能够继承 Person</span></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> department: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.department = department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> Person(<span class="string">"John"</span>); <span class="comment">// 错误: 'Person' 的构造函数是被保护的.</span></span><br></pre></td></tr></table></figure>
<p><strong><code>抽象类</code></strong><br><code>abstract 用于定义抽象类和其中的抽象方法。</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先，抽象类是不允许被实例化的：</span></span><br><span class="line"><span class="comment">//其次，抽象类中的抽象方法必须被子类实现：</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> eat() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is eating.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="comment">// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(<span class="string">'Tom'</span>);</span><br><span class="line"><span class="comment">// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的例子中，我们定义了一个类 Cat 继承了抽象类 Animal，但是没有实现抽象方法 sayHi</span></span><br></pre></td></tr></table></figure>

<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p><code>ECMAScript 标准提供的内置对象有：</code><br>Boolean、Error、Date、RegExp  Object Number……<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">查看更多</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">Error</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error occurred'</span>);</span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> r: <span class="built_in">RegExp</span> = <span class="regexp">/[a-z]/</span>;</span><br></pre></td></tr></table></figure>

<p><code>DOM 和 BOM 的内置对象</code><br>Document、HTMLElement、Event、NodeList …..</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> body: HTMLElement = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">let</span> allDiv: NodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e: MouseEvent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>TypeScript 核心库的定义文件</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="string">'2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,14): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//事实上Math.pow 的类型定义如下：</span></span><br><span class="line"><span class="keyword">interface</span> Math &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of a base expression taken to a specified power.</span></span><br><span class="line"><span class="comment">     * @param x The base value of the expression.</span></span><br><span class="line"><span class="comment">     * @param y The exponent value of the expression.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pow(x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-类型别名"><a href="#type-类型别名" class="headerlink" title="type 类型别名"></a>type 类型别名</h3><p>type 会给一个类型起个新名字。 type 有时和 interface 很像，但是可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>; <span class="comment">// 基本类型</span></span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>; <span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver; <span class="comment">// 联合类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类型别名常用于联合类型。</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><p><code>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EventNames = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">ele: Element, event: EventNames</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>), <span class="string">'scroll'</span>);  <span class="comment">// 没问题</span></span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'world'</span>), <span class="string">'dbclick'</span>); <span class="comment">// 报错，event 不能为 'dbclick'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(7,47): error TS2345: Argument of type '"dbclick"' is not assignable to parameter of type 'EventNames'.</span></span><br></pre></td></tr></table></figure>
<p><strong><code>类型别名</code> 与 <code>字符串字面量类型</code> 都是使用 <code>type</code> 进行定义</strong></p>
<h3 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h3><p><code>声明语句放到一个单独的文件如(index.d.ts)中，这就是声明文件，声明文件必需以 .d.ts 为后缀。</code></p>
<p>假如无法解析index.d.ts，那么可以检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 index.d.ts 文件</p>
<h4 id="React的声明文件"><a href="#React的声明文件" class="headerlink" title="React的声明文件"></a>React的声明文件</h4><figure class="highlight typescript"><figcaption><span>jsx&#123;1,7&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; History,Location &#125; <span class="keyword">from</span> <span class="string">"history"</span>;</span><br><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">   location: Location;</span><br><span class="line">   history: History;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AnyAction, Dispatch &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  dispatch: Dispatch&lt;AnyAction&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承React"><a href="#继承React" class="headerlink" title="继承React"></a>继承React</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormComponentProps &#125; <span class="keyword">from</span> <span class="string">'antd/lib/form'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; match &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Dispatch &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IProps <span class="keyword">extends</span> React.HTMLAttributes&lt;HTMLDivElement&gt; &#123;</span><br><span class="line">  dispatch?: Dispatch&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">  match?: match;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Component&lt;P = &#123;&#125;, S = &#123;&#125;&gt; <span class="keyword">extends</span> React.Component&lt;P &amp; IProps, S&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PureComponent&lt;P = &#123;&#125;, S = &#123;&#125;&gt; <span class="keyword">extends</span> React.PureComponent&lt;P &amp; IProps, S&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表单属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> FormProps <span class="keyword">extends</span> IProps, FormComponentProps &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> FormComponent&lt;P = &#123;&#125;, S = &#123;&#125;&gt; <span class="keyword">extends</span> React.PureComponent&lt;P &amp; FormProps, S&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Typescript错误忽略"><a href="#Typescript错误忽略" class="headerlink" title="Typescript错误忽略"></a>Typescript错误忽略</h3><p><strong>单行忽略</strong><br><code>// @ts-ignore</code></p>
<p><strong>忽略全文</strong><br><code>// @ts-nocheck</code></p>
<p><strong>取消忽略全文</strong><br><code>// @ts-check</code></p>
]]></content>
      <categories>
        <category>TypeScript</category>
        <category>TypeScript基础</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用指南（antdp）</title>
    <url>/2019/05/11/workspace/Typescript/use/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>使用指南（antdp）</strong></p>
<p>[[toc]]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type SiderTheme = <span class="string">'light'</span> | <span class="string">'dark'</span>;</span><br><span class="line"><span class="keyword">export</span> interface GlobalHeaderRightProps extends ConnectProps &#123;</span><br><span class="line">  theme?: SiderTheme;</span><br><span class="line">  layout: <span class="string">'sidemenu'</span> | <span class="string">'topmenu'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">validateFields(<span class="function">(<span class="params">err: unknown, fieldsValue: searchParamsType</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line"> form: FormComponentProps[<span class="string">'form'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(e: React.FormEvent)=&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>


<p><strong>d.ts</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Reducer,</span><br><span class="line">  AnyAction,</span><br><span class="line">  ReducersMapObject,</span><br><span class="line">  Dispatch,</span><br><span class="line">  MiddlewareAPI,</span><br><span class="line">  StoreEnhancer</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; History &#125; <span class="keyword">from</span> <span class="string">"history"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface onActionFunc &#123;</span><br><span class="line">  (api: MiddlewareAPI&lt;any&gt;): <span class="keyword">void</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface ReducerEnhancer &#123;</span><br><span class="line">  (reducer: Reducer&lt;any&gt;): <span class="keyword">void</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface Hooks &#123;</span><br><span class="line">  onError?: <span class="function">(<span class="params">e: <span class="built_in">Error</span>, dispatch: Dispatch&lt;any&gt;</span>) =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line">  onAction?: onActionFunc | onActionFunc[],</span><br><span class="line">  onStateChange?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line">  onReducer?: ReducerEnhancer,</span><br><span class="line">  onEffect?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line">  onHmr?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line">  extraReducers?: ReducersMapObject,</span><br><span class="line">  extraEnhancers?: StoreEnhancer&lt;any&gt;[],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type DvaOption = Hooks &amp; &#123;</span><br><span class="line">  initialState?: <span class="built_in">Object</span>,</span><br><span class="line">  history?: <span class="built_in">Object</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface EffectsCommandMap &#123;</span><br><span class="line">  put: <span class="xml"><span class="tag">&lt;<span class="name">A</span> <span class="attr">extends</span> <span class="attr">AnyAction</span>&gt;</span>(action: A) =&gt; any,</span></span><br><span class="line"><span class="xml">  call: Function,</span></span><br><span class="line"><span class="xml">  select: Function,</span></span><br><span class="line"><span class="xml">  take: Function,</span></span><br><span class="line"><span class="xml">  cancel: Function,</span></span><br><span class="line"><span class="xml">  [key: string]: any,</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export type Effect = (action: AnyAction, effects: EffectsCommandMap) =&gt; void;</span></span><br><span class="line"><span class="xml">export type EffectType = 'takeEvery' | 'takeLatest' | 'watcher' | 'throttle';</span></span><br><span class="line"><span class="xml">export type EffectWithType = [Effect, &#123; type : EffectType &#125;];</span></span><br><span class="line"><span class="xml">export type Subscription = (api: SubscriptionAPI, done: Function) =&gt; void;</span></span><br><span class="line"><span class="xml">export type ReducersMapObjectWithEnhancer = [ReducersMapObject, ReducerEnhancer];</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export interface EffectsMapObject &#123;</span></span><br><span class="line"><span class="xml">  [key: string]: Effect | EffectWithType,</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export interface SubscriptionAPI &#123;</span></span><br><span class="line"><span class="xml">  history: History,</span></span><br><span class="line">  dispatch: Dispatch&lt;any&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface SubscriptionsMapObject &#123;</span><br><span class="line">  [key: string]: Subscription,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface Model &#123;</span><br><span class="line">  namespace: string,</span><br><span class="line">  state?: any,</span><br><span class="line">  reducers?: ReducersMapObject | ReducersMapObjectWithEnhancer,</span><br><span class="line">  effects?: EffectsMapObject,</span><br><span class="line">  subscriptions?: SubscriptionsMapObject,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface RouterAPI &#123;</span><br><span class="line">  history: History,</span><br><span class="line">  app: DvaInstance,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface Router &#123;</span><br><span class="line">  (api?: RouterAPI): JSX.Element | Object,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface DvaInstance &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Register an object of hooks on the application.</span><br><span class="line">   *</span><br><span class="line">   * @param hooks</span><br><span class="line">   */</span><br><span class="line">  use: (hooks: Hooks) =&gt; void,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Register a model.</span><br><span class="line">   *</span><br><span class="line">   * @param model</span><br><span class="line">   */</span><br><span class="line">  model: (model: Model) =&gt; void,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Unregister a model.</span><br><span class="line">   *</span><br><span class="line">   * @param namespace</span><br><span class="line">   */</span><br><span class="line">  unmodel: (namespace: string) =&gt; void,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Config router. Takes a function with arguments &#123; history, dispatch &#125;,</span><br><span class="line">   * and expects router config. It use the same api as react-router,</span><br><span class="line">   * return jsx elements or JavaScript Object for dynamic routing.</span><br><span class="line">   *</span><br><span class="line">   * @param router</span><br><span class="line">   */</span><br><span class="line">  router: (router: Router) =&gt; void,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Start the application. Selector is optional. If no selector</span><br><span class="line">   * arguments, it will return a function that return JSX elements.</span><br><span class="line">   *</span><br><span class="line">   * @param selector</span><br><span class="line">   */</span><br><span class="line">  start: (selector?: HTMLElement | string) =&gt; any,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function dva(opts?: DvaOption): DvaInstance;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Connects a React component to Dva.</span><br><span class="line"> */</span><br><span class="line">export function connect(</span><br><span class="line">  mapStateToProps?: Function,</span><br><span class="line">  mapDispatchToProps?: Function,</span><br><span class="line">  mergeProps?: Function,</span><br><span class="line">  options?: Object</span><br><span class="line">): Function;</span><br></pre></td></tr></table></figure>


<p><strong>model</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Reducer &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Subscription, Effect &#125; <span class="keyword">from</span> <span class="string">'dva'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; NoticeIconData &#125; <span class="keyword">from</span> <span class="string">'@/components/NoticeIcon'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; queryNotices &#125; <span class="keyword">from</span> <span class="string">'@/services/user'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConnectState &#125; <span class="keyword">from</span> <span class="string">'./connect.d'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface NoticeItem extends NoticeIconData &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  type: string;</span><br><span class="line">  status: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface GlobalModelState &#123;</span><br><span class="line">  collapsed: boolean;</span><br><span class="line">  notices: NoticeItem[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface GlobalModelType &#123;</span><br><span class="line">  namespace: <span class="string">'global'</span>;</span><br><span class="line">  state: GlobalModelState;</span><br><span class="line">  effects: &#123;</span><br><span class="line">    fetchNotices: Effect;</span><br><span class="line">    clearNotices: Effect;</span><br><span class="line">    changeNoticeReadState: Effect;</span><br><span class="line">  &#125;;</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    changeLayoutCollapsed: Reducer&lt;GlobalModelState&gt;;</span><br><span class="line">    saveNotices: Reducer&lt;GlobalModelState&gt;;</span><br><span class="line">    saveClearedNotices: Reducer&lt;GlobalModelState&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">  subscriptions: &#123; <span class="attr">setup</span>: Subscription &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GlobalModel: GlobalModelType = &#123;</span><br><span class="line">  namespace: <span class="string">'global'</span>,</span><br><span class="line"></span><br><span class="line">  state: &#123;</span><br><span class="line">    collapsed: <span class="literal">false</span>,</span><br><span class="line">    notices: [],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  effects: &#123;</span><br><span class="line">    *fetchNotices(_, &#123; call, put, select &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">yield</span> call(queryNotices);</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">'saveNotices'</span>,</span><br><span class="line">        payload: data,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> unreadCount: number = <span class="keyword">yield</span> select(</span><br><span class="line">        (state: ConnectState) =&gt; state.global.notices.filter(<span class="function"><span class="params">item</span> =&gt;</span> !item.read).length,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">'user/changeNotifyCount'</span>,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          totalCount: data.length,</span><br><span class="line">          unreadCount,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    *clearNotices(&#123; payload &#125;, &#123; put, select &#125;) &#123;</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">'saveClearedNotices'</span>,</span><br><span class="line">        payload,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> count: number = <span class="keyword">yield</span> select(<span class="function">(<span class="params">state: ConnectState</span>) =&gt;</span> state.global.notices.length);</span><br><span class="line">      <span class="keyword">const</span> unreadCount: number = <span class="keyword">yield</span> select(</span><br><span class="line">        (state: ConnectState) =&gt; state.global.notices.filter(<span class="function"><span class="params">item</span> =&gt;</span> !item.read).length,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">'user/changeNotifyCount'</span>,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          totalCount: count,</span><br><span class="line">          unreadCount,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    *changeNoticeReadState(&#123; payload &#125;, &#123; put, select &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> notices: NoticeItem[] = <span class="keyword">yield</span> select(<span class="function">(<span class="params">state: ConnectState</span>) =&gt;</span></span><br><span class="line">        state.global.notices.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> notice = &#123; ...item &#125;;</span><br><span class="line">          <span class="keyword">if</span> (notice.id === payload) &#123;</span><br><span class="line">            notice.read = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> notice;</span><br><span class="line">        &#125;),</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">'saveNotices'</span>,</span><br><span class="line">        payload: notices,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">'user/changeNotifyCount'</span>,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          totalCount: notices.length,</span><br><span class="line">          unreadCount: notices.filter(<span class="function"><span class="params">item</span> =&gt;</span> !item.read).length,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  reducers: &#123;</span><br><span class="line">    changeLayoutCollapsed(state = &#123; <span class="attr">notices</span>: [], <span class="attr">collapsed</span>: <span class="literal">true</span> &#125;, &#123; payload &#125;): GlobalModelState &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        collapsed: payload,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    saveNotices(state, &#123; payload &#125;): GlobalModelState &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        collapsed: <span class="literal">false</span>,</span><br><span class="line">        ...state,</span><br><span class="line">        notices: payload,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    saveClearedNotices(state = &#123; <span class="attr">notices</span>: [], <span class="attr">collapsed</span>: <span class="literal">true</span> &#125;, &#123; payload &#125;): GlobalModelState &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        collapsed: <span class="literal">false</span>,</span><br><span class="line">        ...state,</span><br><span class="line">        notices: state.notices.filter((item): <span class="function"><span class="params">boolean</span> =&gt;</span> item.type !== payload),</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  subscriptions: &#123;</span><br><span class="line">    setup(&#123; history &#125;): <span class="keyword">void</span> &#123;</span><br><span class="line">      <span class="comment">// Subscribe history(url) change, trigger `load` action if pathname is `/`</span></span><br><span class="line">      history.listen((&#123; pathname, search &#125;): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.ga !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">          <span class="built_in">window</span>.ga(<span class="string">'send'</span>, <span class="string">'pageview'</span>, pathname + search);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> GlobalModel;</span><br></pre></td></tr></table></figure>


<p><strong>connect</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Dispatch, AnyAction &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line">interface LoginProps &#123;</span><br><span class="line">  dispatch: Dispatch&lt;AnyAction&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@connect(<span class="function">(<span class="params">&#123; login, loading &#125;: ConnectState</span>) =&gt;</span> (&#123;</span><br><span class="line">  userLogin: login,</span><br><span class="line">  submitting: loading.effects[<span class="string">'login/login'</span>],</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface Loading &#123;</span><br><span class="line">  global: boolean;</span><br><span class="line">  effects: &#123; [key: string]: boolean | <span class="literal">undefined</span> &#125;;</span><br><span class="line">  models: &#123;</span><br><span class="line">    global?: boolean;</span><br><span class="line">    menu?: boolean;</span><br><span class="line">    setting?: boolean;</span><br><span class="line">    user?: boolean;</span><br><span class="line">    login?: boolean;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface ConnectState &#123;</span><br><span class="line">  global: GlobalModelState;</span><br><span class="line">  loading: Loading;</span><br><span class="line">  settings: SettingModelState;</span><br><span class="line">  user: UserModelState;</span><br><span class="line">  login: LoginModelType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
        <category>使用指南（antdp）</category>
      </categories>
  </entry>
  <entry>
    <title>Babel-polyfill</title>
    <url>/2019/01/16/workspace/Webpack/babel_polyfill/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Babel-polyfill</strong></p>
<p>[[toc]]</p>
<h3 id="babel-preset-env-babel-polyfill和-babel-plugin-transform-runtime"><a href="#babel-preset-env-babel-polyfill和-babel-plugin-transform-runtime" class="headerlink" title="@babel/preset-env, @babel/polyfill和@babel/plugin-transform-runtime"></a>@babel/preset-env, @babel/polyfill和@babel/plugin-transform-runtime</h3><p>这可以说是babel官方的得意之作，最早的时候没有这个包，有的是babel-preset-es2015这样的包，后来每次新标准发布之后，就要新加一个包。<br/><br>babel顺应民意，发布了babel-preset-env这个包，它一次性囊括了已发布的所有标准包。<br/><br>首先我们需要明确一下，preset-env的首要作用，不是帮我们把ES6+代码转成ES5.它的首要作用是认读ES6+代码。<br/><br>在使用preset-env之前，babel是无法认识ES6+代码的，运行时会报Token错误。在使用preset-env之后，babel才能认识这些代码语法，并将它们抽象出AST树。<br/><br>preset-env本身包含了一大堆plugin，并通过配置来控制插件，从而控制转码效果<br/></p>
<p><strong><code>@babel/preset-env</code></strong></p>
<p><strong>targets</strong><br>控制目标浏览器的版本</p>
<p><strong>modules</strong><br>默认为commonjs，设置为false时，不会转码模块加载，import from 语法不会转码</p>
<p><strong>useBuiltIns</strong><br>是否自动加载polyfill。它有三个值可选：false（默认）, entry, usage。</p>
<p><strong>corejs</strong><br>承接useBuiltIns，当useBuiltIns值为entry或usage时，有效。它可以设置为：2，3，{ version:2, proposals:true }</p>
<p><strong><code>@babel/polyfill</code></strong><br>这个包是一个纯运行时的包，不是babel插件。它的作用是直接改写全局变量，从而让运行环境支持经过present-env转码后的代码</p>
<p><strong><code>@babel/plugin-transform-runtime</code></strong></p>
<ul>
<li>它有两个作用：<ul>
<li>将preset-env所产生的helpers函数提出到一个独立文件中，从而减少代码量</li>
<li>建立运行时沙盒，避免全局污染</li>
</ul>
</li>
</ul>
<p><strong>corejs</strong></p>
<p><strong>helpers</strong><br>是否要将所有helper函数提炼到另外一个公共文件中。默认为true。</p>
<p>当使用@babel/plugin-trasnform-runtime之后，原本babel会直接在文件中创建一个helper函数，现在会采用require的方式，从@babel/runtime中引入这些函数，这样就可以减少代码量</p>
<h3 id="polyfill了解下"><a href="#polyfill了解下" class="headerlink" title="polyfill了解下"></a>polyfill了解下</h3><p>babel 编译时只转换语法，几乎可以编译所有时新的 JavaScript 语法，但并不会转化BOM里面不兼容的API<br/><br>比如 <strong>Promise,Set,Symbol,Array.from,Array.is,async</strong> 等等的一些API<br/><br>这时候就需要 polyfill 来转转化这些API<br/><br>babel 转译语法需要一些plugin<br/><br>如<strong>babel-preset-es2015,stage-0,stage-1</strong>等等<br/><br>其中的 es2015 表示 babel会加载 es6 相关的编译模块，然后 stage-0 表示的是什么呢？<br/><br>stage 系列集合了一些对 es7 的草案支持的插件，由于是草案，所以作为插件的形式提供。<br/></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stage<span class="number">-0</span> - Strawman: just an idea, possible Babel plugin.</span><br><span class="line">stage<span class="number">-1</span> - Proposal: <span class="keyword">this</span> is worth working on.</span><br><span class="line">stage<span class="number">-2</span> - Draft: initial spec.</span><br><span class="line">stage<span class="number">-3</span> - Candidate: complete spec and initial browser implementations.</span><br><span class="line">stage<span class="number">-4</span> - Finished: will be added to the next yearly release.</span><br></pre></td></tr></table></figure>

<p>stage 是向下兼容  0&gt;1&gt;2&gt;3&gt;4 所包含的插件数量依次减少</p>
<p>polyfill 有三种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">babel-runtime</span><br><span class="line">babel-plugin-transform-runtime(推荐-默认依赖于babel-runtime)</span><br><span class="line">babel-polyfill</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>
<p>在webpack中，<strong>babel-plugin-transform-runtime 实际上是依赖babel-runtime</strong> <br/><br>因为babel编译es6到es5的过程中，babel-plugin-transform-runtime这个插件会自动polyfill es5不支持的特性，<br/><br>这些polyfill包就是在babel-runtime这个包里 core-js 、regenerator等  polyfill。<br/><br>babel-runtime和 babel-plugin-transform-runtime的区别是，相当一前者是手动挡而后者是自动挡，每当要转译一个api时都要手动加上require(‘babel-runtime’)，<br/><br>而babel-plugin-transform-runtime会由工具自动添加，主要的功能是为api提供沙箱的垫片方案，不会污染全局的api，因此适合用在第三方的开发产品中。<br/></p>
<h3 id="babel7中-corejs-和-corejs2-的区别"><a href="#babel7中-corejs-和-corejs2-的区别" class="headerlink" title="babel7中 corejs 和 corejs2 的区别"></a>babel7中 corejs 和 corejs2 的区别</h3><p>最近在给项目升级babel7，有一些改变但是变化不大,在升级中发现 babel7 变化挺大的，包括插件和包。<br>其中一项功能特别赞，就是  @babel/preset-env  中的  useBuiltIns  选项，如果你设置了  usage ，babel 编绎的时候就不用整个 polyfills , 只加载你使用 polyfills，这样就可以减少包的大小。<br>在使用 babel 中还想减少代码，就需要引入 babel 的运行时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add @babel/plugin-transform-runtime -D</span><br><span class="line">yarn add @babel/runtime</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ol>
<li>两个包引入的范围不一样：一个在开发时引入，一个在运行时引入。</li>
<li>plugin-transform-runtime 已经默认包括了 @babel/polyfill，因此不用在独立引入。</li>
</ol>
<p>在 plugin-transform-runtime 中有一个 corejs 很奇怪，可以设置成 false 或者 2。这是为什么这样？<br/><br>大家知道 corejs 是一个给低版本的浏览器提供接口的库，如 Promise, map, set 等。<br/><br>在 babel 中你设置成 false 或者不设置，就是引入的是 corejs 中的库，而且在全局中引入，也就是说侵入了全局的变量。可以观察以下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是你写的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, ms)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// babel 编绎成的代码</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"core-js/modules/es6.promise"</span>);  <span class="comment">// 这里可以看出是全局引入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你的全局有一个引入，防止引入的库影响全局，那你就需要引把 corejs 设置成2。下面就是设真置成2，编绎成的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> _interopRequireDefault = <span class="built_in">require</span>(<span class="string">"@babel/runtime-corejs2/helpers/interopRequireDefault"</span>);</span><br><span class="line"><span class="keyword">var</span> _promise = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">"@babel/runtime-corejs2/core-js/promise"</span>)); <span class="comment">// 独立变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> _promise.default(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以从编绎出的代码看到，Promise 代码变成了一个独立的变量 _promise，不会影响全局的 Promise。<br/><br>这样的好处是，引入的库者自己引入了一个变量，这样如果你引入的第三方库会对 Promise 进行一些自定义操作，这样就可以避免第三方库报错。<br/><br>还要注意一点是： 如果你设置了 corejs2，那你就需要加入下面的库:</p>
<p><span style='display: block;text-align: left;'> corejs选项</span>|<span style='display: block;text-align: left;'> 安装命令</span>|<span style='display: block;text-align: left;'>里面包含的文件</span><br>–|:–:|:–:|–|<br>false |    yarn add @babel/runtime |  helpers、regenerator<br><strong>2</strong> |    <strong>yarn add  @babel/runtime-corejs2</strong> |  core-js、helpers、regenerator<br>3  | yarn add  @babel/runtime-corejs3 | 还支持实例属性（例如[].includes)</p>
<p>参考文档：<br/><br><a href="https://babeljs.io/docs/en/babel-preset-env/" target="_blank" rel="noopener">babel-preset-env</a></p>
<p><a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime" target="_blank" rel="noopener">babel-plugin-transform-runtime</a></p>
<p>runtime转换器插件主要做了三件事：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">当你使用generators/<span class="keyword">async</span>方法、函数时自动调用babel-runtime/regenerator</span><br><span class="line">当你使用ES6 的<span class="built_in">Map</span>或者内置的东西时自动调用babel-runtime/core-js</span><br><span class="line">移除内联babel helpers并替换使用babel-runtime/helpers来替换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">transform-runtime优点</span><br><span class="line">    不会污染全局变量</span><br><span class="line">    多次使用只会打包一次</span><br><span class="line">    依赖统一按需引入,无重复引入,无多余引入</span><br><span class="line"></span><br><span class="line">transform-runtime缺点</span><br><span class="line">   不支持实例化的方法<span class="built_in">Array</span>.includes(x) 就不能转化</span><br><span class="line">   如果使用的API用的次数不是很多，那么transform-runtime 引入polyfill的包会比不是transform-runtime时大</span><br><span class="line"></span><br><span class="line">babel-polyfill则是通过改写全局prototype的方式实现，比较适合单独运行的项目。</span><br><span class="line">    开启babel-polyfill的方式，可以直接在代码中<span class="built_in">require</span>，或者在webpack的entry中添加，也可以在babel的env中设置useBuildins为<span class="literal">true</span>来开启。</span><br><span class="line">    但是babel-polyfill会有近<span class="number">100</span>K，</span><br><span class="line">    打包后代码冗余量比较大，</span><br><span class="line">    对于现代的浏览器,有些不需要polyfill，造成流量浪费</span><br><span class="line">    污染了全局对象</span><br><span class="line"></span><br><span class="line">@babel/runtime-corejs2包含三个文件夹：</span><br><span class="line">    core-js  引用core-js这个npm包</span><br><span class="line">    helpers  定义了一些处理新的语法关键字的帮助函数</span><br><span class="line">    regenerator  仅仅是引用regenerator-runtime这个npm包</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Webpack</category>
        <category>Babel-polyfill</category>
      </categories>
  </entry>
  <entry>
    <title>Webpack的使用</title>
    <url>/2019/01/14/workspace/Webpack/use/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Webpack的使用</strong></p>
<p>[[toc]]</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>异步加载模块</span><br><span class="line"><span class="number">2.</span>提取第三库</span><br><span class="line"><span class="number">3.</span>代码压缩</span><br><span class="line"><span class="number">4.</span>去除不必要的插件</span><br><span class="line"><span class="number">5.</span>图片base64</span><br><span class="line"><span class="number">6.</span>按需加载</span><br><span class="line"><span class="number">7.</span>开启Gzip压缩</span><br></pre></td></tr></table></figure>

<h3 id="splitChunks拆包"><a href="#splitChunks拆包" class="headerlink" title="splitChunks拆包"></a>splitChunks拆包</h3><ul>
<li>Webpack4之SplitChunksPlugin</li>
<li>Webpack3的CommonsChunkPlugin（已废弃）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自己项目的配置</span></span><br><span class="line">&#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,<span class="comment">//分离后的最小块文件大小，单位为字节</span></span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,<span class="comment">//分离前，该块被引入的次数（也就是某个js文件通过import或require引入的次数）</span></span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,<span class="comment">//内层文件（第二层）按需加载时最大的并行加载数量</span></span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,<span class="comment">//一个入口文件可以并行加载的最大文件数量</span></span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,<span class="comment">//修改上文中的 “~” ,  若改为： “-” 则分离后的js默认命名规则为 [来源]-[入口的key值].js</span></span><br><span class="line">      name: <span class="literal">true</span>,<span class="comment">//用以控制分离后代码块的命名，当存在匹配的缓存组（后面会说到）时，命名使用缓存组中的name值，若不存在则为  [来源]~[入口的key值].js  的格式</span></span><br><span class="line">      cacheGroups: &#123;<span class="comment">//名字叫做缓存组，其实就是存放分离代码块的规则的对象，叫做cacheGroup的原因是webpack会将规则放置在cache流中，为对应的块文件匹配对应的流，从而生成分离后的块。</span></span><br><span class="line">      <span class="comment">// 抽取所有CSS为一个文件</span></span><br><span class="line">      <span class="comment">// https://webpack.js.org/plugins/mini-css-extract-plugin/#extracting-all-css-in-a-single-file</span></span><br><span class="line">      styles: &#123; <span class="attr">name</span>: <span class="string">'styles'</span>, <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">chunks</span>: <span class="string">'all'</span>, <span class="attr">enforce</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 第三方组件</span></span><br><span class="line">      common: &#123;</span><br><span class="line">        name: <span class="string">'common'</span>,</span><br><span class="line">        chunks: <span class="string">'all'</span>,<span class="comment">//chunks :匹配的块的类型：initial（初始块），async（按需加载的异步块），all（所有块）</span></span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/](react|react-dom|react-router|react-router-dom)[\\/]/</span>,</span><br><span class="line">        priority: <span class="number">10</span>,</span><br><span class="line">        enforce: <span class="literal">true</span>,</span><br><span class="line">        reuseExistingChunk: <span class="literal">true</span> <span class="comment">// 可设置是否重用该chunk</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 指定组件</span></span><br><span class="line">      antd: &#123;</span><br><span class="line">        name: <span class="string">'antd'</span>,</span><br><span class="line">        chunks: <span class="string">'all'</span>,</span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/](@ant-design|antd)[\\/]/</span>,</span><br><span class="line">        priority: <span class="number">-10</span>,</span><br><span class="line">        enforce: <span class="literal">true</span>,</span><br><span class="line">        reuseExistingChunk: <span class="literal">true</span> <span class="comment">// 可设置是否重用该chunk</span></span><br><span class="line">      &#125;,</span><br><span class="line">      excel: &#123;</span><br><span class="line">        name: <span class="string">'excel'</span>,</span><br><span class="line">        chunks: <span class="string">'all'</span>,</span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/](js-export-excel)[\\/]/</span>,</span><br><span class="line">        priority: <span class="number">-20</span>,</span><br><span class="line">        enforce: <span class="literal">true</span>,</span><br><span class="line">        reuseExistingChunk: <span class="literal">true</span> <span class="comment">// 可设置是否重用该chunk</span></span><br><span class="line">      &#125;,</span><br><span class="line">       echarts: &#123;</span><br><span class="line">          name: <span class="string">'echarts'</span>,</span><br><span class="line">          chunks: <span class="string">'async'</span>,  <span class="comment">//设置异步导入，什么时候用什么时候导入</span></span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/](echarts|echarts-for-react)[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">80</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span> <span class="comment">// 可设置是否重用该chunk</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    runtimeChunk: &#123;</span><br><span class="line">        name: <span class="string">"manifest"</span>  <span class="comment">//用于管理被分出来的包，优化持久化缓存的,如果不设置这个的话，一旦代码有变动的话，main.js的hash就会发生变化,</span></span><br><span class="line">        <span class="comment">// optimization.runtimeChunk 就是告诉 webpack 是否要把这变化的部分单独打包出来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义全局变量-DefinePlugin"><a href="#定义全局变量-DefinePlugin" class="headerlink" title="定义全局变量(DefinePlugin)"></a>定义全局变量(DefinePlugin)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eslint 设置通过</span></span><br><span class="line"> <span class="string">"globals"</span>: &#123;</span><br><span class="line">     <span class="string">"ENV"</span>: <span class="literal">true</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">     <span class="comment">//必须 JSON.stringify()，然后在eslint里面，global()通过一下</span></span><br><span class="line">    ENV: <span class="built_in">JSON</span>.stringify(process.env.ENV), <span class="comment">// 执行环境</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>

<h3 id="webpack代理"><a href="#webpack代理" class="headerlink" title="webpack代理"></a>webpack代理</h3><ul>
<li>webpack-dev-server<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在配置文件webpackDevServer.config.js添加，</span></span><br><span class="line"><span class="comment">//新版本直接在package.json 里面添加，但是只能添加一个并且是字符串，也可在src下添加setupProxy.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">    app.use(</span><br><span class="line">        proxy(<span class="string">"/pic"</span>, &#123;</span><br><span class="line">            <span class="string">"target"</span>: <span class="string">"http://120.79.229.197:9000"</span>,</span><br><span class="line">            <span class="string">"changeOrigin"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"secure"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"pathRewrite"</span>: &#123;<span class="string">"^/pic"</span>: <span class="string">""</span>&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">    app.use(</span><br><span class="line">        proxy(<span class="string">"/self"</span>, &#123;</span><br><span class="line">            <span class="string">"target"</span>: <span class="string">"http://localhost:9999"</span>,</span><br><span class="line">            <span class="string">"changeOrigin"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"secure"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"pathRewrite"</span>: &#123;<span class="string">"^/self"</span>: <span class="string">""</span>&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新的版本已经支持在package.json里面直接修改</span></span><br><span class="line">&#123;&#123;</span><br><span class="line">   <span class="string">"presets"</span>: [</span><br><span class="line">     [</span><br><span class="line">     <span class="string">"@babel/preset-env"</span>, &#123;</span><br><span class="line">       <span class="string">"targets"</span>: &#123;</span><br><span class="line">         <span class="string">"chrome"</span>: <span class="number">58</span>,</span><br><span class="line">         <span class="string">"ie"</span>: <span class="number">11</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   ], <span class="string">"react-app"</span>],</span><br><span class="line">   <span class="string">"plugins"</span>: [</span><br><span class="line">     [<span class="string">"import"</span>, &#123;</span><br><span class="line">         <span class="string">"libraryName"</span>: <span class="string">"antd"</span>,</span><br><span class="line">         <span class="string">"libraryDirectory"</span>: <span class="string">"es"</span>,</span><br><span class="line">         <span class="string">"style"</span>: <span class="string">"css"</span></span><br><span class="line">       &#125;</span><br><span class="line">     ],</span><br><span class="line">     [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="string">"legacy"</span>: <span class="literal">true</span> &#125;],  <span class="comment">//用于转换装饰器代码的插件。</span></span><br><span class="line">     [</span><br><span class="line">       <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="string">"absoluteRuntime"</span>: <span class="literal">false</span>,</span><br><span class="line">         <span class="string">"corejs"</span>: <span class="number">2</span>,</span><br><span class="line">         <span class="string">"helpers"</span>: <span class="literal">true</span>,</span><br><span class="line">         <span class="string">"regenerator"</span>: <span class="literal">true</span>,</span><br><span class="line">         <span class="string">"useESModules"</span>: <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"env"</span>: &#123;</span><br><span class="line">     <span class="string">"production"</span>: &#123;</span><br><span class="line">       <span class="string">"plugins"</span>:  [<span class="string">"transform-remove-console"</span>]</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="env"><a href="#env" class="headerlink" title=".env"></a>.env</h3><p>定义一些环境变量，可以通过process.env.[name]拿取出来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GENERATE_SOURCEMAP=<span class="literal">false</span>  <span class="comment">//禁止输出.map文件</span></span><br></pre></td></tr></table></figure>

<h3 id="优化输出的文件"><a href="#优化输出的文件" class="headerlink" title="优化输出的文件"></a>优化输出的文件</h3><p><code>taro为例</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* hash:hash是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的hash值都会更改</span></span><br><span class="line"><span class="comment">* 采用hash计算的话，每一次构建后生成的哈希值都不一样，即使文件内容压根没有改变。这样子是没办法实现缓存效果，我们需要换另一种哈希值计算方式，即chunkhash。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* chunkhash:根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。</span></span><br><span class="line"><span class="comment">* 我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* filename:决定了entry入口文件输出文件的名称。 (main.js)</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* chunkFilename:决定了非入口(non-entry) chunk 文件的名称,比如按需加载（异步）模块的时候 (组件打包的js)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//js文件的输出</span></span><br><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'js/[name].[hash:8].js'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'js/[name].[chunkhash:8].js'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//css文件的输出</span></span><br><span class="line">miniCssExtractPluginOption: &#123;</span><br><span class="line">    filename: <span class="string">'css/[name].[hash:8].css'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'css/[name].[chunkhash:8].css'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//img文件的输出</span></span><br><span class="line">imageUrlLoaderOption: &#123;</span><br><span class="line">    limit: <span class="number">1024</span>*<span class="number">50</span>,</span><br><span class="line">    name: <span class="string">'static/images/[name].[hash:8].[ext]'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="webpack对图片做了什了？（面试题）"><a href="#webpack对图片做了什了？（面试题）" class="headerlink" title="webpack对图片做了什了？（面试题）"></a>webpack对图片做了什了？（面试题）</h3><p><strong>url-loader：</strong> 如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl(base64)。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy</p>
<p><strong>file-loader：</strong>  解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。</p>
<p><strong>image-webpack-loader：</strong>  对图片进行压缩和优化</p>
<p><a href="https://github.com/tcoopman/image-webpack-loader" target="_blank" rel="noopener">image-webpack-loader</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test: [<span class="regexp">/\.bmp$/</span>, /\.gif$/, /\.jpe?g$/, /\.png$/],</span><br><span class="line"></span><br><span class="line"><span class="comment">// options: &#123;</span></span><br><span class="line"><span class="comment">//     limit: 10000,</span></span><br><span class="line"><span class="comment">//     name: 'static/media/[name].[hash:8].[ext]',</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line">use: [</span><br><span class="line">    &#123;</span><br><span class="line">        loader: <span class="built_in">require</span>.resolve(<span class="string">'url-loader'</span>),</span><br><span class="line">        options:</span><br><span class="line">            &#123; <span class="comment">// 这里的options选项参数可以定义多大的图片转换为base64</span></span><br><span class="line">                name: <span class="string">'static/images/[name].[hash:8].[ext]'</span>,</span><br><span class="line">                limit: <span class="number">1024</span> * <span class="number">50</span>, <span class="comment">// 表示小于50kb的图片转为base64,大于50kb的是路径</span></span><br><span class="line">                <span class="comment">// outputPath: 'images' //定义输出的图片文件夹</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// &#123;    //压缩图片要在file-loader之后使用</span></span><br><span class="line">    <span class="comment">//     loader: require.resolve('image-webpack-loader'),</span></span><br><span class="line">    <span class="comment">//     options:</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             bypassOnDebug: true</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="webpack用到的插件"><a href="#webpack用到的插件" class="headerlink" title="webpack用到的插件"></a>webpack用到的插件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">webpack-dev-server  <span class="comment">//热更新</span></span><br><span class="line">clean-webpack-plugin   <span class="comment">//在打包输出前清空文件夹</span></span><br><span class="line">mini-css-extract-plugin <span class="comment">//拆分css</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">new MiniCssExtractPlugin(&#123;</span></span><br><span class="line"><span class="comment"> filename: 'static/css/[name].[contenthash:8].css',</span></span><br><span class="line"><span class="comment"> chunkFilename: 'static/css/[name].[contenthash:8].chunk.css',</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">extract-text-webpack-plugin@next <span class="comment">//拆分多个css</span></span><br><span class="line">terser-webpack-plugin/uglifyjs-webpack-plugin  <span class="comment">//压缩js 解决uglifyjs不支持es6语法问题</span></span><br><span class="line">optimize-css-assets-webpack-plugin <span class="comment">//最大化压缩css</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image-webpack-loader  <span class="comment">//图片压缩</span></span><br><span class="line">webpackbar  <span class="comment">//进度条</span></span><br><span class="line">@babel/plugin-proposal-decorators(transform-decorators-legacy 基于babel6)   <span class="comment">//装饰器</span></span><br><span class="line">redux-devtools-extension  <span class="comment">//配置redux工具</span></span><br><span class="line">babel-plugin-transform-remove-<span class="built_in">console</span>  <span class="comment">//生产环境清除控制台的内容</span></span><br><span class="line">webpack-bundle-analyzer  <span class="comment">//打包体积优化</span></span><br><span class="line">happyPack <span class="comment">//多进程打包，加快打包速度。</span></span><br><span class="line">postcss-loader  <span class="comment">//css编译的工具</span></span><br><span class="line">postcss-preset-env <span class="comment">//将现代CSS转换成浏览器能理解的东西,无需再安装autoprefixer</span></span><br><span class="line">postcss-flexbugs-fixes <span class="comment">//修复Flexbugs</span></span><br><span class="line">postcss-px-to-viewport <span class="comment">//把px转换成viewport单位</span></span><br><span class="line">postcss-pxtorem <span class="comment">//把px转换成rem</span></span><br></pre></td></tr></table></figure>

<h3 id="require-context是什么"><a href="#require-context是什么" class="headerlink" title="require.context是什么"></a>require.context是什么</h3><p>一个webpack的api,通过执行<code>require.context</code>函数获取一个特定的上下文,主要用来实现自动化导入模块,在前端工程中,如果遇到从一个文件夹引入很多模块的情况,可以使用这个api,它会遍历文件夹中的指定文件,然后自动导入,使得不需要每次显式的调用import导入模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">'./getters'</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> files = <span class="built_in">require</span>.context(<span class="string">'./modules'</span>, <span class="literal">false</span>, /\.js$/)</span><br><span class="line"><span class="comment">// files.keys() 获取所有的文件目录，不带后缀</span></span><br><span class="line"><span class="keyword">let</span> modules = &#123;&#125;</span><br><span class="line">files.keys().forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name = path.basename(key, <span class="string">'.js'</span>)</span><br><span class="line">    modules[name] = files(key).default || files(key) <span class="comment">// 获取所有的内容</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules,</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Webpack</category>
        <category>Webpack的使用</category>
      </categories>
  </entry>
  <entry>
    <title>Webpack4 配置详解</title>
    <url>/2019/01/10/workspace/Webpack/webpack/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Webpack4 配置详解</strong></p>
<p>[[toc]]</p>
<p>Webpack4后包拆成webpack和webpack-cli两个包：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装webpack</span></span><br><span class="line">npm install --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure>

<p> 主要有以下这些一级配置：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>, <span class="comment">// 模式配置,webpack4.0新增</span></span><br><span class="line">    entry: <span class="string">''</span>, <span class="comment">// 入口文件</span></span><br><span class="line">    output: &#123;&#125;, <span class="comment">// 出口文件</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [<span class="comment">/*loader setting*/</span>]</span><br><span class="line">    &#125;, <span class="comment">// 配置modules，包括loader</span></span><br><span class="line">    plugins: [], <span class="comment">// 对应的插件</span></span><br><span class="line">    devServer: &#123;&#125;, <span class="comment">// 开发服务器配置</span></span><br><span class="line">    optimization: &#123;&#125;, <span class="comment">// 最佳实践</span></span><br><span class="line">    devtool: <span class="string">''</span>,</span><br><span class="line">    resolve: &#123; <span class="attr">alias</span>: &#123;&#125;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-mode"><a href="#1-mode" class="headerlink" title="1. mode"></a>1. mode</h3><p> Webpack 4 引入了 mode 这个选项。这个选项的值可以是 development 或者 production。</p>
<p> 设置了 mode 之后会把 process.env.NODE_ENV 也设置为 development 或者 production。然后在 production 模式下，会默认开启 UglifyJsPlugin 等一堆插件。</p>
<ul>
<li><p>webpack4支持ES6的方式导入JSON文件，并且支持Tree-shaking (通过工具”摇”我们的JS文件，将其中用不到的代码”摇”掉，是一个性能优化的范畴)</p>
<h3 id="2-entry-amp-output"><a href="#2-entry-amp-output" class="headerlink" title="2. entry &amp; output"></a>2. entry &amp; output</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let path &#x3D; require(&#39;path&#39;);</span><br><span class="line">let HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 1.写成数组的方式就可以打出多入口文件，不过这里打包后的文件都合成了一个</span><br><span class="line">    &#x2F;&#x2F; entry: [&#39;.&#x2F;src&#x2F;index.js&#39;, &#39;.&#x2F;src&#x2F;login.js&#39;],</span><br><span class="line">    &#x2F;&#x2F; 2.真正实现多入口和多出口需要写成对象的方式</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: path.resolve(__dirname,&#39;.&#x2F;src&#x2F;index.js&#39;),</span><br><span class="line">        login: path.resolve(__dirname,&#39;.&#x2F;src&#x2F;login.js&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. filename: &#39;bundle.js&#39;, &#39;bundle.[hash:4].js&#39;,   </span><br><span class="line">        &#x2F;&#x2F; 2. [name]就可以将出口文件名和入口文件名一一对应</span><br><span class="line">        filename: &#39;[name].[hash:8].js&#39;,      &#x2F;&#x2F; 打包后会生成index.313eerrd.js和login.dsfcersx.js文件</span><br><span class="line">        path: path.resolve(__dirname,&#39;..&#x2F;dist&#39;)   &#x2F;&#x2F;打包后的目录</span><br><span class="line">    &#125;,</span><br><span class="line">     plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: path.resolve(__dirname,&#39;.&#x2F;public&#x2F;index.html&#39;),   &#x2F;&#x2F; 用哪个html作为模板 , react一般在在src目录下public里创建一个index.html页面当做模板来用</span><br><span class="line">            filename: &#39;index.html&#39;, &#x2F;&#x2F;  要打包输出的文件名</span><br><span class="line">            chunks: [&#39;manifest&#39;,&#39;index&#39;]   &#x2F;&#x2F; 对应关系,index.js对应的是index.html</span><br><span class="line">        &#125;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: path.resolve(__dirname,&#39;.&#x2F;public&#x2F;login.html&#39;),</span><br><span class="line">            filename: &#39;login.html&#39;, </span><br><span class="line">            chunks: [&#39;manifest&#39;,&#39;login&#39;]   &#x2F;&#x2F; 对应关系,login.js对应的是login.html</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-mudule-rules-配置"><a href="#3-mudule-rules-配置" class="headerlink" title="3. mudule - rules 配置"></a>3. mudule - rules 配置</h3><p> webpack4中移除loaders配置，必须使用rules。rules 配置模块的读取和解析规则， 通常用来配置loader， 其类型是一个数组， 数组里每一项都描述了如何去处理部分文件。</p>
<p> 配置一项rules大致通过以下方式：</p>
<ol>
<li><p>条件匹配： 通过test、include、exclude三个配置来命中Loader要应用的规则文件。(三个配置都可以是正则，也支持数组)</p>
</li>
<li><p>应用规则： 对选中后的文件通过use配置项来应用loader，可以应用一个loader或者按照从后往前的顺序应用一组loader。同时还可以分别给loader传入参数。</p>
</li>
<li><p>重置顺序： 一组loader的执行顺序默认是从右到左执行，通过exforce选项可以让其中一个loader的执行顺序放到最前或者是最后。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,     <span class="comment">// 解析css</span></span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] <span class="comment">// 从右向左解析</span></span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                    也可以这样写，这种方式方便写一些配置参数</span></span><br><span class="line"><span class="comment">                    use: [</span></span><br><span class="line"><span class="comment">                        &#123;loader: 'style-loader'&#125;,</span></span><br><span class="line"><span class="comment">                        &#123;</span></span><br><span class="line"><span class="comment">                            loader: require.resolve('postcss-loader'),   //这里是加上浏览器的前缀</span></span><br><span class="line"><span class="comment">                            options: &#123;</span></span><br><span class="line"><span class="comment">                                ident: 'postcss',</span></span><br><span class="line"><span class="comment">                                plugins: () =&gt; [</span></span><br><span class="line"><span class="comment">                                    require('postcss-flexbugs-fixes'), //修复Flexbugs</span></span><br><span class="line"><span class="comment">                                    require('postcss-preset-env')(&#123; //postcss-preset-env包括autoprefixer</span></span><br><span class="line"><span class="comment">                                        autoprefixer: &#123;</span></span><br><span class="line"><span class="comment">                                            flexbox: 'no-2009',</span></span><br><span class="line"><span class="comment">                                        &#125;,</span></span><br><span class="line"><span class="comment">                                        stage: 3,</span></span><br><span class="line"><span class="comment">                                    &#125;),</span></span><br><span class="line"><span class="comment">                                ]</span></span><br><span class="line"><span class="comment">                            &#125;,</span></span><br><span class="line"><span class="comment">                       &#125;</span></span><br><span class="line"><span class="comment">                    ]</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-optimization"><a href="#4-optimization" class="headerlink" title="4. optimization"></a>4. optimization</h3><p>在Webpack4中引入，根据mode（production/development）的不同，配置项默认值不同，具体有以下：</p>
</li>
<li><p><strong>optimization.minimize</strong>： 是否自动压缩打包后的代码。mode = production时，为true。<br>压缩默认使用<code>terser-webpack-plugin</code>插件(更加兼容ES6)，如果想要使用别的压缩插件，可以使用<code>optimization.minimizer</code>设置。</p>
</li>
<li><p><strong>optimization.splitChunks</strong>: 根据不同的策略来分割打包出来的bundle。配置基于<a href="https://webpack.js.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener">SplitChunksPlugin</a>,剔除了老的<code>CommonsChunkPlugin</code>（webpack4移除）。</p>
</li>
<li><p>零配置</p>
<ul>
<li><strong>optimization.nodeEnv</strong>: 告诉webpack process.env.NODE_ENV的值，值来自于mode的取值。代替<a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noopener">webpack.DefinePlugin</a></li>
<li><strong>optimization.namedModules</strong>: 代替webpack.NamedModulesPlugin（webpack4移除）  <code>给模块有意义的名称代替ids</code></li>
<li><strong>optimization.noEmitOnErrors</strong>: 代替webpack.NoEmitOnErrorsPlugin（webpack4移除） <code>编译错误时不写入到输出</code></li>
<li><strong>optimization.concatenateModules</strong>: 代替webpack.optimize.ModuleConcatenationPlugin（webpack4移除） <code>尝试查找模块图中可以安全连接到单个模块中的段。- -</code></li>
</ul>
</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000013712229?utm_source=index-hottest" target="_blank" rel="noopener">默认配置</a></p>
<h3 id="5-plugins"><a href="#5-plugins" class="headerlink" title="5. plugins"></a>5. plugins</h3><ul>
<li>常用插件<ol>
<li><code>HtmlWebpackPlugin</code> 自动在html中加载打包后的js文件</li>
<li><code>DLLPlugin/DllReferencePlugin</code> 提高打包速度<ul>
<li>DLLPlugin：创建一个只有dll的bundle</li>
<li>DllReferencePlugin： 打包生成的dll文件引用到需要的预编译依赖上来</li>
</ul>
</li>
<li>happyPack 多进程打包，加快打包速度。</li>
<li><code>webpack.DefinePlugin</code> webpack4设置mode会自动使用</li>
<li><code>uglifyjs-webpack-plugin</code> webpack4 mode = production默认使用</li>
<li>WebpackBar</li>
<li>webpack-bundle-analyzer</li>
<li>clean-webpack-plugin  清除dist文件夹里会残留上次打包的文件</li>
</ol>
</li>
<li>废弃插件<br>ExtractTextWebpackPlugin 拆分css样式的插件(webapck4已废弃)。由于webpack4以后对css模块支持的逐步完善和commonchunk插件的移除，<br>在处理css文件提取的计算方式上也做了些调整，之前我们首选使用的extract-text-webpack-plugin也完成了其历史使命，<br>将让位于<a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a>。</li>
</ul>
<h3 id="6-devServer"><a href="#6-devServer" class="headerlink" title="6. devServer"></a>6. devServer</h3><p> webpack的devServer配置基于webpack-dev-server集成的插件。该插件提供了proxy代理配置，基于express中间件 http-proxy-middleware实现，该中间件又基于node http-proxy,</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    <span class="comment">// 提供静态文件目录地址</span></span><br><span class="line">    <span class="comment">// 基于express.static实现</span></span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    <span class="comment">// 任意的 404 响应都被替代为 index.html</span></span><br><span class="line">    <span class="comment">// 基于node connect-history-api-fallback包实现</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否一切服务都启用 gzip 压缩</span></span><br><span class="line">    <span class="comment">// 基于node compression包实现</span></span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否隐藏bundle信息</span></span><br><span class="line">    noInfo: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 发生错误是否覆盖在页面上</span></span><br><span class="line">    overlay: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否开启热加载</span></span><br><span class="line">    <span class="comment">// 必须搭配webpack.HotModuleReplacementPlugin 才能完全启用 HMR。</span></span><br><span class="line">    <span class="comment">// 如果 webpack 或 webpack-dev-server 是通过 --hot 选项启动的，那么这个插件会被自动添加</span></span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 热加载模式</span></span><br><span class="line">    <span class="comment">// true代表inline模式，false代表iframe模式</span></span><br><span class="line">    inline: <span class="literal">true</span>, <span class="comment">// 默认是true</span></span><br><span class="line">    <span class="comment">// 是否自动打开</span></span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 设置本地url和端口号</span></span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    <span class="comment">// 代理</span></span><br><span class="line">    <span class="comment">// 基于node http-proxy-middleware包实现</span></span><br><span class="line">    proxy: &#123;</span><br><span class="line">        <span class="comment">// 匹配api前缀时，则代理到3001端口</span></span><br><span class="line">        <span class="comment">// 即http://localhost:8080/api/123 = http://localhost:3001/api/123</span></span><br><span class="line">        <span class="comment">// 注意:这里是把当前server8080代理到3001，而不是任意端口的api代理到3001</span></span><br><span class="line">        <span class="string">'/api'</span>: <span class="string">'http://localhost:3001'</span>,</span><br><span class="line">        <span class="comment">// 设置为true, 本地就会虚拟一个服务器接收你的请求并代你发送该请求</span></span><br><span class="line">        <span class="comment">// 主要解决跨域问题</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 针对代理https</span></span><br><span class="line">        secure: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 覆写路径：http://localhost:8080/api/123 = http://localhost:3001/123</span></span><br><span class="line">        pathRewrite: &#123;<span class="string">'^/api'</span> : <span class="string">''</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 举个完整例子：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line">&#x2F;&#x2F; 插件都是一个类，所以我们命名的时候尽量用大写开头</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;); &#x2F;&#x2F;打包html</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&quot;mini-css-extract-plugin&quot;); &#x2F;&#x2F; 提取出来css</span><br><span class="line">const UglifyJsPlugin &#x3D; require(&#39;uglifyjs-webpack-plugin&#39;); &#x2F;&#x2F; 压缩打包后的js </span><br><span class="line">const HappyPack &#x3D; require(&#39;happypack&#39;); &#x2F;&#x2F; 多线程构建</span><br><span class="line">const happyThreadPool &#x3D; HappyPack.ThreadPool(&#123; size: 5 &#125;);  &#x2F;&#x2F; 构造出共享进程池，进程池中包含5个子进程</span><br><span class="line">const OptimizeCssAssetsPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;)&#x2F;&#x2F; 最大化压缩css</span><br><span class="line"></span><br><span class="line">console.log(&#39;process.env.NODE_ENV-------&gt;&#39;,  process.env.NODE_ENV)</span><br><span class="line">&#x2F;&#x2F; 解决css 分离后图片引入路径不正确问题</span><br><span class="line">if (process.env.type &#x3D;&#x3D; &#39;build&#39;) &#123; &#x2F;&#x2F; 判断package.json里面是build还是dev命令</span><br><span class="line">    &#x2F;&#x2F; 开发</span><br><span class="line">    var website &#x3D;&#123;</span><br><span class="line">        publicPath:&quot;&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 生产</span><br><span class="line">    var website &#x3D;&#123;</span><br><span class="line">        publicPath:&quot;&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; devtool:&#39;eval-source-map&#39;,</span><br><span class="line">    mode: &#39;development&#39;, &#x2F;&#x2F; 模式配置</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">    &#125;,             </span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &#39;bundle.[chunkhash:6].js&#39;,</span><br><span class="line">        path: path.resolve(__dirname, &#39;dist&#39;),</span><br><span class="line">        publicPath: website.publicPath, &#x2F;&#x2F; 解决css 分离后图片引入路径不正确问题</span><br><span class="line">    &#125;,             </span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.css&#x2F;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">                use: [&#39;style-loader&#39;, MiniCssExtractPlugin.loader,&#x2F;&#x2F;拆分css [对应109-112行]</span><br><span class="line">                &#123;</span><br><span class="line">                      loader: require.resolve(&#39;postcss-loader&#39;),   &#x2F;&#x2F;这里是加上浏览器的前缀</span><br><span class="line">                      options: &#123;</span><br><span class="line">                          ident: &#39;postcss&#39;,</span><br><span class="line">                          plugins: () &#x3D;&gt; [</span><br><span class="line">                              require(&#39;postcss-flexbugs-fixes&#39;), &#x2F;&#x2F;修复Flexbugs</span><br><span class="line">                              require(&#39;postcss-preset-env&#39;)(&#123; &#x2F;&#x2F;postcss-preset-env包括autoprefixer</span><br><span class="line">                                  autoprefixer: &#123;</span><br><span class="line">                                      flexbox: &#39;no-2009&#39;,</span><br><span class="line">                                  &#125;,</span><br><span class="line">                                  stage: 3,</span><br><span class="line">                              &#125;),</span><br><span class="line">                          ]</span><br><span class="line">                      &#125;,</span><br><span class="line">                 &#125;, </span><br><span class="line">                 &#39;css-loader&#39;],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.less$&#x2F;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">                use: [&#39;style-loader&#39;, MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;less-loader&#39;],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.(png|jpe?g|gif|svg)$&#x2F;,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &#39;url-loader&#39;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: 10000,</span><br><span class="line">                            name: &#39;[name]_[hash:7].[ext]&#39;, </span><br><span class="line">                            outputPath:&#39;static&#x2F;images&#x2F;&#39;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.(htm|html)$&#x2F;,</span><br><span class="line">                use: &#39;html-withimg-loader&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#x2F;&#x2F; babel 解析es7 es6 jsx</span><br><span class="line">            &#123;</span><br><span class="line">                test:&#x2F;\.(jsx|js)$&#x2F;,</span><br><span class="line">                include: [ </span><br><span class="line">                    path.resolve(__dirname, &#39;src&#39;),</span><br><span class="line">                ],</span><br><span class="line">                use:[&#39;babel-loader&#39;],</span><br><span class="line">                &#x2F;*</span><br><span class="line">                    如果开启多线程进行构建</span><br><span class="line">                    use:[&#39;happypack&#x2F;loader?id&#x3D;js&#39;], </span><br><span class="line">                    loader这样写 匹配下面注释的插件</span><br><span class="line">                *&#x2F;</span><br><span class="line">                exclude:&#x2F;node_modules&#x2F;</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,              </span><br><span class="line">    plugins: [</span><br><span class="line">        &#x2F;&#x2F; 打包html</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &#39;.&#x2F;src&#x2F;index.html&#39;,</span><br><span class="line">            hash: true,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                minifyCSS: true,</span><br><span class="line">                minifyJS: true, </span><br><span class="line">                removeAttributeQuotes: true</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: &quot;static&#x2F;css&#x2F;[name].[chunkhash:8].css&quot;,</span><br><span class="line">            chunkFilename: &quot;[id].css&quot;</span><br><span class="line">        &#125;),</span><br><span class="line">        new UglifyJsPlugin(&#123;</span><br><span class="line">            parallel: true, </span><br><span class="line">        &#125;),</span><br><span class="line">        new webpack.DefinePlugin(&#123;</span><br><span class="line">            NODE_ENV: JSON.stringify(&#39;DEV&#39;)</span><br><span class="line">        &#125;),</span><br><span class="line">        &#x2F;&#x2F; 多线程构建 匹配上面的loader</span><br><span class="line">        &#x2F;&#x2F; new HappyPack(&#123;</span><br><span class="line">        &#x2F;&#x2F;     id: &#39;js&#39;,</span><br><span class="line">        &#x2F;&#x2F;     &#x2F;&#x2F;threads: 4,</span><br><span class="line">        &#x2F;&#x2F;     loaders: [&#39;babel-loader&#39;],</span><br><span class="line">        &#x2F;&#x2F;     threadPool: happyThreadPool, &#x2F;&#x2F; 使用共享进程池中的子进程去处理任务</span><br><span class="line">        &#x2F;&#x2F; &#125;),</span><br><span class="line">        &#39;postcss-px-to-viewport&#39;: &#123;</span><br><span class="line">           viewportWidth: 750,   &#x2F;&#x2F; 视窗的宽度，对应的是我们设计稿的宽度，一般是750</span><br><span class="line">           viewportHeight: 1334, &#x2F;&#x2F; 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置</span><br><span class="line">           unitPrecision: 3,     &#x2F;&#x2F; 指定&#96;px&#96;转换为视窗单位值的小数位数</span><br><span class="line">           viewportUnit: &quot;vw&quot;,   &#x2F;&#x2F;指定需要转换成的视窗单位，建议使用vw</span><br><span class="line">           selectorBlackList: [&#39;.ignore&#39;],&#x2F;&#x2F; 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名</span><br><span class="line">           minPixelValue: 1,     &#x2F;&#x2F; 小于或等于&#96;1px&#96;不转换为视窗单位，你也可以设置为你想要的值</span><br><span class="line">           mediaQuery: false     &#x2F;&#x2F; 允许在媒体查询中转换&#96;px&#96;</span><br><span class="line">        &#125;   </span><br><span class="line">    ],   </span><br><span class="line">    &#x2F;&#x2F; 提取公共代码</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">           &#x2F;&#x2F; 自定义js优化配置，将会覆盖默认配置 最大化压缩成js</span><br><span class="line">            new UglifyJsPlugin(&#123;</span><br><span class="line">                exclude: &#x2F;\.min\.js$&#x2F;, &#x2F;&#x2F; 过滤掉以&quot;.min.js&quot;结尾的文件，我们认为这个后缀本身就是已经压缩好的代码，没必要进行二次压缩</span><br><span class="line">                cache: true,</span><br><span class="line">                parallel: true, &#x2F;&#x2F; 开启并行压缩，充分利用cpu</span><br><span class="line">                sourceMap: false,</span><br><span class="line">                extractComments: false, &#x2F;&#x2F; 移除注释</span><br><span class="line">                uglifyOptions: &#123;</span><br><span class="line">                  compress: &#123;</span><br><span class="line">                    unused: true,</span><br><span class="line">                    warnings: false,</span><br><span class="line">                    drop_debugger: true</span><br><span class="line">                  &#125;,</span><br><span class="line">                  output: &#123;</span><br><span class="line">                    comments: false</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;),</span><br><span class="line">            &#x2F;&#x2F; 用于优化css文件 最大化压缩成css 并且去掉注释掉的css</span><br><span class="line">            new OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">                assetNameRegExp: &#x2F;\.css$&#x2F;g,</span><br><span class="line">                cssProcessorOptions: &#123;</span><br><span class="line">                  safe: true,</span><br><span class="line">                  autoprefixer: &#123; disable: true &#125;,</span><br><span class="line">                  mergeLonghand: false,</span><br><span class="line">                  discardComments: &#123;</span><br><span class="line">                    removeAll: true &#x2F;&#x2F; 移除注释</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                canPrint: true</span><br><span class="line">            &#125;)</span><br><span class="line">           ],</span><br><span class="line">            splitChunks: &#123;</span><br><span class="line">                cacheGroups: &#123;</span><br><span class="line">                vendor: &#123;   &#x2F;&#x2F; 抽离第三方插件</span><br><span class="line">                    test: &#x2F;node_modules&#x2F;,   &#x2F;&#x2F; 指定是node_modules下的第三方包</span><br><span class="line">                    chunks: &#39;initial&#39;,</span><br><span class="line">                    name: &#39;vendor&#39;,  &#x2F;&#x2F; 打包后的文件名，任意命名    </span><br><span class="line">                    &#x2F;&#x2F; 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包</span><br><span class="line">                    priority: 10    </span><br><span class="line">                &#125;,</span><br><span class="line">                &#x2F;&#x2F; utils: &#123; &#x2F;&#x2F; 抽离自己写的公共代码，utils这个名字可以随意起 (css&#x2F;js公用的都会单独抽离出来生成一个单独的文件)</span><br><span class="line">                &#x2F;&#x2F;     chunks: &#39;initial&#39;,</span><br><span class="line">                &#x2F;&#x2F;     name: &#39;utils&#39;,  &#x2F;&#x2F; 任意命名</span><br><span class="line">                &#x2F;&#x2F;     minSize: 0    &#x2F;&#x2F; 只要超出0字节就生成一个新包</span><br><span class="line">                &#x2F;&#x2F; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,        </span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: true,</span><br><span class="line">        inline: true</span><br><span class="line">    &#125;,   </span><br><span class="line">    &#x2F;&#x2F; externals: &#123;</span><br><span class="line">    &#x2F;&#x2F;     jquery: &quot;jQuery&quot;,</span><br><span class="line">    &#x2F;&#x2F; &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        &#x2F;&#x2F; alias 别名配置，它能够将导入语句里的关键字替换成你需要的路径</span><br><span class="line">        alias: &#123;</span><br><span class="line">            &#x2F;&#x2F; 比如我们就可以直接写 import Nav from &#39;@&#x2F;Nav&#39;</span><br><span class="line">            &#39;@&#39;: &#39;.&#x2F;app&#x2F;component&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 省略后缀</span><br><span class="line">        extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.less&#39;, &#39;.json&#39;, &#39;.css&#39;],</span><br><span class="line">    &#125;,     </span><br><span class="line">    performance: &#123;</span><br><span class="line">        hints: false &#x2F;&#x2F; 选项可以控制 webpack 如何通知「资源(asset)和入口起点超过指定文件限制」</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><p><a href="https://juejin.im/post/5de87444518825124c50cd36?utm_source=gold_browser_extension" target="_blank" rel="noopener">实战</a></p>
</li>
<li><p><a href="https://webpack.js.org/configuration/optimization/" target="_blank" rel="noopener">webpack optimization</a></p>
</li>
<li><p><a href="https://dev.to/flexdinesh/upgrade-to-webpack-4---5bc5" target="_blank" rel="noopener">Upgrade to Webpack 4</a></p>
</li>
<li><p><a href="https://juejin.im/post/5b3e22e3f265da0f4b7a72df" target="_blank" rel="noopener">webpack编译速度提升之DllPlugin</a></p>
</li>
<li><p><a href="https://juejin.im/post/5abbc2ca5188257ddb0fae9b" target="_blank" rel="noopener">webpack4.0打包优化策略系列</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Webpack</category>
        <category>Webpack4 配置详解</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Git恢复上一次的修改</title>
    <url>/2019/02/11/workspace/Git/git-cherry/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Git恢复上一次的修改</strong></p>
<p>[[toc]]</p>
<h3 id="查看谁修改的代码"><a href="#查看谁修改的代码" class="headerlink" title="查看谁修改的代码"></a>查看谁修改的代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git blame</span><br><span class="line">比如多人协作的情况下线上出问题了，可以通过git blame清楚的知道是谁对文件进行了修改了。下面给出一个例子:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;(1)第一步进入到我们的本地git仓库</span><br><span class="line">git branch -a</span><br><span class="line">&#x2F;&#x2F;(2)假如我们是要查看远程的daily&#x2F;1.1.68分支的修改情况，执行下面的命令</span><br><span class="line">git checkout  remotes&#x2F;origin&#x2F;daily&#x2F;1.1.68</span><br><span class="line">&#x2F;&#x2F;(3)查看远程分支src&#x2F;pages&#x2F;item&#x2F;ItemTable&#x2F;ItemTable.js文件的修改</span><br><span class="line">git blame src&#x2F;pages&#x2F;item&#x2F;ItemTable&#x2F;ItemTable.js</span><br><span class="line">&#x2F;&#x2F;(4)此时会显示每一行代码的修改者</span><br></pre></td></tr></table></figure>

<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line"></span><br><span class="line">下面只是给出几种显示log的方式：</span><br><span class="line">&#x2F;&#x2F;压缩模式，在每个提交的旁边显示经过精简的提交哈希码和提交信息，以一行显示</span><br><span class="line">git log --oneline</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;图形模式，使用该选项会在输出的左边绘制一张基于文本格式的历史信息表示图。如果你查看的是单个分支的历史记录的话，该选项无效</span><br><span class="line">git log --graph</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示所有分支的历史记录</span><br><span class="line">git log --all</span><br></pre></td></tr></table></figure>

<h3 id="git-reset-amp-撤回回退的代码"><a href="#git-reset-amp-撤回回退的代码" class="headerlink" title="git reset &amp; 撤回回退的代码"></a>git reset &amp; 撤回回退的代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git reflog + git cherry-pick</span><br><span class="line"></span><br><span class="line">场景: 你提交了几个commit，然后用 git reset --hard 撤销了这些修改，接着你又意识到：你    希  望还原这些修改！</span><br><span class="line">    原理: git reflog 对于恢复项目历史是一个超棒的资源。你可以恢复几乎任何东西 — 任何你commit 过的东西 — 只要通过 reflog。</span><br><span class="line"></span><br><span class="line">你可能已经熟悉了 git log 命令，它*会显示commit的列表*。 git reflog 也是类似的，不过它显示的是一个*HEAD发生改变的时间列表*。</span><br><span class="line"></span><br><span class="line">一些注意事项：</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>)它涉及的只是*HEAD的改变*。在你切换分支、用git commit进行提交、以及用 git reset撤销 commit时，HEAD会改变，但当你用 git checkout -- 撤销时(只是替换文件，分支不变)，HEAD 并不会改变 — 如前所述，这些修改从来没有被提交过，因此reflog 也无法帮助我们恢复它们。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)git reflog不会永远保持。Git 会定期清理那些 “用不到的” 对象。不要指望几个月前的提交还一直躺在那里。</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)你的reflog就是你的，只是你的。你不能用 git reflog 来恢复另一个开发者没有 push 过的 commit。</span><br><span class="line"></span><br><span class="line">下面我们演示一个例子:</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)第一次修改并提交</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)第二次修改和提交</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)第三次修改和提交</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)取消第三次提交</span></span><br><span class="line">git reset --hard HEAD~<span class="number">1</span></span><br><span class="line"><span class="comment">//注意：此时运行git log会没有第三次提交的log信息，但是reflog却可以看到HEAD指针的移动历史</span></span><br><span class="line">下面我们看看git reflog的HEAD的改变历史:</span><br><span class="line"></span><br><span class="line">如果我们要恢复上一次的修改只要执行如下的命令就可以了:</span><br><span class="line"></span><br><span class="line">git cherry-pick <span class="number">52e3</span>fa6</span><br><span class="line"><span class="comment">//52e3fa6表示第三次的修改的hash</span></span><br><span class="line">此时运行了git cherry-pick之后，我们通过git log可以看到第三次的提交信息了。</span><br></pre></td></tr></table></figure>

<h3 id="Tag回退代码"><a href="#Tag回退代码" class="headerlink" title="Tag回退代码"></a>Tag回退代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m&#39;1.0.0&#39;</span><br><span class="line"></span><br><span class="line">git tag v1.0.0 &#x2F;&#x2F;打tag</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line">git push origin --tags  or git push origin v1.0.0 &#x2F;&#x2F;本地tag推送到线上</span><br><span class="line"></span><br><span class="line">git tag  &#x2F;&#x2F;查看所有的tag</span><br><span class="line"></span><br><span class="line">git tag -d v1.0.0 &#x2F;&#x2F;本地删除tag</span><br><span class="line"></span><br><span class="line">git push origin :refs&#x2F;tags&#x2F;v1.0.0  &#x2F;&#x2F;本地tag删除了，再执行该句，删除线上tag</span><br><span class="line"></span><br><span class="line">git checkout v1.0.0 &#x2F;&#x2F;切换tag,完成代码回退</span><br><span class="line"></span><br><span class="line">git show 1.0.0  or git show v1.0.0^&#123;tree&#125;&#x2F;&#x2F;查看相关信息</span><br></pre></td></tr></table></figure>

<p>::: danger 特别注意<br> 通过标签回退版本后，尽量不要改动代码，如果一定要修改代码<code>必须马上拉一个分支</code>，然后当前的主干的分支立即回到原来的位置，否则正在开发的分支可能白干了，并且不能把改动的代码合并到主干，接着在刚拉的分支上改bug,修改完毕后合并在主干上<br>:::</p>
<p><code>如果你通过标签回退版本后，立马改了当前的分支，很不幸你就成功的push不到Git上了，看提示的错误：</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#39;git pull ...&#39;) before pushing again.</span><br><span class="line">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</span><br><span class="line">&#x2F;&#x2F;更新被拒绝，因为远程包含您所做的工作,大致意思就是你之前的提交的那个库指向同一引用，且低于一个版本，要你集成远程更改</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有如下几种解决方法：</p>
</blockquote>
<p><strong>1：使用强制push的方法：</strong></p>
<p>git push -u origin [name] -f </p>
<p>太暴力，峰哥不喜欢 ，这样会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候。</p>
<p><strong>2：push前先将远程repository修改pull下来</strong></p>
<p>git pull origin [name]</p>
<p>一般会让你解决冲突，然后还要merge一堆破事,不过这个冲突总是要解决的，你就看看是你解决还是等人来解决。</p>
<p><strong>3：若不想merge远程和本地修改，可以先创建新的分支：</strong></p>
<p>git checkout -b  [name]</p>
<p>然后git push -u origin [name]  万事大吉，实在不行后期你直接 git push origin –delete [name]不留痕迹</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>VirtualDOM</title>
    <url>/2019/11/17/workspace/Frame/react/dom_diff/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>VirtualDOM</strong></p>
<p>[[toc]]</p>
<p><strong>React 的核心思想</strong></p>
<p>给我一个数据，我根据这个数据生成一个全新的<code>Virtual DOM</code>，然后跟我上一次生成的Virtual DOM去 <code>diff</code>，得到一个<code>Patch</code>，<br>然后把这个Patch打到浏览器的DOM上去。完事,并且这里的patch显然<code>不是完整的虚拟DOM</code>，<br>而是新的虚拟DOM和上一次的虚拟DOM经过<code>diff</code>后的<code>差异化</code>的部分。</p>
<h3 id="JSX和createElement"><a href="#JSX和createElement" class="headerlink" title="JSX和createElement"></a>JSX和createElement</h3><p>我们在实现一个React组件时可以选择两种编码方式，第一种是使用<code>JSX</code>编写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello hzf<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种是直接使用<code>React.createElement</code>编写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="string">'div'</span>, <span class="literal">null</span>, <span class="string">`Hello hzf`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，上面两种写法是等价的，<code>JSX只是为 React.createElement(component, props, ...children)</code>方法提供的语法糖。也就是说所有的JSX代码最后都会转换成<code>React.createElement(...)</code>，<code>Babel</code>帮助我们完成了这个转换的过程。</p>
<p><strong>注意</strong>：babel在编译时会判断JSX中组件的首字母，当<code>首字母为小写时</code>，其被认定为<code>原生DOM标签</code>，createElement的第一个变量被编译为字符串；当<code>首字母为大写时</code>，其被认定为自定义<code>组件</code>，createElement的第一个变量被<code>编译为对象</code>,所以组件首字母要大写</p>
<h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/%E8%99%9A%E6%8B%9Fdom.png" alt=""></p>
<p>冷静对待虚拟dom，他不是一定能够提升页面的性能，如果是首次渲染，Vitrua lDom不具有任何优势，甚至它要进行更多的计算，消耗更多的内存，是因为有diff他才会展现它的优势</p>
<h4 id="Virtual-DOM的存在的意义"><a href="#Virtual-DOM的存在的意义" class="headerlink" title="Virtual DOM的存在的意义"></a>Virtual DOM的存在的意义</h4><ul>
<li>Vitrua Dom为React带来了跨平台渲染的能力。以React Native为例子;React根据Vitrual Dom画出相应平台的ui层，只不过不同平台画的姿势不同而已</li>
<li>服务端渲染</li>
<li>函数式编程</li>
</ul>
<h4 id="Virtual-DOM-基本步骤"><a href="#Virtual-DOM-基本步骤" class="headerlink" title="Virtual DOM 基本步骤:"></a>Virtual DOM 基本步骤:</h4><ol>
<li>用<code>js对象来表示DOM树的结构</code>； 然后用这个树构建一个真正的DOM树，插入到文档中。</li>
<li>当状态变更的时候，<code>重新构造一个新的对象</code>，然后用这个新的树和旧的树作对比，记录<code>两个树的差异</code>。 </li>
<li>把2所记录的差异应用在步骤1所构建的真正的DOM树上，视图就更新了。</li>
</ol>
<p>看看虚拟DOM的真实模样</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H66008463790e4f8d9feaa1f12800ee9cm.png" alt=""></p>
<ul>
<li><code>type</code>：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或class）</li>
<li><code>key</code>：组件的唯一标识，用于Diff算法</li>
<li><code>ref</code>：用于访问原生dom节点</li>
<li><code>props</code>：传入组件的props</li>
<li><code>owner</code>：当前正在构建的Component所属的Component</li>
<li><code>$$typeof</code>：防止xss攻击，如果你的服务器有一个漏洞，允许用户存储任意JSON对象， 而客户端代码需要一个字符串，这可能为你的应用程序带来风险。JSON中不能存储Symbol类型的变量，而React渲染时会把没有<code>$$typeof</code>标识的组件过滤掉。</li>
<li><code>self</code>指定当前位于哪个组件实例。</li>
<li><code>_source</code>指定调试代码来自的文件(fileName)和代码行数(lineNumber)。</li>
</ul>
<h4 id="简单实现-vdom"><a href="#简单实现-vdom" class="headerlink" title="简单实现 vdom"></a>简单实现 vdom</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./createElement.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">React</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建虚拟dom用的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>type 标签的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>options props</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param  <span class="type">&#123;...any&#125;</span> </span>arg 子代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> createElement(type, options, ...arg) &#123;</span><br><span class="line">        <span class="comment">// options肯定是一个对象，不管传还是不传</span></span><br><span class="line">        options = options || <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//arg是存储上下的参数，即使没有其他的参数，arg也是一个空数组，</span></span><br><span class="line">        <span class="keyword">let</span> obj = &#123;</span><br><span class="line">            type,</span><br><span class="line">            key: <span class="literal">null</span>,</span><br><span class="line">            ref: <span class="literal">null</span>,</span><br><span class="line">            props: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//key ref</span></span><br><span class="line">        [<span class="string">"key"</span>, <span class="string">"ref"</span>].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (item <span class="keyword">in</span> options) &#123;</span><br><span class="line">                obj[item] = options[item];</span><br><span class="line">                <span class="keyword">delete</span> options[item]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//处理props</span></span><br><span class="line">        obj.props = &#123; ...options &#125;;</span><br><span class="line">        <span class="comment">//因为我这用的es6语法，下面的判断没什么作用，用es5的话需要加上</span></span><br><span class="line">        <span class="keyword">let</span> len = arg.length;</span><br><span class="line">        <span class="keyword">switch</span> (len) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                obj.props.children = arg[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 拥有多个子节点</span></span><br><span class="line">                obj.props.children = arg</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactDom</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将虚拟节点转换成真实的dom节点，最后插入到container容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>objJSX 编译后的虚拟节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>container 要渲染到那个容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>callback 回调函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> render(objJSX, container, callback) &#123;</span><br><span class="line">        <span class="keyword">let</span> newEle = ReactDom.createDomElementFromVnode(objJSX)</span><br><span class="line">        container.appendChild(newEle);</span><br><span class="line">        callback &amp;&amp; callback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> createDomElementFromVnode(objJSX)&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; type, props &#125; = objJSX;</span><br><span class="line">        objJSX.newEle = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">        <span class="comment">//设置属性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!props.hasOwnProperty(key)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//className</span></span><br><span class="line">            <span class="keyword">if</span> (key === <span class="string">"className"</span>) &#123;</span><br><span class="line">                objJSX.newEle.setAttribute(<span class="string">"class"</span>, props[<span class="string">"className"</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//style设置</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"style"</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props[<span class="string">'style'</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (props[<span class="string">"style"</span>].hasOwnProperty(key)) &#123;</span><br><span class="line">                        objJSX.newEle[<span class="string">"style"</span>][key] = props[<span class="string">"style"</span>][key]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//children</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"children"</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> children = props[<span class="string">'children'</span>];</span><br><span class="line">                <span class="keyword">if</span> (children <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">                    children.forEach(<span class="function"><span class="params">itemChildren</span> =&gt;</span> &#123;</span><br><span class="line">                        ReactDom.handChildren(itemChildren, objJSX.newEle)</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ReactDom.handChildren(children, objJSX.newEle);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                objJSX.newEle.setAttribute(key, props[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objJSX.newEle</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> handChildren(children, newEle) &#123;</span><br><span class="line">        <span class="comment">//只有一个子节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> children === <span class="string">"object"</span>) &#123;</span><br><span class="line">            <span class="comment">//当前唯一的新对象</span></span><br><span class="line">            ReactDom.render(children, newEle)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newEle.appendChild(<span class="built_in">document</span>.createTextNode(children))</span><br><span class="line">            <span class="built_in">console</span>.log(newEle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> styleObj = &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125;;</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">    React.createElement(<span class="string">"div"</span>, &#123;</span><br><span class="line">        id: <span class="string">"box"</span>,</span><br><span class="line">        className: <span class="string">"box"</span>,</span><br><span class="line">        style: styleObj</span><br><span class="line">      &#125;, React.createElement(<span class="string">"h2"</span>, &#123;</span><br><span class="line">        className: <span class="string">"title"</span></span><br><span class="line">      &#125;, <span class="string">"\u8FD9\u91CC\u662F\u5934\u90E8"</span>), React.createElement(<span class="string">"ul"</span>, &#123;</span><br><span class="line">        className: <span class="string">"newsItem"</span></span><br><span class="line">      &#125;, React.createElement(<span class="string">"li"</span>, &#123;</span><br><span class="line">        key: <span class="string">"1"</span>,</span><br><span class="line">        style: &#123;</span><br><span class="line">          color: <span class="string">"#ccc"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="string">"\u54C8\u54C8\u54C8"</span>), React.createElement(<span class="string">"li"</span>, &#123;</span><br><span class="line">        key: <span class="string">"2"</span></span><br><span class="line">      &#125;, <span class="string">"\u5475\u5475\u5475"</span>)), <span class="string">"1221"</span>), </span><br><span class="line">    <span class="built_in">window</span>.app</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然后根据不同的情况，来进行树上节点的增删改的操作。这个过程是分为diff和patch：</p>
<ul>
<li><strong>diff</strong>：递归对比两棵 VDom 树的、对应位置的节点差异</li>
<li><strong>patch</strong>：根据不同的差异，进行节点的更新</li>
</ul>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>其实React的 virtual dom的性能好也离不开它本身特殊的diff算法。传统的diff算法时间复杂度达到O(n3)，而react的diff算法时间复杂度只是o(n)，react的diff能减少到o(n)依靠的是react diff的三大策略。</p>
<h4 id="传统diff-对比-react-diff"><a href="#传统diff-对比-react-diff" class="headerlink" title="传统diff 对比 react diff"></a>传统diff 对比 react diff</h4><p>传统的diff算法追求的是“<code>完全</code>”以及“<code>最小</code>”，而react diff则是放弃了这两种追求：<br>在传统的diff算法下，对比前后两个节点，<code>如果发现节点改变了，会继续去比较节点的子节点，一层一层去对比</code>。就这样循环递归去进行对比，复杂度就达到了O(n3)，n是树的节点数，想象一下如果这棵树有1000个节点，我们得执行上十亿次比较，这种量级的对比次数，时间基本要用秒来做计数单位了。</p>
<h4 id="React-diff-三大策略"><a href="#React-diff-三大策略" class="headerlink" title="React diff 三大策略"></a>React diff 三大策略</h4><ul>
<li><strong>tree diff</strong>：Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。<code>（DOM结构发生改变-----直接卸载并重新creat）</code></li>
<li><strong>component diff</strong>：组件的DOM结构一样—–不会卸载,但是会update</li>
<li><strong>element diff</strong>：所有同一层级的子节点.他们都可以通过key来区分—–同时遵循1.2两点</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H9b1d122f787048f7afc393265e732d28D.png" alt=""></p>
<h4 id="虚拟DOM树分层比较（tree-diff）"><a href="#虚拟DOM树分层比较（tree-diff）" class="headerlink" title="虚拟DOM树分层比较（tree diff）"></a>虚拟DOM树分层比较（<code>tree diff</code>）</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H087b9d785877406b94078d9b6a07c15av.png" alt=""></p>
<p>上图中，<strong>div只会和同一层级的div对比，第二层级的只会和第二层级对比。 这样算法复杂度就可以达到O(n)</strong>。</p>
<p>但是如果DOM节点出现了跨层级操作，diff会如何处理？</p>
<p>React是不会机智的判断出子树仅仅是发生了移动，而是<strong>会直接销毁</strong>，并重新创建这个子树，然后再挂在到目标DOM上;<br/><br>实际上，React官方也并不推荐我们做出跨层级的骚操作。所以我们可以从中悟出一个道理：就是我们自己在实现组件的时候，一个稳定的DOM结构是有助于我们的性能提升的。</p>
<h4 id="组件间的比较（component-diff）"><a href="#组件间的比较（component-diff）" class="headerlink" title="组件间的比较（component diff）"></a>组件间的比较（<code>component diff</code>）</h4><p>核心的策略还是看结构是否发生改变。React是基于组件构建应用的，对于组件间的比较所采用的策略也是非常简洁和高效的。</p>
<p><strong>如果是同一个类型的组件</strong>，则按照原策略进行Virtual DOM比较。<br/><br><strong>如果不是同一类型的组件</strong>，则将其判断为dirty component，从而替换整个组价下的所有子节点。<br/><br><strong>如果是同一个类型的组件，有可能经过一轮Virtual DOM比较下来，并没有发生变化</strong>。如果我们能够提前确切知道这一点，那么就可以省下大量的diff运算时间。因此，React允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对比自定义组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffComponent</span>(<span class="params">oldNode, newNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldNode._component &amp;&amp; (oldNode._component.constructor !== newNode.nodeName)) &#123; <span class="comment">// 如果新老组件不同, 则直接将新组件替换老组件</span></span><br><span class="line">    <span class="keyword">const</span> newDom = vdomToDom(newNode)</span><br><span class="line">    oldNode._component.parentNode.insertBefore(newDom, oldNode._component)</span><br><span class="line">    oldNode._component.parentNode.removeChild(oldNode._component)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setProps(oldNode._component, newNode.attributes) <span class="comment">// 如果新老组件相同, 则将新组件的 props 赋到老组件上</span></span><br><span class="line">    renderComponent(oldNode._component)              <span class="comment">// 对获得新 props 前后的老组件做 diff 比较（renderComponent 中调用了 diff）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="元素间的比较（element-diff）"><a href="#元素间的比较（element-diff）" class="headerlink" title="元素间的比较（element diff）"></a>元素间的比较（<code>element diff</code>）</h4><p>当节点处于同一层级的时候，react diff 提供了三种节点操作：<strong>插入、删除、移动</strong>。</p>
<p><span style='display: block;text-align: left;'> 操作</span>|<span style='display: block;text-align: left;'> 描述</span>|<br>–|:–:|:–:|–|<br>插入|新节点不存在于老集合当中，即全新的节点，就会执行插入操作|<br>移动|新节点在老集合中存在，并且只做了位置上的更新，就会复用之前的节点，做移动操作（依赖于Key）|<br>删除|新节点在老集合中存在，但节点做出了更改不能直接复用，做出删除操作|</p>
<h4 id="Key的作用"><a href="#Key的作用" class="headerlink" title="Key的作用"></a>Key的作用</h4><p><strong>react利用key来识别组件，它是一种身份标识标识，就像我们的身份证用来辨识一个人一样</strong>。每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。</p>
<p><strong>key的使用场景</strong></p>
<ul>
<li>数组动态创建的子组件</li>
<li>为一个有复杂繁琐逻辑的组件添加key后，后续操作可以改变该组件的key属性值，从而达到先销毁之前的组件，再重新创建该组件。</li>
</ul>
<p>我们在循环渲染列表时候(map)时候忘记标记key值报的警告,既然是警告,就说明即使没有key的情况下也不会影响程序执行的正确性,其实这个key的存在只会<code>影响diff算法的复杂度</code>(不是一定会提高性能),也就是说你不加上Key就会暴力渲染，加了Key之后，React就可以做出移动的操作了，看例子：</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H1f3780ed47c947c8b8b9c9a5092a06507.png" alt=""></p>
<p>每个节点都加上了唯一的key值，通过这个<strong>Key值发现新老集合里面其实全部都是相同的元素</strong>，只不过位置发生了改变。因此就无需进行节点的插入、删除等操作了，只需要将老集合当中节点的位置进行移动就可以了。React给出的diff结果为：<code>B、D不做操作，A、C进行移动操作</code>。react是如何判断谁该移动，谁该不动的呢？</p>
<p>react会去循环整个新的集合：</p>
<p>① 从新集合中取到<code>B</code>，然后去旧集合中判断是否存在相同的<code>B</code>，确认<code>B</code>存在后，再去判断是否要移动：<br><code>B</code>在旧集合中的<code>index = 1</code>，有一个游标叫做<code>lastindex</code>。默认<code>lastindex = 0</code>，然后会把旧集合的<code>index和游标作</code>对比来判断是否需要移动，如果<strong>index &lt; lastindex ，那么就做移动操作</strong>，在这里<code>B的index = 1</code>，不满足于 <code>index &lt; lastindex</code>,所以就不做移动操作，然后游标lastindex更新，<code>取(index, lastindex) 的较大值</code>，这里就是<code>lastindex = 1</code></p>
<p>② 然后遍历到<code>A</code>，<code>A</code>在老集合中的<code>index = 0</code>，此时的游标<code>lastindex = 1</code>，满足<code>index &lt; lastinde</code>x，所以对A需要移动到对应的位置，此时<code>lastindex = max(index, lastindex) = 1</code></p>
<p>③ 然后遍历到<code>D</code>，<code>D</code>在老集合中的<code>index = 3</code>，此时游标<code>lastindex = 1</code>，不满足<code>index &lt; lastindex</code>，所以D保持不动。<code>lastindex = max(index, lastindex) = 3</code></p>
<p>④ 然后遍历到<code>C</code>，<code>C</code>在老集合中的<code>index = 2</code>，此时游标<code>lastindex = 3</code>，满足 <code>index &lt; lastindex</code>，所以C移动到对应位置。C之后没有节点了，diff就结束了</p>
<p>以上主要分析新老集合中<code>节点相同但位置不同</code>的情景，仅对节点进行位置移动的情况，如果新集合中有新加入的节点且老集合存在需要删除的节点，那么 React diff 又是如何对比运作的呢？</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Haafdd54eefeb47e1ad5fbb10e7f8ba9bE.png" alt=""></p>
<p>和第一种情景基本是一致的，react还是去循环整个新的集合：<br>① 不赘述了，和上面的第一步是一样的，<code>B不做移动，lastindex = 1</code></p>
<p>② 新集合取得<code>E</code>，发现旧集合中不存在，则创建E并放在新集合对应的位置，<code>lastindex = 1</code></p>
<p>③ 遍历到<code>C</code>，不满足<code>index &lt; lastindex</code>，<code>C</code>不动，<code>lastindex = 2</code></p>
<p>④ 遍历到<code>A</code>，满足<code>index &lt; lastindex</code>，<code>A</code>移动到对应位置，<code>lastindex = 2</code></p>
<p>⑤ 当完成新集合中所有节点 <code>diff</code> 时，最后还需要对老集合进行循环遍历，判断是否存在新集合中没有但老集合中仍存在的节点，发现存在这样的节点 <code>D</code>，因此<code>删除节点 D</code>，到此 diff 全部完成</p>
<p>但是 react diff也存在一些问题，和需要优化的地方，看下面的例子：</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hc94d1ce042be45a5b6e694b0b034817cU.png" alt=""></p>
<p>在上面的这个例子，<strong>A、B、C、D</strong>都没有变化，仅仅是<code>D</code>的位置发生了改变。看上面的图我们就知道react并没有把D的位置移动到头部，而是把 <strong>A、B、C</strong>分别移动到<code>D</code>的后面了，通过前面的两个例子，我们也大概知道，为什么会发生这样的情况了：</p>
<p>因为<code>D</code>节点在老集合里面的<code>index</code> 是最大的，使得<strong>A、B、C</strong>三个节点都会 <code>index &lt; lastindex</code>，从而导致<strong>A、B、C</strong>都会去做移动操作。所以在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</p>
<h4 id="三句箴言"><a href="#三句箴言" class="headerlink" title="三句箴言"></a>三句箴言</h4><p>所以经过这么一分析<code>react diff</code>的三大策略，我们能够在开发中更加进一步的提高react的渲染效率。</p>
<ul>
<li>在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；</li>
<li>使用 <code>shouldComponentUpdate()</code>方法节省diff的开销</li>
<li>在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</li>
</ul>
<h4 id="为什么不推荐使用index作为Key"><a href="#为什么不推荐使用index作为Key" class="headerlink" title="为什么不推荐使用index作为Key"></a>为什么不推荐使用index作为Key</h4><p>看下面这个示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   state = &#123;</span><br><span class="line">      list: [&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">val</span>: <span class="string">'A'</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">val</span>: <span class="string">'B'</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">val</span>: <span class="string">'C'</span> &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">  click = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; list &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      list:list.reverse()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">this</span>.state.list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">              &lt;li key=&#123;index&#125; &gt;</span><br><span class="line">                &#123;item.val&#125;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span>&gt;&lt;<span class="regexp">/input&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>li&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.click&#125;&gt;Reverse&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在三个输入框里面，依次输入1，2，3，点击Reverse按钮，按照我们的预期，这时候页面应该渲染成3，2，1，但是实际上，顺序依然还是1，2，3，证明数据确实是更新了的。那么为什么会发生这种事情，我们可以分析一下：</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H3ecb41d8764e4834b940428652f66478s.png" alt=""></p>
<p>出现这种情况，使用key是用来表示唯一的标识组件，当发现setState前后key的值没有发生变化 ，react就会认为你setState前后是同一个组件，进而只会对内部的属性进行修改：</p>
<ul>
<li>检测key值发现都是0，判定组件为同一个。</li>
<li>检测item.val部分，发现有变化重新渲染这部分</li>
<li>检测input，发现不依赖props，所以不进行重新渲染</li>
</ul>
<h4 id="diff-源码"><a href="#diff-源码" class="headerlink" title="diff 源码"></a>diff 源码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; diff函数，对比两颗树</span><br><span class="line">function diff(oldTree, newTree) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前的节点的标志。因为在深度优先遍历的过程中，每个节点都有一个index。</span><br><span class="line">    var index &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 在遍历到每个节点的时候，都需要进行对比，找到差异，并记录在下面的对象中。</span><br><span class="line">    var pathches &#x3D; &#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F; 开始进行深度优先遍历</span><br><span class="line">    dfsWalk(oldTree, newTree, index, pathches);</span><br><span class="line">    &#x2F;&#x2F; 最终diff算法返回的是一个两棵树的差异。</span><br><span class="line">    return pathches;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对两棵树进行深度优先遍历。</span><br><span class="line">function dfsWalk(oldNode, newNode, index, pathches) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对比oldNode和newNode的不同，记录下来</span><br><span class="line">    pathches[index] &#x3D; [...];</span><br><span class="line">  if (_.isString(newNode)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对比文本 dom 节点</span><br><span class="line">    return diffTextDom(oldNode, newNode, index, pathches)   </span><br><span class="line">  &#125;</span><br><span class="line">  if (oldNode.nodeName.toLowerCase() !&#x3D;&#x3D; newNode.nodeName) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对比非文本 dom 节点</span><br><span class="line">    diffNotTextDom(oldNode, newNode, index, pathches)     </span><br><span class="line">  &#125;</span><br><span class="line">  if (_.isFunction(newNode.nodeName)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对比自定义组件</span><br><span class="line">    return diffComponent(oldNode, newNode, index, pathches) </span><br><span class="line">  &#125;</span><br><span class="line">  if (</span><br><span class="line">     &#x2F;&#x2F; 值对比标签的类型和key值是否一致</span><br><span class="line">      oldNode.type &#x3D;&#x3D;&#x3D; newNode.type &amp;&amp;</span><br><span class="line">      oldNode.key &#x3D;&#x3D;&#x3D; newNode.key</span><br><span class="line">    ) &#123;</span><br><span class="line">      var propsPatches &#x3D; diffProps(oldNode, newNode) &#x2F;&#x2F; 对比属性</span><br><span class="line">      if (propsPatches) &#123;</span><br><span class="line">        pathches.push(&#123; type: patch.PROPS, props: propsPatches &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">     if (newVdom.children.length &gt; 0) &#123;</span><br><span class="line">       &#x2F;&#x2F; 遍历对比子节点</span><br><span class="line">       diffChildren(oldNode.children, newNode.children, index, pathches);  </span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历子节点</span><br><span class="line">function diffChildren(oldChildren, newChildren, index, pathches) &#123;  </span><br><span class="line">    var leftNode &#x3D; null;</span><br><span class="line">    var currentNodeIndex &#x3D; index;</span><br><span class="line">    oldChildren.forEach(function (child, i) &#123;</span><br><span class="line">    var newChild &#x3D; newChildren[i];</span><br><span class="line">    currentNodeIndex &#x3D; (leftNode &amp;&amp; leftNode.count)</span><br><span class="line">    ? currentNodeIndex + leftNode.count + 1</span><br><span class="line">    : currentNodeIndex + 1</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 深度遍历子节点</span><br><span class="line">    dfsWalk(child, newChild, currentNodeIndex, pathches);</span><br><span class="line">    leftNode &#x3D; child;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/diff.js#L5" target="_blank" rel="noopener">详细diff跳转</a></p>
<h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>因为步骤一所构建的 JavaScript 对象树和render出来真正的DOM树的信息、结构是一样的。<br>所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作。</p>
<p><strong>差异类型</strong></p>
<p>DOM操作可能会：</p>
<ul>
<li>替换原来的节点，如把上面的div换成了section。 </li>
<li>移动、删除、新增子节点， 例如上面div的子节点，把p和ul顺序互换。</li>
<li>修改了节点的属性。 </li>
<li>对于文本节点，文本内容可能会改变。<br>所以，我们可以定义下面的几种类型：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> REPLACE = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">var</span> REORDER = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> PROPS = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> TEXT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//patches里面存储着差异的dom,是个数组</span></span><br><span class="line">patches[<span class="number">0</span>] = [</span><br><span class="line">  &#123;</span><br><span class="line">   type:  TEXT,</span><br><span class="line">   content: <span class="string">'word'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; </span><br><span class="line">    type: PROPS,</span><br><span class="line">    props: &#123;</span><br><span class="line">      id: <span class="string">'container'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>patch 源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">node, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> walker = &#123;<span class="attr">index</span>: <span class="number">0</span>&#125;</span><br><span class="line">  dfsWalk(node, walker, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span> (<span class="params">node, walker, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentPatches = patches[walker.index] <span class="comment">// 从patches拿出当前节点的差异</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> len = node.childNodes</span><br><span class="line">    ? node.childNodes.length</span><br><span class="line">    : <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 深度遍历子节点</span></span><br><span class="line">    <span class="keyword">var</span> child = node.childNodes[i]</span><br><span class="line">    walker.index++</span><br><span class="line">    dfsWalk(child, walker, patches)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentPatches) &#123;</span><br><span class="line">    applyPatches(node, currentPatches) <span class="comment">// 对当前节点进行DOM操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>applyPatches，根据不同类型的差异对当前节点进行 DOM 操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatches</span> (<span class="params">node, currentPatches</span>) </span>&#123;</span><br><span class="line">  currentPatches.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">currentPatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> REPLACE:</span><br><span class="line">        node.parentNode.replaceChild(currentPatch.node.render(), node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> REORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> PROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TEXT:</span><br><span class="line">        node.textContent = currentPatch.content</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unknown patch type '</span> + currentPatch.type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/patch.js#L8" target="_blank" rel="noopener">详细patch跳转</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>virtual DOM算法主要实现上面步骤的三个函数： <code>react.createElement</code>、<code>diff</code>、<code>patch</code>，然后就可以实际的进行使用了。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 构建虚拟DOM</span></span><br><span class="line"><span class="keyword">let</span> tree = React.createElement(<span class="string">"div"</span>, &#123;</span><br><span class="line">  id: <span class="string">"box"</span>,</span><br><span class="line">  className: <span class="string">"box"</span>,</span><br><span class="line">  style: &#123;</span><br><span class="line">    color: <span class="string">"#ccc"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, </span><br><span class="line">React.createElement(<span class="string">"h2"</span>, &#123;</span><br><span class="line">   className: <span class="string">"title"</span></span><br><span class="line"> &#125;, <span class="string">"hhhh222"</span>),</span><br><span class="line"><span class="string">"divdivdiv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过虚拟DOM构建真正的DOM</span></span><br><span class="line"><span class="keyword">var</span> root = tree.render()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 生成新的虚拟DOM</span></span><br><span class="line"><span class="keyword">var</span> newTree = React.createElement(<span class="string">"div"</span>, &#123;</span><br><span class="line">  id: <span class="string">"box"</span>,</span><br><span class="line">  className: <span class="string">"box"</span>,</span><br><span class="line">  style: &#123;</span><br><span class="line">    color: <span class="string">"#ccc"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, </span><br><span class="line">React.createElement(<span class="string">"h2"</span>, &#123;</span><br><span class="line">   className: <span class="string">"title"</span></span><br><span class="line"> &#125;, <span class="string">"--hhhh222"</span>),</span><br><span class="line"><span class="string">"--divdivdiv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 比较两棵虚拟DOM树的不同</span></span><br><span class="line"><span class="keyword">var</span> patches = diff(tree, newTree)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 在真正的DOM元素上应用变更</span></span><br><span class="line">patch(root, patches)</span><br></pre></td></tr></table></figure>
<p>当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的ReactJS了。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://juejin.im/post/5cb66fdaf265da0384128445" target="_blank" rel="noopener">https://juejin.im/post/5cb66fdaf265da0384128445</a><br/><br><a href="https://blog.csdn.net/qq_36407875/article/details/84965311" target="_blank" rel="noopener">https://blog.csdn.net/qq_36407875/article/details/84965311</a><br/><br><a href="https://www.cnblogs.com/zhuzhenwei918/p/7271305.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuzhenwei918/p/7271305.html</a><br/><br><a href="http://react-china.org/t/react-react/26788" target="_blank" rel="noopener">http://react-china.org/t/react-react/26788</a><br/><br><a href="https://github.com/MuYunyun/blog/blob/master/React/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React/4.diff%E7%AE%97%E6%B3%95.md" target="_blank" rel="noopener">https://github.com/MuYunyun/blog/blob/master/React/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React/4.diff%E7%AE%97%E6%B3%95.md</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>React</category>
        <category>VirtualDOM</category>
      </categories>
  </entry>
  <entry>
    <title>Dva封装</title>
    <url>/2018/01/17/workspace/Frame/react/dva/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Dva封装</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createStore,combineReducers,applyMiddleware&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Provider,connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">'redux-saga'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> effects <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createHashHistory&#125; <span class="keyword">from</span> <span class="string">'history'</span>;</span><br><span class="line"><span class="keyword">const</span> NAMESPACE_SEPERATOR = <span class="string">'/'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    connect</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> app = &#123;</span><br><span class="line">        model,</span><br><span class="line">        _models:[],</span><br><span class="line">        router,</span><br><span class="line">        _router:<span class="literal">null</span>,</span><br><span class="line">        start</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">model</span>(<span class="params">model</span>)</span>&#123;</span><br><span class="line">        app._models.push(model);<span class="comment">//把传入的model存放起来</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">router</span>(<span class="params">routeConfig</span>)</span>&#123;</span><br><span class="line">        app._router = routeConfig;<span class="comment">//把路由的配置暂存起来</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">root</span>)</span>&#123;<span class="comment">//启动渲染</span></span><br><span class="line">        <span class="keyword">let</span> reducers = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> model <span class="keyword">of</span> app._models)&#123;</span><br><span class="line">            reducers[model.namespace] = <span class="function"><span class="keyword">function</span>(<span class="params">state=model.state,action</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> actionType = action.type;<span class="comment">//获取动作类型 counter/add  ['counter','add']</span></span><br><span class="line">                <span class="keyword">let</span> values = actionType.split(NAMESPACE_SEPERATOR);</span><br><span class="line">                <span class="keyword">if</span>(values[<span class="number">0</span>] == model.namespace)&#123;<span class="comment">//如果说命名空间的名字和动作命名空间一样的话</span></span><br><span class="line">                    <span class="keyword">let</span> reducer = model.reducers[values[<span class="number">1</span>]];<span class="comment">//获取要进行计算状态的reducer</span></span><br><span class="line">                    <span class="keyword">if</span>(reducer)</span><br><span class="line">                      <span class="keyword">return</span> reducer(state,action);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reducer = combineReducers(reducers);<span class="comment">//合并reducers</span></span><br><span class="line">        <span class="keyword">let</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line">        <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> model <span class="keyword">of</span> app._models)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> model.effects)&#123;</span><br><span class="line">                    <span class="keyword">yield</span> effects.takeEvery(<span class="string">`<span class="subst">$&#123;model.namespace&#125;</span><span class="subst">$&#123;NAMESPACE_SEPERATOR&#125;</span><span class="subst">$&#123;key&#125;</span>`</span>,model.effects[key],effects);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> store = createStore(reducer,applyMiddleware(sagaMiddleware));<span class="comment">//创建仓库</span></span><br><span class="line">        sagaMiddleware.run(rootSaga);</span><br><span class="line">        <span class="keyword">const</span> history = createHashHistory();</span><br><span class="line">        <span class="keyword">let</span> App = app._router(&#123;app,history&#125;);<span class="comment">//获取要渲染的组件</span></span><br><span class="line">        ReactDOM.render(<span class="comment">//执行渲染</span></span><br><span class="line">            &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">                &#123;App&#125;</span><br><span class="line">            &lt;<span class="regexp">/Provider&gt;,document.querySelector(root)</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    return app;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>简单使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;adminCharacters, adminCharactersDelete&#125; <span class="keyword">from</span> <span class="string">'src/api/admin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    namespace: <span class="string">'roleAdmin'</span>,</span><br><span class="line">    state: &#123;</span><br><span class="line">        dataSource: [],</span><br><span class="line">    &#125;,</span><br><span class="line">    effects: &#123;</span><br><span class="line">        * fetchData (&#123;id&#125;, &#123;call, put, select&#125;) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;data&#125; = <span class="keyword">yield</span> call(adminCharacters);</span><br><span class="line">            <span class="keyword">yield</span> put(&#123;</span><br><span class="line">                type: <span class="string">'save'</span>,</span><br><span class="line">                payload: &#123;</span><br><span class="line">                    dataSource: data,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        * deleteData (&#123;id, cb&#125;, &#123;call, put&#125;) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;success&#125; = <span class="keyword">yield</span> call(adminCharactersDelete, id);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                cb()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    reducers: &#123;</span><br><span class="line">        save(state, &#123;payload&#125;) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;...state, ...payload&#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>React</category>
        <category>Dva封装</category>
      </categories>
  </entry>
  <entry>
    <title>react事件委托机制</title>
    <url>/2019/11/17/workspace/Frame/react/event/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>react事件委托机制</strong></p>
<p>[[toc]]</p>
<h3 id="为什么要用事件委托"><a href="#为什么要用事件委托" class="headerlink" title="为什么要用事件委托"></a>为什么要用事件委托</h3><p>一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历，这样的话每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，如果数量更大的话就gg了。</p>
<h3 id="事件委托的作用"><a href="#事件委托的作用" class="headerlink" title="事件委托的作用"></a>事件委托的作用</h3><ul>
<li>支持为同一个DOM元素注册多个同类型事件</li>
<li>可将事件分成事件捕获和事件冒泡机制</li>
</ul>
<h3 id="dom-绑定事件"><a href="#dom-绑定事件" class="headerlink" title="dom 绑定事件"></a>dom 绑定事件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>onclick</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'打印第一次'</span>)</span><br><span class="line">&#125;</span><br><span class="line">div1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'打印第二次'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果是第二个点击注册事件覆盖了第一个点击事件,只执行了console.log('打印第二次');</span></span><br></pre></td></tr></table></figure>

<p><strong>DOM 2 实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addEventListener(type,listener,useCapture)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'打印第一次'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">div1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'打印第二次'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//可以看到两个注册事件都会成功触发</span></span><br></pre></td></tr></table></figure>

<h3 id="事件捕获和事件冒泡机制"><a href="#事件捕获和事件冒泡机制" class="headerlink" title="事件捕获和事件冒泡机制"></a>事件捕获和事件冒泡机制</h3><p><strong>事件捕获</strong><br/><br>当一个事件触发后,从Window对象触发,不断经过下级节点,直到目标节点。在事件到达目标节点之前的过程就是捕获阶段。所有经过的节点,都会触发对应的事件</p>
<p><strong>事件冒泡</strong><br/><br>当事件到达目标节点后，会沿着捕获阶段的路线原路返回。同样，所有经过的节点,都会触发对应的事件</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H872695a92b914492ab8ba0d9783368cdg.jpg" alt=""></p>
<p>上面的<code>addEventListener</code>的第三个参数就是设置是捕获还是冒泡阶段，默认是false是<code>冒泡阶段</code>，当设为true的时候是<code>事件捕获</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">body.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'打印body'</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">div1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'打印div1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印body   打印div1</span></span><br></pre></td></tr></table></figure>
<h3 id="addEventListener-和-onclick的区别"><a href="#addEventListener-和-onclick的区别" class="headerlink" title="addEventListener() 和 onclick的区别"></a>addEventListener() 和 onclick的区别</h3><ul>
<li>onclick 不能同时执行两个函数，addEventListener()可以执行两个不同的函数</li>
<li>移除事件侦听的方式不同 (onclick直接覆盖就行 ，addEventListener用removeEventListener移除)</li>
<li>addEventListener可以在捕获阶段和冒泡阶段触发，而onclick只能冒泡阶段触发</li>
<li>onclick支持IE低版本，addEventListener不支持IE8一下，低版本的IE使用 attachEvent 进行事件侦听；使用 detachEvent 移除事件侦听。</li>
</ul>
<h3 id="事件委托的优点"><a href="#事件委托的优点" class="headerlink" title="事件委托的优点"></a>事件委托的优点</h3><p><strong>提高性能</strong> 每一个函数都会占用内存空间，只需添加一个事件处理程序代理所有事件,所占用的内存空间更少。<br><strong>动态监听</strong> 使用事件委托可以自动绑定动态添加的元素,即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。</p>
<h3 id="react的事件委托机制"><a href="#react的事件委托机制" class="headerlink" title="react的事件委托机制"></a>react的事件委托机制</h3><p>react事件机制分为两个部分：<strong>1、事件注册 2、事件分发</strong></p>
<p><strong>事件注册</strong>部分，所有的事件都会注册到document上，拥有统一的回调函数dispatchEvent来执行事件分发</p>
<p><strong>事件分发</strong>部分，首先生成合成事件，注意同一种事件类型只能生成一个合成事件<code>Event</code>，如<code>onClick</code>这个类型的事件，dom上所有带有通过jsx绑定的<code>onClick</code>的回调函数都会按顺序（冒泡或者捕获）会放到<code>Event._dispatchListeners</code> 这个数组里，后面依次执行它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">   <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'document click'</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="built_in">document</span>.getElementsByClassName(<span class="string">'App'</span>)[<span class="number">0</span>].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'app click'</span>) </span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="built_in">document</span>.getElementsByTagName(<span class="string">'button'</span>)[<span class="number">0</span>].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'button click'</span>)  </span><br><span class="line">     <span class="comment">// e.stopPropagation();</span></span><br><span class="line">   &#125;)</span><br><span class="line"> &#125; </span><br><span class="line"> onClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">   e.stopPropagation() <span class="comment">// 能够阻止div.app的触发</span></span><br><span class="line">   e.nativeEvent.stopImmediatePropagation(); <span class="comment">// nativeEvent是原生的事件 ， 能够阻止document的触发  </span></span><br><span class="line">   e.nativeEvent.stopPropagation(); <span class="comment">// 什么都阻止不了,因为onClick合成事件都会注册到document上</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'react button click'</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;div className=<span class="string">"App"</span> onClick=&#123;() =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'react app click'</span>)&#125;&#125;&gt;</span><br><span class="line">       &lt;button onClick=&#123;<span class="keyword">this</span>.onClick&#125;&gt;按钮&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>div&gt;</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// button click -&gt; app click -&gt; react button click</span></span><br></pre></td></tr></table></figure>

<p><strong>看下实现封步骤</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vdom = &#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    onClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//合成事件</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'react app click'</span>)    </span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        type: <span class="string">'button'</span>,</span><br><span class="line">        props: &#123;</span><br><span class="line">           onClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'react button click'</span>)    </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注册事件</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bankForRegistrationName = &#123; <span class="comment">// 回调事件的保存</span></span><br><span class="line">    <span class="comment">// 数字是_debugID,react用于识别每一个dom</span></span><br><span class="line">    <span class="number">5</span>: &#123;</span><br><span class="line">      click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'react app click'</span>)    </span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">6</span>: &#123;</span><br><span class="line">      click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'react button click'</span>)    </span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事件触发</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合成事件简单实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SyntheticEvent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.nativeEvent = e;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// e: event， type: 事件类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchEvent</span>(<span class="params">e, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> synE = <span class="keyword">new</span> SyntheticEvent(e);</span><br><span class="line">  <span class="comment">// 执行监听事件</span></span><br><span class="line">  <span class="keyword">let</span> debugID = e.target.__reactInternalInstance$om8tco7dvl._debugID;</span><br><span class="line">  bankForRegistrationName[debugID][type](synE); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// document事件委托</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  dispatchEvent(e, <span class="string">'click'</span>); <span class="comment">// 总之最后是通过点击document做事件委托触发的</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://www.jianshu.com/p/b249793fd2a7" target="_blank" rel="noopener">https://www.jianshu.com/p/b249793fd2a7</a><br/><br><a href="https://www.jianshu.com/p/c01756e520c7" target="_blank" rel="noopener">https://www.jianshu.com/p/c01756e520c7</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>React</category>
        <category>react事件委托机制</category>
      </categories>
  </entry>
  <entry>
    <title>React16 Fiber</title>
    <url>/2019/01/17/workspace/Frame/react/fiber/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>React16 Fiber</strong></p>
<p>[[toc]]</p>
<p>React早期的优化都是<code>停留于JS层面</code>（vdom的 create/diff），诸如减少组件的复杂度（Stateless），<br>减少向下diff的规模(SCU)，减少diff的成本(immutable.js)，当然，也有例外，比如针对老式的IE的LazyDOMTree。<br>到React16，则<code>升级到浏览器渲染机制层面</code>, 在patch上取得了突破。众所周知，浏览器是单线程。<br>想象一下，如果有两个线程，一个线程要对这节点进行移除，一个要对它进行样式操作。<br>线程是并发的，无法决定顺序，这样页面的效果是不可控的。换单线程则简单可控，<br>但JS执行与视图渲染与资原加载与事件回调是如何调度呢，于是有了EventLoop这种东西。</p>
<h3 id="React16之前的痛点"><a href="#React16之前的痛点" class="headerlink" title="React16之前的痛点"></a>React16之前的痛点</h3><ul>
<li>组件不能返回数组</li>
<li>弹窗问题</li>
<li>异常处理</li>
<li>HOC没有考虑到ref与context的向下传递。</li>
<li>组件的性能优化全凭人肉，并且主要集中在SCU，希望框架能干些事情，即使不用SCU，性能也能上去。</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/He5cb4e937aaa4ecfbb32c6f106bd1b98O.jpg" alt=""></p>
<h3 id="解决进度"><a href="#解决进度" class="headerlink" title="解决进度"></a>解决进度</h3><p>16版本大更新，Fiber顺手解决了这些痛点</p>
<ul>
<li>16.0 让组件支持返回任何数组类型，从而解决数组问题; 推出createPortal API ,解决弹窗问题; 推出componentDidCatch新钩子， 划分出错误组件与边界组件， 每个边界组件能修复下方组件错误一次， 再次出错，转交更上层的边界组件来处理，解决异常处理问题。</li>
<li>16.2 推出Fragment组件，可以看作是数组的一种语法糖。</li>
<li>16.3 推出createRef与forwardRef解决Ref在HOC中的传递问题，推出new Context API，解决HOC的context传递问题</li>
<li>而性能问题，从16.0开始一直由一些内部机制来保证，涉及到批量更新及基于时间分片的限量更新。</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H0c7d42dd77864b7484ada4c2d7ea9316J.jpg" alt=""></p>
<h3 id="Fiber是什么"><a href="#Fiber是什么" class="headerlink" title="Fiber是什么"></a>Fiber是什么</h3><p><code>React Fiber</code>是对核心算法的一次重新实现。<code>React Fiber</code>把更新过程碎片化，把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会</p>
<ul>
<li>在<code>React Fiber</code>中，一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来</li>
<li>因为一个更新过程可能被打断，所以<code>React Fiber</code>一个更新过程被分为两个阶段(Phase)：第一个阶段<code>Reconciliation Phase</code>(调度阶段)和第二阶段<code>Commit Phase</code>(渲染阶段)</li>
<li>在第一阶段<code>Reconciliation Phase</code>，React Fiber会找出需要更新哪些DOM，这个阶段是<code>可以被打断</code>的；但是到了第二阶段<code>Commit Phase</code>，那就一鼓-作气把DOM更新完，<code>绝不会被打断</code></li>
<li>这两个阶段大部分工作都是React Fiber做，和我们相关的也就是修改了部分生命周期函数</li>
</ul>
<p>React Fiber改变了之前react的组件渲染机制，新的架构使原来同步渲染的组件现在可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程,解决掉帧的问题</p>
<h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><ul>
<li>时间分片（把渲染任务拆分成块，匀到多帧）</li>
<li>更新时能够暂停，终止，复用渲染任务（链表）</li>
<li>给不同类型的更新赋予优先级</li>
<li>并发方面新的基础能力</li>
</ul>
<h3 id="为什么需要异步渲染"><a href="#为什么需要异步渲染" class="headerlink" title="为什么需要异步渲染"></a>为什么需要异步渲染</h3><p>我们都知道在react16之前，react对virtual dom 的渲染是同步的，即每次将所有操作累加起来，统计对比出所有的变化后，统一更新一次DOM树（<a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">了解虚拟dom算法</a>），随着组件层级的深入，由于渲染更新<strong>一旦开始就无法停止</strong>，导致主线程长时间被占用，这也是react在动画，布局和手势等区域会有造成掉帧、延迟响应（甚至无响应）等不佳体验。</p>
<p>假如更新一个组件需要1毫秒，如果有200个组件要更新，那就需要200毫秒，在这200毫秒的更新过程中，浏览器那个唯一的主线程都在专心运行更新操作，无暇去做任何其他的事情。想象一下，在这200毫秒内，用户往一个input元素中输入点什么，敲击键盘也不会获得响应，因为渲染输入按键结果也是浏览器主线程的工作，但是浏览器主线程被React占着呢，抽不出空，最后的结果就是用户敲了按键看不到反应，等React更新过程结束之后，咔咔咔那些按键一下子出现在input元素里了。</p>
<h3 id="Fiber的结构"><a href="#Fiber的结构" class="headerlink" title="Fiber的结构"></a>Fiber的结构</h3><p>React 目前的做法是使用<code>链表</code>, 每个 VirtualDOM 节点内部现在使用 Fiber表示, 它的结构大概如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Fiber = &#123;</span><br><span class="line">  <span class="comment">// Fiber 类型信息</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ⚛️ 链表结构</span></span><br><span class="line">  <span class="comment">// 指向父节点，或者render该节点的组件</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向第一个子节点</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向下一个兄弟节点</span></span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fiber中最为重要的是return、child、sibling指针，连接父子兄弟节点以构成一颗单链表Fiber树，其扁平化的单链表结构的特点<code>将以往递归遍历改为了循环遍历</code>，实现深度优先遍历不用每次都进入递归函数，重新生成什么执行上下文，变量对象，激活对象，性能当然比递归好。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hf4b7a27bd4e1433e87216f879a2b9b78B.jpg" alt=""></p>
<h3 id="Fiber-tree与workInProgress-tree"><a href="#Fiber-tree与workInProgress-tree" class="headerlink" title="Fiber tree与workInProgress tree*"></a>Fiber tree与workInProgress tree*</h3><p><strong>current树：</strong> React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为<code>Virtual DOM Tree</code>，由于要<code>记录上下文信息</code>，加入了 Fiber，每一个 Element 会对应一个 <code>Fiber Node</code>，将 <code>Fiber Node</code> 链接起来的结构成为 <code>Fiber Tree</code>。它反映了用于渲染 UI 的应用程序的状态。这棵树通常被称为 <code>current 树</code>（当前树，记录当前页面的状态）。</p>
<p>在后续的更新过程中（setState），每次重新渲染都会<code>重新创建 Element</code>, 但是 Fiber 不会，Fiber 只会使用对应的 Element 中的数据来更新自己必要的属性，</p>
<p>Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</p>
<p><strong>当 render 的时候有了这么一条单链表，当调用 setState 的时候又是如何 Diff 得到 change 的呢？</strong></p>
<p>采用的是一种叫双缓冲技术（double buffering），这个时候就需要另外一颗树：WorkInProgress Tree，它反映了要刷新到屏幕的未来状态。</p>
<p><strong>workInProgress树：</strong> 当React经过<code>current当前树</code>时，对于每一个先存在的Fiber节点，它都会创建一个替代（alternate）节点，这些节点组成了workInProgress树。这个节点是使用render方法返回的React元素的数据创建的。一旦更新处理完以及所有相关工作完成，React就有一颗替代树来准备刷新屏幕。一旦这颗workInProgress树渲染（render）在屏幕上，它便成了当前树。下次进来会把current状态复制到WIP上，进行交互复用，而不用每次更新的时候都创建一个新的对象，消耗性能</p>
<p>WorkInProgress Tree 构造完毕，得到的就是新的 Fiber Tree，然后喜新厌旧（把 current 指针指向WorkInProgress Tree，丢掉旧的 Fiber Tree）就好了。</p>
<p>这样做的好处：</p>
<ul>
<li>能够复用内部对象（Fiber）</li>
<li>节省内存分配、GC的时间开销</li>
<li>就算运行中有错误，也不会影响 View 上的数据</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H036ba6384df544979539d0c3f63096c4d.jpg" alt=""></p>
<p><strong>alternate</strong> 可以理解为一个Fiber版本池，用于交替记录组件更新（切分任务后变成多阶段更新）过程中Fiber的更新，因为在组件更新的各阶段，更新前及更新过程中Fiber状态并不一致，在需要恢复时（如发生冲突），即可使用另一者直接回退至上一版本Fiber。</p>
<h3 id="Fiber-Reconciliation-更新过程"><a href="#Fiber-Reconciliation-更新过程" class="headerlink" title="Fiber Reconciliation(更新过程)*"></a>Fiber Reconciliation(更新过程)*</h3><p>react渲染大抵可以分为<strong>reconciler（调度阶段）和 commit（渲染阶段）</strong>，前者用于对比，后者用于操作dom，<code>reconciler</code>阶段可以算是一个从顶向下的递归算法，主要工作是对<code>current tree 和 new tree</code>做计算，找出变化部分。<code>commit</code>阶段是对在reconciler阶段获取到的变化部分应用到真实的DOM树中,在绝大部分运用场景中，reconciler阶段的时间远远超过commit，因此Fiber选择将reconciler阶段进行分割。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第1阶段 render/reconciliation</span></span><br><span class="line"><span class="comment">//（可中断）render/reconciliation 通过构造workInProgress tree得出change</span></span><br><span class="line"><span class="keyword">constructor</span></span><br><span class="line">componentWillMount //废弃</span><br><span class="line">componentWillReceiveProps //废弃</span><br><span class="line">static getDerivedStateFromProps</span><br><span class="line">shouldComponentUpdate</span><br><span class="line">componentWillUpdate //废弃</span><br><span class="line">render</span><br><span class="line"></span><br><span class="line">// 第2阶段 commit</span><br><span class="line">//（不可中断）commit 应用这些DOM change</span><br><span class="line">getSnapshotBeforeUpdate()  //严格来说，这个是在进入 commit 阶段前调用</span><br><span class="line">componentDidMount</span><br><span class="line">componentDidUpdate</span><br><span class="line">componentWillUnmount</span><br></pre></td></tr></table></figure>
<h4 id="diff-render-reconciliation"><a href="#diff-render-reconciliation" class="headerlink" title="diff ~ render/reconciliation"></a>diff ~ render/reconciliation</h4><p>diff的实际工作是对比prevInstance和nextInstance的状态，找出差异及其对应的DOM change。diff本质上是一些计算（遍历、比较），是可拆分的（算一半待会儿接着算）</p>
<p>以Fiber tree为蓝本，把每个Fiber作为一个工作单元，自顶向下逐节点构造workInProgress tree（构建中的新Fiber tree）</p>
<p>具体过程如下（以组件节点为例）：</p>
<ol>
<li>如果当前节点不需要更新，直接把子节点clone过来，跳到5；要更新的话打个tag</li>
<li>更新当前节点状态（props, state, context等）</li>
<li>调用shouldComponentUpdate()，false的话，跳到5</li>
<li>调用render()获得新的子节点，并为子节点<code>创建Fiber</code>（创建过程会尽量复用现有Fiber，子节点增删也发生在这里）</li>
<li>如果没有产生child Fiber，该工作单元结束，把effect list归并到return，并把当前节点的sibling作为下一个工作单元；否则把child作为下一个工作单元</li>
<li>如果没有剩余可用时间了，等到下一次主线程空闲时才开始下一个工作单元；否则，立即开始做</li>
<li>如果没有下一个工作单元了（回到了workInProgress tree的根节点），第1阶段结束，进入pendingCommit状态</li>
</ol>
<p>实际上是1-6的工作循环，7是出口，工作循环每次只做一件事，做完看要不要喘口气。工作循环结束时，workInProgress tree的根节点身上的effect list就是收集到的所有side effect（因为每做完一个都向上归并）</p>
<p>所以，<strong>构建workInProgress tree的过程就是<code>diff</code>的过程</strong>，通过requestIdleCallback来调度执行一组任务，每完成一个任务后回来看看有没有插队的（更紧急的），每完成一组任务，把时间控制权交还给主线程，直到下一次requestIdleCallback回调再继续构建workInProgress tree,这部分的核心是<code>beginWork</code>函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">fiber: Fiber</span>): <span class="title">Fiber</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.tag === WorkTag.HostComponent) &#123;</span><br><span class="line">    <span class="comment">// 宿主节点diff</span></span><br><span class="line">    diffHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.ClassComponent) &#123;</span><br><span class="line">    <span class="comment">// 类组件节点diff</span></span><br><span class="line">    diffClassComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.FunctionComponent) &#123;</span><br><span class="line">    <span class="comment">// 函数组件节点diff</span></span><br><span class="line">    diffFunctionalComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他类型节点，省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="patch-commit"><a href="#patch-commit" class="headerlink" title="patch ~ commit"></a>patch ~ commit</h4><p>第2阶段直接一口气做完：</p>
<ol>
<li><p>处理effect list（更新DOM树、调用组件生命周期函数以 更新ref、异常处理等内部状态）</p>
</li>
<li><p>出对结束，第2阶段结束，所有更新都commit到DOM树上了</p>
</li>
</ol>
<p>注意，真的是<code>一口气做完</code>（同步执行，不能喊停）的，这个阶段的实际工作量是比较大的，所以尽量不要在后3个生命周期函数里干重活儿</p>
<p>patch阶段把本次更新中的所有DOM change应用到DOM树，是一连串的DOM操作。这些DOM操作虽然看起来也可以拆分（按照change list一段一段做），但这样做一方面可能造成DOM实际状态与维护的内部状态不一致，另外还会影响体验。而且，一般场景下，DOM更新的耗时比起diff及生命周期函数耗时不算什么，拆分的意义不很大</p>
<h3 id="为什么需要新的生命周期"><a href="#为什么需要新的生命周期" class="headerlink" title="为什么需要新的生命周期"></a>为什么需要新的生命周期</h3><p>v16之前的生命周期<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=184887708,229247596&fm=26&gp=0.jpg" alt=""></p>
<ol>
<li>v16之前的版本，组件在<code>挂载</code>过程中会调3次钩子/方法<code>（constructor, componentWillMount, render）</code>， 组件在<code>更新</code>过程中会调4次钩子 <code>（componentWillReceiveProps, shouldUpdate, componentWillUpdate,render）</code>, updateView在check的时候很害怕出错的，总不能每个方法都用try catch包起来，这样会性能很差。而constructor, render是不可避免的，于是对三个willXXX动刀了。</li>
<li>在早期版本中，<code>componentWillMount与componentWillReceiveProps会</code>做内部优化，执行多次setState都会延后到render时进行合并处理。因此用户就肆意setState了。这些willXXX还可以让用户任意操作DOM。 操作DOM会可能reflow，这是官方不愿意看到的。于是官方推出了<code>getDerivedStateFromProps</code>，让你在render设置新state，你主要返回一个新对象，它就主动帮你setState。由于这是一个静态方法，你不能操作instance，这就<code>阻止了你多次操作setState</code>。</li>
<li>生命周期在React v16推出的Fiber之后就不合适了，在render函数之前的所有函数，都有可能被执行多次。<br>因为新的react引入了异步渲染机制，主要的功能是，在渲染完成前，可以中断任务，中断之后不会继续执行生命周期，而是重头开始执行生命周期。这导致上述的<code>componentWillMount，componentWillReceiveProps，componentWillUpdate</code>可能会被中断，导致执行多次，带来意想不到的情况。<code>如果render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用</code></li>
</ol>
<p><code>reconciler</code>阶段的钩子都不应该操作DOM，最好也不要setState，我们称之为<code>轻量钩子</code>。<code>commit</code>阶段的钩子则对应称之为<code>重量钩子</code>。</p>
<h3 id="Fiber流程图"><a href="#Fiber流程图" class="headerlink" title="Fiber流程图"></a>Fiber流程图</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H42a99254c6d8425ab9b8bf782554349aG.jpg" alt=""></p>
<h3 id="优先级策略"><a href="#优先级策略" class="headerlink" title="优先级策略"></a>优先级策略</h3><p>每个工作单元运行时有6种优先级：</p>
<ul>
<li>synchronous 与之前的Stack reconciler操作一样，同步执行</li>
<li>task 在next tick之前执行</li>
<li>animation 下一帧之前执行</li>
<li>high 在不久的将来立即执行</li>
<li>low 稍微延迟（100-200ms）执行也没关系</li>
<li>offscreen 下一次render时或scroll时才执行</li>
</ul>
<p><code>synchronous</code>首屏（首次渲染）用，要求尽量快，不管会不会阻塞UI线程。<code>animation</code>通过requestAnimationFrame来调度，这样在下一帧就能立即开始动画过程；<code>后3个</code>都是由requestIdleCallback回调执行的；offscreen指的是当前隐藏的、屏幕外的（看不见的）元素</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37095662</a></p>
<p><a href="http://www.ayqy.net/blog/dive-into-react-fiber/#articleHeader1" target="_blank" rel="noopener">http://www.ayqy.net/blog/dive-into-react-fiber/#articleHeader1</a></p>
<p><a href="https://juejin.im/post/5dadc6045188255a270a0f85" target="_blank" rel="noopener">https://juejin.im/post/5dadc6045188255a270a0f85</a></p>
<p><a href="https://juejin.im/post/5df21c895188251260743972" target="_blank" rel="noopener">https://juejin.im/post/5df21c895188251260743972</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>React</category>
        <category>Fiber</category>
      </categories>
  </entry>
  <entry>
    <title>问题验证解析</title>
    <url>/2019/01/17/workspace/Frame/react/problem/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>问题验证解析</strong></p>
<p>[[toc]]</p>
<h3 id="setState为什么是异步的、什么时候是异步的？"><a href="#setState为什么是异步的、什么时候是异步的？" class="headerlink" title="setState为什么是异步的、什么时候是异步的？"></a>setState为什么是异步的、什么时候是异步的？</h3><p>setState本身的执行过程是同步的，只是因为在react的<strong>合成事件</strong>与钩子函数中执行顺序在更新之前，所以不能直接拿到更新后的值，形成了所谓的异步；</p>
<p>在原生事件与setTimeout中是同步的</p>
<p><strong>验证结果</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        num: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">this</span>.clickFunc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原生点击事件的处理函数</span></span><br><span class="line">    clickFunc() &#123;</span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.num);</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.num,<span class="string">'打印的是当前值'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//setTimeout</span></span><br><span class="line">    addNumSet = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.num);</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.num, <span class="string">'打印的是当前值'</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//合成事件、钩子函数内进行了批量更新优化</span></span><br><span class="line">    addNum = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.num, <span class="string">'打印的是上一次的值'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;h1&gt;&#123;<span class="keyword">this</span>.state.num&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &#123;/</span>* react的合成事件 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;this.addNum&#125;&gt;React合成事件的按钮&lt;/</span>button&gt;</span><br><span class="line">                &#123;<span class="comment">/* 原生DOM事件 */</span>&#125;</span><br><span class="line">                &lt;button id=<span class="string">'btn'</span>&gt;绑定原生DOM事件的按钮&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &#123;/</span>* 定时器 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;this.addNumSet&#125;&gt;定时器&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Index;</span></span><br></pre></td></tr></table></figure>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hbb3d522c7afa45d894e583388f1615f4p.jpg" alt=""></p>
<h3 id="setState之后都发生了什么"><a href="#setState之后都发生了什么" class="headerlink" title="setState之后都发生了什么"></a>setState之后都发生了什么</h3><ul>
<li>合并 state</li>
<li>更新 state</li>
<li>然后看业务代码中是否实现生命周期方法 shouldComponentUpdate 有则调用，如果返回值为 false 则停止往下执行</li>
<li>然后是生命周期方法 componentWillUpdate</li>
<li>然后通过拿到新 state 的 instance 调用 render 方法拿到新的 element 和之旧的 element 的节点差异，然后根据差异对界面进行最小化重渲染</li>
<li>在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</li>
</ul>
<h3 id="传入-setState-函数的第二个参数的作用是什么？"><a href="#传入-setState-函数的第二个参数的作用是什么？" class="headerlink" title="传入 setState 函数的第二个参数的作用是什么？"></a>传入 setState 函数的第二个参数的作用是什么？</h3><p>该函数会在setState函数调用完成并且<code>组件开始重渲染</code>的时候被调用，我们可以用来监听该函数是否渲染完成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'xxxx'</span> &#125;,</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'更新完成'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="shouldComponentUpdate-的作用"><a href="#shouldComponentUpdate-的作用" class="headerlink" title="shouldComponentUpdate 的作用"></a>shouldComponentUpdate 的作用</h3><p>shouldComponentUpdate 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们<code>避免不必要的更新</code>,减少向下diff的规模，减少diff的成本</p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>Immer</title>
    <url>/2019/01/17/workspace/Frame/react/immer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Immer</strong></p>
<p>[[toc]]</p>
<h3 id="React中浅层次拷贝的问题"><a href="#React中浅层次拷贝的问题" class="headerlink" title="React中浅层次拷贝的问题"></a>React中浅层次拷贝的问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> detail = &#123;<span class="attr">name</span>:<span class="string">'和振峰'</span>,<span class="attr">school</span>:&#123;<span class="attr">loc</span>:<span class="string">'shijaizhuang'</span>&#125;&#125;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;,detail);</span><br><span class="line">copy.school.loc =<span class="string">"北京"</span>;</span><br><span class="line"><span class="comment">//此时你会发现我们的detail.school.loc也变成了"北京"了</span></span><br><span class="line">copy.school === detail.school</span><br><span class="line"><span class="comment">//此时copy.school和detail.school指向同一个对象，引用相同，一个值被修改那么另一个同样被修改</span></span><br></pre></td></tr></table></figure>

<p>要解决上面的问题，一定要深克隆，而不是浅层次的拷贝</p>
<h3 id="React中引用类型导致组件不更新"><a href="#React中引用类型导致组件不更新" class="headerlink" title="React中引用类型导致组件不更新"></a>React中引用类型导致组件不更新</h3><p><strong>栗子</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        ff: &#123;</span><br><span class="line">            a: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">school</span>: &#123;</span><br><span class="line">                location: <span class="string">"jing999.cn"</span>,</span><br><span class="line">                name: <span class="string">"和振峰"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;ff&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="comment">// ff.school.name = 11;  //[1]</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            ff: &#123;</span><br><span class="line">                ...ff,</span><br><span class="line">                school: &#123;</span><br><span class="line">                    location: <span class="string">"jing999.cn"</span>,</span><br><span class="line">                    name: <span class="number">11</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">//[2]</span></span><br><span class="line">        <span class="comment">// let data = produce(ff, draft =&gt; &#123;</span></span><br><span class="line">        <span class="comment">//     draft.school.name = 11;</span></span><br><span class="line">        <span class="comment">// &#125;); //[3]</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    shouldComponentUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">        <span class="comment">//[1]这里永远是true ,因为内存地址是完全一样的</span></span><br><span class="line">        <span class="comment">//[2]这里永远是false ,因为克隆后地址一直在变</span></span><br><span class="line">        <span class="comment">//[3]只有第一次是false,后面不会变，值变化后跟之前的一样，性能最高</span></span><br><span class="line">        <span class="built_in">console</span>.log(nextState.ff === <span class="keyword">this</span>.state.ff);</span><br><span class="line">        <span class="keyword">if</span> (nextState.ff === <span class="keyword">this</span>.state.ff) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.add&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &#123;this.state.ff.school.name&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index</span><br></pre></td></tr></table></figure>

<h3 id="简介不可变数据"><a href="#简介不可变数据" class="headerlink" title="简介不可变数据"></a>简介不可变数据</h3><p>React在减少重复渲染方面确实是有一套独特的处理办法，那就是虚拟DOM，但显然在首次渲染的时候React绝无可能超越原生的速度，或者一定能将其它的框架比下去。<br>但是每次数据变动都会执行render，大大影响了性能，特别是在移动端。</p>
<p>JavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。如 foo={a: 1}; bar=foo; bar.a=2 你会发现此时 foo.a 也被改成了 2。虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。</p>
<p>不可变数据就是一旦创建，就不能再被直接更改的数据。对Immutable 对象的任何修改或添加删除操作都会返回一个新的Immutable对象。<br>Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，<br>Immutable 使用了Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p>
<p><code>Object.freeze()</code> 方法可以冻结一个对象，冻结的对象不能添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。尝试修改会静默失败或抛出TypeError类型的错误。相关函数还包括：<br><code>Object.isExtensible()</code><br><code>Object.seal()</code> 和<code>Object.defineProperty()</code>均为ES5中定义的方法</p>
<h3 id="immerJS"><a href="#immerJS" class="headerlink" title="immerJS"></a>immerJS</h3><p>Immer是mobx的作者写的一个immutable库，核心实现是利用 ES6 的 <code>proxy</code>，几乎以最小的成本实现了js的不可变数据结构</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">"immer"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseState = [</span><br><span class="line">    &#123;</span><br><span class="line">        todo: <span class="string">"Learn typescript"</span>,</span><br><span class="line">        done: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        todo: <span class="string">"Try immer"</span>,</span><br><span class="line">        done: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextState = produce(baseState, draftState =&gt; &#123;</span><br><span class="line">    draftState.push(&#123;<span class="attr">todo</span>: <span class="string">"Tweet about it"</span>&#125;)</span><br><span class="line">    draftState[<span class="number">1</span>].done = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带深度合并的经典React.setState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">onBirthDayClick1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">        user: &#123;</span><br><span class="line">            ...prevState.user,</span><br><span class="line">            age: prevState.user.age + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ...但是，由于setState接受函数，</span></span><br><span class="line"><span class="comment"> * 上面相当于所有的东西都会重新渲染，用immerjs优化后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">onBirthDayClick2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(</span><br><span class="line">        produce(<span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//这里只有age发生的变化，state里面的值，他们的引用不会发生变化，不会引起不必要的更新</span></span><br><span class="line">            draft.user.age += <span class="number">1</span> </span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H7060e5bd80e044aea4ccda0edcf06f8e7.png" alt=""></p>
<p>上图可以：immer.js的方法修改了对象的某一个属性的时候，该属性的所有的父级属性的引用都会发生改变，而其他属性的引用都是共享</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nextState = produce(currentState, draftState =&gt; &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>主要思想就是先在currentState基础上生成一个代理draftState，之后的所有修改都会在draftState上进行，避免直接修改currentState，而当修改结束后，再从draftState基础上生成nextState。</strong></p>
<p>Immer内部使用Object.freeze()方法,只冻结nextState跟currentState<code>相比修改</code>的部分</p>
<ul>
<li>优点:<ul>
<li>降低了 Mutable 带来的复杂度</li>
<li>节省内存</li>
<li>Undo/Redo (因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。)</li>
<li>拥抱函数式编程 (纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。)</li>
</ul>
</li>
</ul>
<ul>
<li>对比ImmutableJS<ul>
<li>增加了资源文件大小(压缩后代码大小16K，immer是4k)</li>
<li>需要使用者学习它的数据结构操作方式，没有 Immer 提供的使用<code>原生对象</code>的操作方式简单、易用；</li>
<li>它的操作结果需要通过toJS方法才能得到原生对象，这使得在操作一个对象的时候，时刻要主要操作的是原生对象还是 ImmutableJS 的返回结果，稍不注意，就会产生意想不到的 bug。</li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="immutable-js"><a href="#immutable-js" class="headerlink" title="immutable.js"></a>immutable.js</h4><p>看看Immutable怎么使用的，谁能保证以后一定不用这个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Immutable <span class="keyword">from</span> <span class="string">"immutable"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map1 = Immutable.Map(&#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">3</span>,<span class="attr">school</span>:&#123;</span><br><span class="line">    location:<span class="string">"shijiazhuang"</span>,</span><br><span class="line">    name :<span class="string">"和振峰"</span></span><br><span class="line"> &#125;&#125;);</span><br><span class="line"><span class="keyword">let</span> map2 = map1.set(<span class="string">'b'</span>, <span class="number">50</span>);<span class="comment">//我这里仅仅设置了b的值，那么其他的值都会共享</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map1) <span class="comment">//返回的是一个Map的对象，不能直接在原数据更改</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'引用相等'</span>,map1===map2); <span class="comment">//immutable.js中每次返回的引用都是不一样的，此处返回false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'school的引用没有变化'</span>,map2.school===map1.school);<span class="comment">//immutable.js中没有变化的对象将会共享，所以此处返回true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map3 = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">let</span> map4 = map3; <span class="comment">//map4拿到的是map3的指针，所以一个变化后另外一个也会变化，但是变化的是值，引用本身是不变化的，所以map3===map4返回true</span></span><br><span class="line">map4.c =<span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'map3===map4'</span>,map3===map4);</span><br></pre></td></tr></table></figure>

<h4 id="Immer-js"><a href="#Immer-js" class="headerlink" title="Immer.js"></a>Immer.js</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">"immer"</span></span><br><span class="line"><span class="keyword">let</span> map1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">school</span>: &#123;</span><br><span class="line">        location: <span class="string">"shijiazhuang"</span>,</span><br><span class="line">        name: <span class="string">"和振峰"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> map2 = produce(map1, draft =&gt; &#123;</span><br><span class="line">    draft.b = <span class="number">50</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(map2);  <span class="comment">//跟源原对象一样的类型</span></span><br><span class="line"><span class="comment">// console.log(map2.a = 100); // Cannot assign to `read only` property 'a' of object  要保持跟源对象一致，值类型不能被修改</span></span><br><span class="line"><span class="built_in">console</span>.log(map1 === map2);  <span class="comment">//false  此处跟immutable一致，每次返回的引用都是不一样的</span></span><br><span class="line"><span class="built_in">console</span>.log(map1.school === map2.school);  <span class="comment">//没有变化的对象将会共享</span></span><br><span class="line"><span class="built_in">console</span>.log(map2.school.name = <span class="number">1</span>);  <span class="comment">//school的引用地址没有发生改变，可以修改,双方发生变化  不建议修改</span></span><br></pre></td></tr></table></figure>

<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>为什么你要在React.js中使用Immutable Data熟悉React.js的都应该知道，React.js是一个UI = f(states)的框架，为了解决更新的问题，React.js使用了virtual dom，virtual dom通过diff修改dom，来实现高效的dom更新。听起来很完美吧，但是有一个问题。<br>当state更新时，如果子组件数据没变，你也会去做virtual dom的diff，这就产生了浪费。</p>
<ol>
<li>与 React 搭配使用，Pure Render<br>熟悉 React 的都知道，React 做性能优化时有一个避免重复渲染的大招，就是使用 <code>shouldComponentUpdate()</code>，但它默认返回 <code>true</code>，即始终会执行 <code>render()</code> 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 更新，这里往往会带来很多无必要的渲染并成为性能瓶颈。</li>
</ol>
<p>当然我们也可以在 <code>shouldComponentUpdate()</code> 中使用使用 deepCopy 和 deepCompare 来避免无必要的 <code>render()</code>，但 <strong>deepCopy 和 deepCompare 一般都是非常耗性能的</strong>。</p>
<ol start="2">
<li>React 建议把 <code>this.state</code> 当作 Immutable 的，因为之前修改前需要做一个 deepCopy，显得麻烦</li>
<li>与 Redux 搭配使用</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://immerjs.github.io/immer/docs/introduction" target="_blank" rel="noopener">官方文档</a></p>
<p><a href="https://github.com/camsong/blog/issues/3" target="_blank" rel="noopener">Immutable 详解及 React 中实践</a></p>
<p><a href="http://file.jing999.cn/workspace/Project/immutable.html">seamless-immutable</a></p>
<p><a href="https://segmentfault.com/a/1190000015426465" target="_blank" rel="noopener">Immer.js简析</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>React</category>
        <category>Immer</category>
      </categories>
  </entry>
  <entry>
    <title>Hooks</title>
    <url>/2019/10/17/workspace/Frame/react/react-hooks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Hooks</strong></p>
<p>[[toc]]</p>
<h3 id="Hook的规则"><a href="#Hook的规则" class="headerlink" title="Hook的规则"></a>Hook的规则</h3><ul>
<li>只在最顶层使用 Hook<ul>
<li>不要在<code>循环</code>，<code>条件</code>或<code>嵌套函数</code>中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的 <strong><code>顺序</code></strong> 被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。</li>
</ul>
</li>
<li>只在 React 函数中调用 Hook     <ul>
<li>在 React 的函数组件中调用 Hook</li>
<li>在自定义 Hook 中调用其他 Hook<ul>
<li><strong>在类中使用报错警告</strong> 「Hooks can only be called inside the body of a function component」</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用Hooks的好处"><a href="#使用Hooks的好处" class="headerlink" title="使用Hooks的好处"></a>使用Hooks的好处</h3><p><strong>1.class 学习成本高</strong><br/><br>生命周期，this指向啥的，hooks只要会usestate   useeffect差不多能解决所有问题<br/><br><strong>2.class业务逻辑分散</strong><br/><br>定时器，dom2事件啥的一定要在componentWillUnMount 去卸载。而是用hooks就非常聚合了，直接返回函数里面清楚就可以了<br/><br><strong>3.class逻辑复用困难</strong><br/><br>hooks最有优势的就数她的逻辑复用能力了<br/><br>在class中一般用Render Props（局限性）和高阶组件（嵌套太深）做逻辑复用<br/><br>比如一个列表渲染，class每次都要写数据请求，下拉加载，上拉刷新重置分页，loading展示，而在hooks里直接自定义一个hooks就可以做到全部的列表加载逻辑公用<br/><br><strong>4.</strong> class 打包时无法对 class 的属性方法进行优化，而使用 hooks 则可以将代码压缩到极致。<br/><br><strong>5.</strong> 最直接的就是业务变更的时候不需要再把函数式组件变成class了</p>
<p><strong>缺点</strong><br/><br>形成太多闭包，容易导致内存泄漏<br/><br>function写太多代码后期不好维护</p>
<p><strong>自定义过的</strong><br/><br>useFetch<br/><br>useMouse<br/><br>useScroll<br/><br>useSize<br/><br>useFrom<br/><br>useTable<br/><br>useStore<br/></p>
<p>真正说服我使用 react hooks 的，是 react blog 里面提到的，使用 class component 打包时无法对 class 的属性方法进行优化，而<strong>使用 hooks 则可以将代码压缩到极致</strong>。<br/><br>有人会说 hooks 是趋势是未来啥的，但是，实际上，hooks 比 class 复杂和难理解多了，而且随着业务逻辑的增长，一个 function 里面将会写出越来越多的代码，<br>越来越复杂，让你无法维护。而实际上，在运行时，两则的差别不是特别大，都没有性能上的优劣。<br/></p>
<h3 id="Hooks的方法"><a href="#Hooks的方法" class="headerlink" title="Hooks的方法"></a>Hooks的方法</h3><table>
<thead>
<tr>
<th align="left"><span style='display: block;text-align: left;'> 钩子名</span></th>
<th align="left"><span style='display: block;text-align: left;'> 作用</span></th>
</tr>
</thead>
<tbody><tr>
<td align="left">useState</td>
<td align="left">初始化和设置状态</td>
</tr>
<tr>
<td align="left">useEffect</td>
<td align="left">componentDidMount，componentDidUpdate和componentWillUnmount和结合体,所以可以监听useState定义值的变化</td>
</tr>
<tr>
<td align="left">useContext</td>
<td align="left">定义一个全局的对象,类似 context</td>
</tr>
<tr>
<td align="left">useReducer</td>
<td align="left">可以增强函数提供类似 Redux 的功能</td>
</tr>
<tr>
<td align="left">useCallback</td>
<td align="left">记忆作用,共有两个参数，第一个参数为一个匿名函数，就是我们想要创建的函数体。第二参数为一个数组，里面的每一项是用来判断是否需要重新创建函数体的变量，如果传入的变量值保持不变，返回记忆结果。如果任何一项改变，则返回新的结果</td>
</tr>
<tr>
<td align="left">useMemo</td>
<td align="left">作用和传入参数与 useCallback 一致,useCallback返回函数,useDemo 返回值</td>
</tr>
<tr>
<td align="left">useRef</td>
<td align="left">获取 ref 属性对应的 dom</td>
</tr>
<tr>
<td align="left">useImperativeMethods</td>
<td align="left">自定义使用ref时公开给父组件的实例值</td>
</tr>
<tr>
<td align="left">useLayoutEffect</td>
<td align="left">作用与useEffect相同，但在所有DOM改变后同步触发</td>
</tr>
<tr>
<td align="left">useDebugValue</td>
<td align="left">useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。</td>
</tr>
</tbody></table>
<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;直接传入初始值</span><br><span class="line">const [state, setState] &#x3D; useState(initialState);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用</span><br><span class="line">const [state, setState] &#x3D; useState(() &#x3D;&gt; &#123;</span><br><span class="line">  const initialState &#x3D; ff(props);</span><br><span class="line">  return initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>官方建议推荐把 state 切分成多个 state 变量，每个变量包含的不同值会在同时发生变化。</p>
<p><strong>好处是</strong></p>
<ul>
<li>后期把一些相关的逻辑抽取到一个自定义 Hook 变得容易<br/></li>
<li>赋值的时候简单，多个需要克隆下，把不变的存储下来</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setState(state+<span class="number">1</span>);  <span class="comment">//直接从初始值里面获取</span></span><br><span class="line">setState(<span class="function"><span class="params">prevState</span>=&gt;</span>prevState+<span class="number">1</span>) <span class="comment">//该函数将接收先前的state,并返回一个更新后的值</span></span><br></pre></td></tr></table></figure>

<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p><code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>：useEffect Hook 可以表达所有这些(包括 不那么 常见 的场景)的组合。</p>
<p>默认情况下，effect 将在每轮<code>渲染结束后执行</code>，但你可以选择让它 在只有<code>某些值改变</code>的时候 才执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    const timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">      setCount(c &#x3D;&gt; c + 1); </span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    return () &#x3D;&gt; clearInterval(timer);</span><br><span class="line">  &#125;, []); </span><br><span class="line">  return &lt;h1&gt;&#123;count&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，<code>上一个 effect 就已被清除</code>。看下个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Fragment, useState, useEffect, useRef&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Example &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(1);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;11&quot;);</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&quot;22&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &#123;console.log(&quot;渲染&quot;)&#125;</span><br><span class="line">            &lt;h1&gt;&#123;count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123;</span><br><span class="line">                setCount(count + 1)</span><br><span class="line">            &#125;&#125;&gt; +</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H66bfd87154314ad49baee2dd855336acT.gif" alt=""></p>
<p>打印的顺序为 <strong>渲染-&gt;22-&gt;11</strong></p>
<p>若多次执行effect，其内部会生成新的函数，（effect还是原函数，或者说指向原地址）这样的话如果我是定义的事件，每次更新都会执行，那么岂不是在事件还没有移除掉又定义了一次，所以useEffect加入了这个功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;useState, useEffect&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Example &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const [width, setWidth] &#x3D; useState(window.innerWidth);</span><br><span class="line">    const [count, setCount] &#x3D; useState(1);</span><br><span class="line">    const resizeHandle &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        setWidth(window.innerWidth);</span><br><span class="line">        console.log(window.innerWidth);</span><br><span class="line">    &#125;;</span><br><span class="line">    const a &#x3D; useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        window.addEventListener(&quot;resize&quot;, resizeHandle);</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; window.removeEventListener(&quot;resize&quot;, resizeHandle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);  &#x2F;&#x2F;或者使用[]</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;h1&gt;&#123;width&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123;</span><br><span class="line">                setCount(count + 1)</span><br><span class="line">            &#125;&#125;&gt;+</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>

<p>看下面图片可以看出来，重复多次执行了<code>resize</code>方法</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H9d109cbe0722447baf4ef132fa24268fE.gif" alt=""></p>
<p><a href="http://file.jing999.cn/workspace/Frame/react/use-hooks.html#useeffect%E5%9C%A8%E5%A4%96%E9%9D%A2%E5%A3%B0%E6%98%8E%E5%87%BD%E6%95%B0'">官方建议effect使用的方法声明在其内部</a></p>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p>React16中更新了Context API，Context主要用于爷孙组件的传值问题，新的Context API使用订阅发布者模式方式实现在爷孙组件中传值</p>
<p>React Hooks出现之后也对Context API出了响应的Hook useContext。同样也是解传值的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const stateContext &#x3D; createContext(&#39;default&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&lt;stateContext.Provider</span><br><span class="line">    value&#x3D;&#123;&quot;Hello React&quot;&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;ContextComponent&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;stateContext.Provider&gt;</span><br><span class="line">&#x2F;&#x2F;子组件 </span><br><span class="line">const ContextComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const value &#x3D; useContext(stateContext);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;h1&gt;&#123;value&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，使用<code>useContext仍然需要在上层组件中使用&lt;MyContext.Provider&gt;</code>来为下层组件提供context。</p>
<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>看到<code>useReducer</code>,肯定会想到Redux，没错它和Redux的工作方式是一样的。useReducer的出现是useState的替代方案，能够让我们更好的管理状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>

<p>在某些场景下，useReducer 会比 useState 更适用，例如 state <code>逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state</code>等。<br>并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，<code>因为你可以向子组件传递 dispatch 而不是回调函数</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const initialState &#x3D; &#123;count: 0&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#39;increment&#39;:</span><br><span class="line">      return &#123;count: state.count + 1&#125;;</span><br><span class="line">    case &#39;decrement&#39;:</span><br><span class="line">      return &#123;count: state.count - 1&#125;;</span><br><span class="line">    default:</span><br><span class="line">      throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const [state, dispatch] &#x3D; useReducer(reducer, initialState);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三个参数(惰性初始化)</strong></p>
<p>useReducer的第三个参数接受一个函数作为参数，并把第二个参数当作函数的参数执行。主要作用是初始值的惰性求值，把一些对状态的逻辑抽离出来，有利于重置state。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Fragment, useState, useEffect, useRef, useCallback, useMemo, useReducer&#125; from &quot;react&quot;;</span><br><span class="line">const initialState &#x3D; &#123;count: 0&#125;;</span><br><span class="line">function init(s) &#123;</span><br><span class="line">    console.log(s);</span><br><span class="line">    return &#123;...s&#125;;</span><br><span class="line">&#125;</span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#39;increment&#39;:</span><br><span class="line">            return &#123;count: state.count + 1&#125;;</span><br><span class="line">        case &#39;decrement&#39;:</span><br><span class="line">            return &#123;count: state.count - 1&#125;;</span><br><span class="line">        case &#39;reset&#39;:</span><br><span class="line">            return init(action.payload);</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, initialState, init);</span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            Count: &#123;state.count&#125;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;reset&#39;, payload: initialState&#125;)&#125;&gt;重置&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default Counter</span><br></pre></td></tr></table></figure>

<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>返回一个memoized回调<code>函数</code>。</p>
<p><a href="http://file.jing999.cn/workspace/Frame/react/use-hooks.html#usecallback%E7%A4%BA%E4%BE%8B%E4%BD%95%E6%97%B6%E6%9B%B4%E6%96%B0">下面介绍的使用方式</a></p>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>返回一个memoized<code>值</code>。</p>
<p>useMemo和useCallback很像，唯一不同的就是</p>
<p>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。</p>
<p>公用的<code>方法</code>用<code>useCallback</code>,若是直接<code>渲染值</code>则用<code>useMemo</code>，用<code>useCallback</code>的话也是每次都要执行的，但是<code>useMemo</code>是直接把值记忆存储了（前面的都是废话，其实都能实现，不过这样更符合习惯）</p>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>本质上<code>useRef</code>就像是可以在其<code>.current</code>属性中保存一个可变值的“盒子”，<code>useRef(null)返回值</code>是不可拓展的属性,<code>.current</code>可以。</p>
<p>下篇文章介绍如何使用而useRef自己最新的值，或者存储上一次props或者state的值；我们直接声明一个值存储当前的值不好吗，为啥要借助useRef()</p>
<p><strong>这是因为它创建的是一个普通Javascript对象。而useRef()和自建一个 {current: …}对象的唯一区别是，useRef会在每次渲染时返回同一个ref对象。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Fragment, useState, useEffect, useRef, useCallback, useMemo, useReducer&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Example &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    let inputRef &#x3D; useRef(null);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        inputRef.current.focus();</span><br><span class="line">    &#125;, []);</span><br><span class="line">    return (</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;inputRef&#125;&#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>


<h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>

<p><code>useImperativeHandle</code>可以让你在使用 ref 时<code>自定义</code>暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <code>forwardRef</code> 一起使用</p>
<p>就是说：当我们使用父组件把ref传递给子组件的时候，这个Hooks允许在子组件中把自定义实例附加到父组件传过来的ref上，有利于父组件控制子组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;</span><br><span class="line">    Fragment,</span><br><span class="line">    useRef,</span><br><span class="line">    useImperativeHandle,</span><br><span class="line">    forwardRef,</span><br><span class="line">    useEffect</span><br><span class="line">&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">function FancyInput(props, ref) &#123;</span><br><span class="line">    const inputRef &#x3D; useRef();</span><br><span class="line">    useImperativeHandle(ref, () &#x3D;&gt; (</span><br><span class="line">        &#123;</span><br><span class="line">            addText: () &#x3D;&gt; &#123;</span><br><span class="line">                inputRef.current.value &#x3D; &quot;我是由父级添加的&quot;;</span><br><span class="line">            &#125;,</span><br><span class="line">            focus: () &#x3D;&gt; &#123;</span><br><span class="line">                inputRef.current.focus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ));</span><br><span class="line">    return &lt;input ref&#x3D;&#123;inputRef&#125;&#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const TempFancyInput &#x3D; forwardRef(FancyInput);</span><br><span class="line"></span><br><span class="line">const Example &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    let ref &#x3D; useRef(null);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(ref);</span><br><span class="line">        ref.current.addText();</span><br><span class="line">        ref.current.focus();</span><br><span class="line">    &#125;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;TempFancyInput ref&#x3D;&#123;ref&#125;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H3eab0df2695d4654a1f9e9a9b1f20edem.png" alt=""></p>
<h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p>这个钩子函数与useEffect相同，但它会在所有的DOM变更之后<code>同步</code>调用effect。可以使用它来读取DOM布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p>
<p>官网建议还是尽可能的是使用标准的useEffec以避免阻塞视觉更新。</p>
<h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3><p>useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。</p>
<h3 id="自定义-Hook-必须以-use-开头吗？"><a href="#自定义-Hook-必须以-use-开头吗？" class="headerlink" title="自定义 Hook 必须以 use 开头吗？"></a>自定义 Hook 必须以 use 开头吗？</h3><p>必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的<a href="https://react.docschina.org/docs/hooks-rules.html" target="_blank" rel="noopener">规则</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useWinResize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> [size, setSize] = useState(&#123;</span><br><span class="line">     width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">     height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">const</span> resize = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     setSize(&#123;</span><br><span class="line">     width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">     height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125;, [])</span><br><span class="line"> useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, resize);</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, resize);</span><br><span class="line"> &#125;, []);</span><br><span class="line"> <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123;width, height&#125; = useWinResize();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>width: &#123;width&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>height: &#123;height&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="面试题示例"><a href="#面试题示例" class="headerlink" title="面试题示例"></a>面试题示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Fragment, useState, useEffect, useRef, useCallback&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">const</span> useInterval = <span class="function">(<span class="params">callback, delay</span>) =&gt;</span> &#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delay !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> id = setInterval(callback, delay);</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [delay]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [diff, setDiff] = useState(<span class="number">500</span>);</span><br><span class="line">    useInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;, diff);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;p&gt; count: &#123;count&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt; diff: &#123;diff&#125;ms &lt;/</span>p&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; setDiff(diff - <span class="number">50</span>)&#125;&gt; 加快<span class="number">50</span>ms&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;() =&gt; setDiff(diff + 50)&#125;&gt; 减慢50ms&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure>

<p>可是这段运行后很奇怪，页面从0到1后，就再也不变了，console.log(count)的输出表明代码并没有卡死，那么问题出在哪儿了？<br/><br>React组件中的props和state是可以改变的，React会重渲染它们且「丢弃」任何关于上一次渲染的结果，它们之间不再有相关性。<br/><br>useEffect()Hook也「丢弃」上一次渲染结果，它会清除上一次effect再建立下一个effect，下一个effect<code>锁住新的props和state</code>，这也是我们第一次尝试简单示例可以正确工作的原因。<br/><br>但setInterval不会「丢弃」。它会一直引用老的props和state直到你把它换掉——不重置时间你是无法做到的。这里就要用到useRef这个hook了，我们把callback存储到ref中，当callback更新时去更新ref.current的值：</p>
<p>两种方法:【一种是把count存起来，一种是把定时器里面的函数存起来】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Fragment, useState, useEffect, useRef, useCallback&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">const</span> useInterval = <span class="function">(<span class="params">callback, delay, val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> saveCallback = useRef();</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        saveCallback.current = val</span><br><span class="line">    &#125;,[val]);</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delay !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> callback(saveCallback.current), delay);</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [delay]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [diff, setDiff] = useState(<span class="number">500</span>);</span><br><span class="line">    useInterval(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        setCount(val + <span class="number">1</span>);</span><br><span class="line">    &#125;, diff, count);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;p&gt; count: &#123;count&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt; diff: &#123;diff&#125;ms &lt;/</span>p&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; setDiff(diff - <span class="number">50</span>)&#125;&gt; 加快<span class="number">50</span>ms&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;() =&gt; setDiff(diff + 50)&#125;&gt; 减慢50ms&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// const useInterval = (callback, delay) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     const saveCallback = useRef();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         // 每次渲染后，保存新的回调到我们的 ref 里</span></span><br><span class="line"><span class="comment">//         saveCallback.current = callback;</span></span><br><span class="line"><span class="comment">//     &#125;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         function tick() &#123;</span></span><br><span class="line"><span class="comment">//             saveCallback.current();  //每次执行最新的callback</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         if (delay !== null) &#123;</span></span><br><span class="line"><span class="comment">//             let id = setInterval(tick, delay);</span></span><br><span class="line"><span class="comment">//             return () =&gt; clearInterval(id);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;, [delay]);</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure>

<h3 id="Hooks-FAQ"><a href="#Hooks-FAQ" class="headerlink" title="Hooks FAQ"></a><code>Hooks FAQ</code></h3><h4 id="useEffect在外面声明函数"><a href="#useEffect在外面声明函数" class="headerlink" title="useEffect在外面声明函数"></a>useEffect在外面声明函数</h4><p><strong>一般来说，不安全</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(someProp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 这样不安全（它调用的 `doSomething` 函数使用了 `someProp`）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要记住 effect 外部的函数使用了哪些 props 和 state 很难。这也是为什么 通常你会想要在 effect 内部 去声明它所需要的函数。 这样就能容易的看出那个 effect 依赖了组件作用域中的哪些值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(someProp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doSomething();</span><br><span class="line">  &#125;, [someProp]); <span class="comment">// ✅ 安全（我们的 effect 仅用到了 `someProp`）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果处于某些原因你无法把一个函数移动到effect内部，还有一些其他办法：</strong></p>
<ul>
<li><p>你可以尝试把那个函数移动到你的组件之外。那样一来，这个函数就肯定不会依赖任何 props,或state并且也不用出现在依赖列表中了。</p>
</li>
<li><p>如果你所调用的方法是一个纯计算，并且可以在渲染时调用，你可以 转而在 effect 之外调用它， 并让 effect 依赖于它的返回值。</p>
</li>
<li><p>万不得已的情况下，你可以把函数加入effect的依赖但 把它的定义包裹 进<code>useCallback Hook</code>。这就确保了它不随渲染而改变，除非 它自身 的依赖发生了改变</p>
</li>
</ul>
<h4 id="如何获取上一轮的-props-或-state"><a href="#如何获取上一轮的-props-或-state" class="headerlink" title="如何获取上一轮的 props 或 state"></a>如何获取上一轮的 props 或 state</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Fragment, useState, useEffect, useRef&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePrevious</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ref = useRef();</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ref.current = value;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ref.current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> prevCount = usePrevious(count);</span><br><span class="line">    <span class="comment">//此时prevCount是上一次的effect的调用，内部已经改变,只是没有重新渲染</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)  <span class="comment">//先渲染后执行这个effect</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Now: &#123;count&#125;, before: &#123;prevCount&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;div onClick=&#123;() =&gt; setCount((val) =&gt; val + 1)&#125;&gt;</span><br><span class="line">            点击加一</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example</span><br></pre></td></tr></table></figure>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hd6588fe44428462c90a0d7ee879c5948a.gif" alt=""></p>
<p>考虑到这是一个相对常见的使用场景，很可能在未来 React 会自带一个 usePrevious Hook。</p>
<h4 id="为什么我修改后在别的函数中获取的还是上一次的值"><a href="#为什么我修改后在别的函数中获取的还是上一次的值" class="headerlink" title="为什么我修改后在别的函数中获取的还是上一次的值"></a>为什么我修改后在别的函数中获取的还是上一次的值</h4><p>组件内部的任何函数，包括事件处理函数和 effect，都是从它<code>被创建</code>的那次渲染中拿到的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;useState, useRef&#125; from &quot;react&quot;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0);</span><br><span class="line">    function handleClick() &#123;</span><br><span class="line">        console.log(count,&#39;函数内部&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    const add &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        let val &#x3D; count + 1;</span><br><span class="line">        setCount(val);</span><br><span class="line">        handleClick()</span><br><span class="line">    &#125;;</span><br><span class="line">     console.log(count,&#39;函数外面&#39;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;add&#125;&gt;</span><br><span class="line">                点击我</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;</span><br><span class="line">                获取值</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default Example;</span><br></pre></td></tr></table></figure>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H70f6508f638a4c35bb9d095a2a5fde9cE.gif" alt=""></p>
<p>你发现<code>handleClick</code>每次获取的都是上一次的值，<strong>因为它获取的是创建它的那次值</strong>，此时可以用<code>useRef</code>曲线救国</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;useState, useRef&#125; from &quot;react&quot;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0);</span><br><span class="line">    const ref &#x3D; useRef();</span><br><span class="line">    function handleClick() &#123;</span><br><span class="line">        console.log(count, ref.current);</span><br><span class="line">    &#125;</span><br><span class="line">    const add &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        let val &#x3D; count + 1;</span><br><span class="line">        setCount(val);</span><br><span class="line">        ref.current &#x3D; val;</span><br><span class="line">        handleClick()</span><br><span class="line">    &#125;;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;add&#125;&gt;</span><br><span class="line">                点击我</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;</span><br><span class="line">                获取值</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default Example;</span><br></pre></td></tr></table></figure>

<h4 id="获取DOM-节点"><a href="#获取DOM-节点" class="headerlink" title="获取DOM 节点"></a>获取DOM 节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Fragment,useState, useRef, useCallback&#125; from &quot;react&quot;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    const [width, setWidth] &#x3D; useState(0);</span><br><span class="line">    &#x2F;&#x2F; const inputEl &#x3D; useRef(null)</span><br><span class="line">    &#x2F;&#x2F; useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;      setWidth(inputEl.current.getBoundingClientRect().width);</span><br><span class="line">    &#x2F;&#x2F; &#125;);</span><br><span class="line">          </span><br><span class="line">    let ref &#x3D; useCallback(node &#x3D;&gt; &#123;</span><br><span class="line">        if (node !&#x3D;&#x3D; null) &#123;</span><br><span class="line">            setWidth(node.getBoundingClientRect().width);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, []);</span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;h1 ref&#x3D;&#123;ref&#125;&gt;Hello, world&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;h2&gt;当前屏幕宽度为 &#123;Math.round(width)&#125;px&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>
<p>这里我们没有选择使用<code>useRef</code>，用的ref的回调函数，因为当ref是一个对象时它并不会把当前ref的值的变化通知到我们，最终还是要借助effect来实现「代码如上」</p>
<p><strong>抽离出来</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;useState, useRef, useCallback&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const useClientRect &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const [width, setWidth] &#x3D; useState(0);</span><br><span class="line">    let ref &#x3D; useCallback(node &#x3D;&gt; &#123;</span><br><span class="line">        if (node !&#x3D;&#x3D; null) &#123;</span><br><span class="line">            setWidth(node.getBoundingClientRect().width);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, []);</span><br><span class="line">    return [width, ref]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">    const [width, ref] &#x3D; useClientRect(0);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;h1 ref&#x3D;&#123;ref&#125;&gt;Hello, world&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;h2&gt;当前屏幕宽度为 &#123;Math.round(width)&#125;px&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>

<h4 id="useCallback示例何时更新"><a href="#useCallback示例何时更新" class="headerlink" title="useCallback示例何时更新"></a>useCallback示例何时更新</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Fragment, useState, useEffect, useRef, useCallback&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const set1 &#x3D; new Set();</span><br><span class="line"></span><br><span class="line">let c &#x3D; 21;&#x2F;&#x2F;【2】</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    name: &quot;hzf&quot;</span><br><span class="line">&#125;;&#x2F;&#x2F;【1】如果是对象的话，他会指向一个地址，除非改变地址他才会重新执行useCallback，否则他返回的是上次缓存的函数</span><br><span class="line"></span><br><span class="line">function Form() &#123;</span><br><span class="line">    const [text, updateText] &#x3D; useState(&#39;&#39;);</span><br><span class="line">    const textRef &#x3D; useRef();</span><br><span class="line"></span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        c &#x3D; Math.random(); &#x2F;&#x2F;【2】</span><br><span class="line"></span><br><span class="line">        textRef.current &#x3D; text;</span><br><span class="line"></span><br><span class="line">        obj &#x3D; &#123;...textRef&#125;; &#x2F;&#x2F;【1】</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const handleSubmit &#x3D; useCallback(() &#x3D;&gt; &#123;</span><br><span class="line">        const currentText &#x3D; textRef.current;</span><br><span class="line">        console.log((currentText));</span><br><span class="line">    &#125;, [obj]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    set1.add(handleSubmit);</span><br><span class="line">    console.log(set1.size);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;input value&#x3D;&#123;text&#125; onChange&#x3D;&#123;e &#x3D;&gt; updateText(e.target.value)&#125;&#x2F;&gt;</span><br><span class="line">            &#123;&#x2F;*&lt;div&gt;&#123;textRef.current&#125;&lt;&#x2F;div&gt;*&#x2F;&#125;</span><br><span class="line">            &lt;div&gt;&#123;c&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;handleSubmit&#125;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Form</span><br></pre></td></tr></table></figure>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H7410c03e8eab4361b28a18bfce16c4ba9.gif" alt=""></p>
<p>由此可见obj每次执行都要<code>浅克隆</code>，useCallback依赖于<code>obj</code>所以每次都会生成新的函数。</p>
<h4 id="useMemo优化组件"><a href="#useMemo优化组件" class="headerlink" title="useMemo优化组件"></a>useMemo优化组件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Example(&#123; a, b &#125;) &#123;</span><br><span class="line">  &#x2F;&#x2F; Only re-rendered if &#96;a&#96; changes:</span><br><span class="line">  const child1 &#x3D; useMemo(() &#x3D;&gt; &lt;Child1 a&#x3D;&#123;a&#125; &#x2F;&gt;, [a]);</span><br><span class="line">  &#x2F;&#x2F; Only re-rendered if &#96;b&#96; changes:</span><br><span class="line">  const child2 &#x3D; useMemo(() &#x3D;&gt; &lt;Child2 b&#x3D;&#123;b&#125; &#x2F;&gt;, [b]);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;child1&#125;</span><br><span class="line">      &#123;child2&#125;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>
<p><code>注意这种方式在循环中是无效的</code></p>
<h4 id="如何向下传递回调？"><a href="#如何向下传递回调？" class="headerlink" title="如何向下传递回调？"></a>如何向下传递回调？</h4><p>我们已经发现大部分人并不喜欢在组件树的每一层手动传递回调。尽管这种写法更明确，但这给人感觉像错综复杂的管道工程一样麻烦。</p>
<p>在<code>大型</code>的组件树中建议使用 context 用 useReducer 往下传一个 <code>dispatch</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TodosDispatch &#x3D; React.createContext(null);</span><br><span class="line"></span><br><span class="line">function TodosApp() &#123;</span><br><span class="line">  &#x2F;&#x2F; 提示：&#96;dispatch&#96; 不会在重新渲染之间变化</span><br><span class="line">  const [todos, dispatch] &#x3D; useReducer(todosReducer);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;TodosDispatch.Provider value&#x3D;&#123;dispatch&#125;&gt;</span><br><span class="line">      &lt;DeepTree todos&#x3D;&#123;todos&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;TodosDispatch.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function DeepTree(props) &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。</span><br><span class="line">  const dispatch &#x3D; useContext(TodosDispatch);</span><br><span class="line"></span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    dispatch(&#123; type: &#39;add&#39;, text: &#39;hello&#39; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;Add todo&lt;&#x2F;button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义Hooks"><a href="#自定义Hooks" class="headerlink" title="自定义Hooks"></a>自定义Hooks</h3><h4 id="useFetch"><a href="#useFetch" class="headerlink" title="useFetch"></a>useFetch</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useDataApi = <span class="function">(<span class="params">initialUrl, initialData</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> [data, setData] = useState(initialData);</span><br><span class="line">    <span class="keyword">const</span> [url, setUrl] = useState(initialUrl);</span><br><span class="line">    <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> [isError, setIsError] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">            setIsError(<span class="literal">false</span>);</span><br><span class="line">            setIsLoading(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> result = <span class="keyword">await</span> fetch(url).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json());</span><br><span class="line">                <span class="comment">// const result = await axios.get(url);</span></span><br><span class="line">                setData(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                setIsError(<span class="literal">true</span>);</span><br><span class="line">                setData(initialData);</span><br><span class="line">            &#125;</span><br><span class="line">            setIsLoading(<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    fetchData();</span><br><span class="line">    &#125;, [url]);</span><br><span class="line">    <span class="keyword">return</span> [&#123;data, isLoading, isError&#125;, setUrl];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Hooks原理分析"><a href="#Hooks原理分析" class="headerlink" title="Hooks原理分析"></a>Hooks原理分析</h3><h4 id="简单实现一个useState"><a href="#简单实现一个useState" class="headerlink" title="简单实现一个useState"></a>简单实现一个useState</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _state;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialValue</span>)</span>&#123;</span><br><span class="line">    _state = _state || initialValue;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>)</span>&#123;</span><br><span class="line">        _state = newState;</span><br><span class="line">        render()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [_state,setState]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setState第一个参数可以使函数，当为函数的时候，参数为当前的_state</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _state;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialValue</span>)</span>&#123;</span><br><span class="line">    _state = _state || initialValue;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">fun</span>)</span>&#123;</span><br><span class="line">        _state = fun(_state) || _state</span><br><span class="line">        render()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [_state,setState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCount(<span class="function"><span class="params">state</span>=&gt;</span>state+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">"antd"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./styles.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _state; <span class="comment">// 把 state 存储在外面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  _state = _state | initialValue; <span class="comment">// 如果没有 _state，说明是第一次执行，把 initialValue 复制给它</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>) </span>&#123;</span><br><span class="line">    _state = newState;</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [_state, setState];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;&#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button</span></span><br><span class="line"><span class="regexp">        onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          setCount(count + 1);</span></span><br><span class="line"><span class="regexp">        &#125;&#125;</span></span><br><span class="line"><span class="regexp">      &gt;</span></span><br><span class="line"><span class="regexp">        点击1</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function render() &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(&lt;App /</span>&gt;, rootElement);</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<h4 id="简单实现一个useEffect"><a href="#简单实现一个useEffect" class="headerlink" title="简单实现一个useEffect"></a>简单实现一个useEffect</h4><p>dependencies:依赖关系</p>
<p>Effect有几个特点</p>
<ul>
<li>有两个参数 callback 和 dependencies 数组</li>
<li>如果 dependencies 不存在，那么 callback 每次 render 都会执行</li>
<li>如果 dependencies 存在，只有当它发生了变化， callback 才会执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _deps; <span class="comment">// _deps 记录 useEffect 上一次的 依赖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, depArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hasNoDeps = !depArray; <span class="comment">// 如果 dependencies 不存在</span></span><br><span class="line">  <span class="keyword">const</span> hasChangedDeps = (_deps</span><br><span class="line">    ? !depArray.every(<span class="function">(<span class="params">el, i</span>) =&gt;</span> el === _deps[i]) <span class="comment">// 两次的 dependencies 是否完全相等</span></span><br><span class="line">    : <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">/* 如果 dependencies 不存在，或者 dependencies 有变化*/</span></span><br><span class="line">  <span class="keyword">if</span> (hasNoDeps || hasChangedDeps) &#123;</span><br><span class="line">    callback();</span><br><span class="line">    _deps = depArray;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到现在的话，在页面能正常使用了，但是每次使用只能用一次，因为你声明多次的话，它是公用的一个变量，不能重复使用。</p>
<p>们可以使用数组，来解决 Hooks 的复用问题</p>
<p><strong>代码关键在于：</strong></p>
<p>初次渲染的时候，按照 <code>useState，useEffect</code> 的顺序，把 <code>state，deps</code> 等按顺序塞到 <code>memoizedState</code> 数组中。<br>更新的时候，按照顺序，从 <code>memoizedState</code> 中把上次记录的值拿出来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> memoizedState = []; <span class="comment">// hooks 存放在这个数组</span></span><br><span class="line"><span class="keyword">let</span> cursor = <span class="number">0</span>; <span class="comment">// 当前 memoizedState 下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  memoizedState[cursor] = memoizedState[cursor] || initialValue;</span><br><span class="line">  <span class="keyword">const</span> currentCursor = cursor;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>) </span>&#123;</span><br><span class="line">    memoizedState[currentCursor] = newState;</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [memoizedState[cursor++], setState]; <span class="comment">// 返回当前 state，并把 cursor 加 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, depArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hasNoDeps = !depArray;</span><br><span class="line">  <span class="keyword">const</span> deps = memoizedState[cursor];</span><br><span class="line">  <span class="keyword">const</span> hasChangedDeps = (deps</span><br><span class="line">    ? !depArray.every(<span class="function">(<span class="params">el, i</span>) =&gt;</span> el === deps[i])</span><br><span class="line">    : <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (hasNoDeps || hasChangedDeps) &#123;</span><br><span class="line">    callback();</span><br><span class="line">    memoizedState[cursor] = depArray;</span><br><span class="line">  &#125;</span><br><span class="line">  cursor++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里基本的业务已经满足了，但是有几个需要注意的点：</p>
<ul>
<li>memoizedState 数组是按 hook定义的顺序来放置数据的，如果hooks的顺序变化，memoizedState 并不会感知到所以不要再循环或者判断语句中调用。</li>
<li>自定义的hooks也是共享同一个 memoizedState，共享同一个顺序。</li>
</ul>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://react.docschina.org/docs/hooks-reference.html" target="_blank" rel="noopener">hooks</a></p>
<p><a href="https://www.robinwieruch.de/react-hooks" target="_blank" rel="noopener">react-hooks-fetch</a></p>
<p><a href="https://react.docschina.org/docs/hooks-faq.html" target="_blank" rel="noopener">hooks-faq</a></p>
<p><a href="https://github.com/facebook/react/blob/master/packages/react/src/ReactHooks.js" target="_blank" rel="noopener">ReactHooks源码</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>React</category>
        <category>Hooks</category>
      </categories>
  </entry>
  <entry>
    <title>Router原理</title>
    <url>/2019/01/17/workspace/Frame/react/react-router/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Router原理</strong></p>
<p>[[toc]]</p>
<h3 id="react-router-和-react-router-dom"><a href="#react-router-和-react-router-dom" class="headerlink" title="react-router 和 react-router-dom"></a>react-router 和 react-router-dom</h3><ul>
<li>react-router是浏览器和原生应用的通用部分。</li>
<li>react-router-dom是用于浏览器的。</li>
<li>react-router-native是用于原生应用的。</li>
<li>react-router-config 是一些配置相关</li>
</ul>
<h3 id="react-router的基本原理"><a href="#react-router的基本原理" class="headerlink" title="react-router的基本原理"></a>react-router的基本原理</h3><p>实现<code>URL</code>与<code>UI</code>界面的同步。其中在<code>react-router</code>中，<code>URL</code>对应<code>Location</code>对象，而<code>UI</code>是由<code>react components</code>来决定的，这样就转变成<code>location与components</code>之间的同步问题</p>
<p>react-router 还用到了 <code>history</code> 库，这个库主要是对 <code>hash</code> 路由、<code>history</code> 路由、<code>memory</code>路由的封装</p>
<p><strong>看一个示例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App=<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> [UI, setUI] = useState(<span class="string">'Login'</span>);</span><br><span class="line">  <span class="keyword">let</span> onClickLogin = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUI(<span class="string">'Login'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> onClickRegister = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUI(<span class="string">'Register'</span>) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> showUI = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(UI) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'Login'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Login</span>/&gt;</span></span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'Register'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Register</span>/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClickLogin&#125;&gt;Login&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;onClickRegister&#125;&gt;Register&lt;/</span>button&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &#123;showUI()&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个其实就是路由的雏形了，每个页面对应着一个组件，然后在不同状态下去切换 。</p>
<h3 id="使用-hash-来切换"><a href="#使用-hash-来切换" class="headerlink" title="使用 hash 来切换"></a>使用 hash 来切换</h3><p>当然我们更希望看到的是,<code>不同 url -&gt; 不同页面 -&gt; 不同组件</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App=<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 进入页面时，先初始化当前 url 对应的组件名</span></span><br><span class="line">  <span class="keyword">let</span> hash = <span class="built_in">window</span>.location.hash</span><br><span class="line">  <span class="keyword">let</span> initUI = hash === <span class="string">'#login'</span> ? <span class="string">'login'</span> : <span class="string">'register'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [UI, setUI] = useState(initUI);</span><br><span class="line">  <span class="keyword">let</span> onClickLogin = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUI(<span class="string">'login'</span>)</span><br><span class="line">    <span class="built_in">window</span>.location.hash = <span class="string">'login'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> onClickRegister = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUI(<span class="string">'register'</span>) </span><br><span class="line">    <span class="built_in">window</span>.location.hash = <span class="string">'register'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> showUI = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(UI) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'login'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Login</span>/&gt;</span></span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'register'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Register</span>/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClickLogin&#125;&gt;Login&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;onClickRegister&#125;&gt;Register&lt;/</span>button&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &#123;showUI()&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样其实已经满足我们的要求了，如果我在地址栏里输入 <code>localhost:8080/#login</code>，就会显示<code>&lt;Login/&gt;</code>。但是这个 “#” 符号不太好看，如果输入 <code>localhost:8080/login</code> 就完美了。</p>
<h3 id="使用-history-切换"><a href="#使用-history-切换" class="headerlink" title="使用 history 切换"></a>使用 history 切换</h3><p>幸运的是 <code>H5</code> 提供了一个好用的 <code>history API</code>，使用 <code>window.history.pushState()</code> 使得我们即可以修改 <code>url</code> 也可以不刷新页面，一举两得。</p>
<p>需要注意的是调用<code>history.pushState()</code>或<code>history.replaceState()</code>不会触发<strong>popstate</strong>事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()或者history.forward()方法）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App=<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 进入页面时，先初始化当前 url 对应的组件名</span></span><br><span class="line">  <span class="keyword">let</span> pathname = <span class="built_in">window</span>.location.pathname</span><br><span class="line">  <span class="keyword">let</span> initUI = pathname === <span class="string">'/login'</span> ? <span class="string">'login'</span> : <span class="string">'register'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [UI, setUI] = useState(initUI);</span><br><span class="line">  <span class="keyword">let</span> onClickLogin = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUI(<span class="string">'login'</span>)</span><br><span class="line">    <span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="string">''</span>, <span class="string">'/login'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> onClickRegister = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUI(<span class="string">'register'</span>) </span><br><span class="line">    <span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="string">''</span>, <span class="string">'/register'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> showUI = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(UI) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'login'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Login</span>/&gt;</span></span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'register'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Register</span>/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClickLogin&#125;&gt;Login&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;onClickRegister&#125;&gt;Register&lt;/</span>button&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &#123;showUI()&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，一个 <code>Router</code> 就已经被我们实现了。当然这个 <code>Router</code> 功能不多，不过这就是 <code>Vue Router</code> 和 <code>React Router</code> 的思想，他们是基于此来开发更多的功能而已。</p>
<h3 id="react-router使用"><a href="#react-router使用" class="headerlink" title="react-router使用"></a>react-router使用</h3><ul>
<li><p><code>BrowserRouter</code> 这是对Router接口的实现。使得页面和浏览器的history保持一致。如：window.location。</p>
</li>
<li><p><code>HashRouter</code> 和上面的一样，只是使用的是url的hash部分，比如：window.location.hash。</p>
</li>
<li><p><code>MemoryRouter</code>， 就是没有URL的情况,在某些环境（比如React Native）下，根本没有URL，只能靠Memory默默记住就好。</p>
</li>
<li><p><code>StaticRouter</code> 在服务器端渲染方案中很有用，因此位置永远不会发生实际变化</p>
<p><strong>BrowserRouter</strong></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>; // 保存setUrl，因为监听事件咱们值加入一次，所以放外面</span><br><span class="line">function popstate(e) &#123;</span><br><span class="line">  <span class="keyword">set</span>(window.location.pathname);</span><br><span class="line">&#125;</span><br><span class="line">// 创建context</span><br><span class="line">export const RouterContext = React.createContext(window.location.pathname);</span><br><span class="line"></span><br><span class="line">export default function(&#123; children &#125;) &#123;</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(<span class="built_in">window</span>.location.pathname);</span><br><span class="line">  <span class="keyword">set</span> = setUrl;</span><br><span class="line"></span><br><span class="line">  window.addEventListener("popstate", popstate);</span><br><span class="line"></span><br><span class="line">  const router = &#123;</span><br><span class="line">    history: &#123;</span><br><span class="line">      push: <span class="function"><span class="keyword">function</span>(<span class="params">url, state, title</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.history.pushState(state, title, url);</span><br><span class="line">        setUrl(url);</span><br><span class="line">      &#125;,</span><br><span class="line">      replace: <span class="function"><span class="keyword">function</span>(<span class="params">url, state, title</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.history.replaceState(state, title, url);</span><br><span class="line">        setUrl(url);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 下面也需要嵌入setUrl，暂不处理</span></span><br><span class="line">      go: <span class="built_in">window</span>.history.go,</span><br><span class="line">      goBack: <span class="built_in">window</span>.history.back,</span><br><span class="line">      goForward: <span class="built_in">window</span>.history.forward,</span><br><span class="line">      length: <span class="built_in">window</span>.history.length</span><br><span class="line">    &#125;,</span><br><span class="line">    url: url</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;RouterContext.Provider value=&#123;router&#125;&gt;&#123;children&#125;&lt;<span class="regexp">/RouterContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><ul>
<li><code>path</code>属性，字符串类型，它的值就是用来匹配url的。</li>
<li><code>component</code>属性，它的值是一个组件。在path匹配成功之后会绘制这个组件。</li>
<li><code>exact</code>属性，这个属性用来指明这个路由是不是排他的匹配。</li>
<li><code>render</code>属性，一个返回React组件的方法。传说中的rencer-prop就是从这里来的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RouterContext &#125; <span class="keyword">from</span> <span class="string">"./BrowserRouter"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Route</span>(<span class="params">&#123; component, path &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取context</span></span><br><span class="line">  <span class="keyword">const</span> &#123; history, url &#125; = useContext(RouterContext);</span><br><span class="line">  <span class="keyword">const</span> match = &#123;</span><br><span class="line">    path,</span><br><span class="line">    url</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> Component = component;</span><br><span class="line">  <span class="keyword">return</span> url === path &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">history</span>=<span class="string">&#123;history&#125;</span> <span class="attr">match</span>=<span class="string">&#123;match&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Route;</span><br></pre></td></tr></table></figure>

<h4 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h4><p>重定向路由：from 是从哪个组件来，to 表示要定向到哪里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Redirect <span class="keyword">from</span>=&#123;<span class="string">'/'</span>&#125; exact to=&#123;<span class="string">'/home/index'</span>&#125;/&gt;;</span><br><span class="line">&lt;Redirect <span class="keyword">from</span>=&#123;<span class="string">'/*'</span>&#125; exact to=&#123;<span class="string">'/404'</span>&#125;/&gt;;</span><br></pre></td></tr></table></figure>
<h4 id="exact"><a href="#exact" class="headerlink" title="exact"></a>exact</h4><p>1.exact是Route下的一个属性，react路由会匹配到所有能匹配到的路由组件，exact能够使得路由的匹配更严格一些。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">'/'</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">&lt;Route path=<span class="string">'/page'</span> component=&#123;Page&#125;&gt;</span><br><span class="line"><span class="comment">//这种情况下，如果匹配路由path='/page'，那么会把Home也会展示出来。</span></span><br><span class="line"><span class="comment">//既路由path='/page'会匹配路由path='/'和路由path='/page'</span></span><br></pre></td></tr></table></figure>

<h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h4><p>2.Switch 只会渲染第一次匹配的路由，为了防止书写顺序要配合exact一块使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Switch, Route &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line">&lt;Switch&gt;  <span class="comment">//匹配到一个路由后，后面的就不要再匹配了</span></span><br><span class="line">  &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/:aa"</span> render=&#123;() =&gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Link组件后路由系统中到底发生了哪些变化"><a href="#Link组件后路由系统中到底发生了哪些变化" class="headerlink" title="Link组件后路由系统中到底发生了哪些变化"></a>Link组件后路由系统中到底发生了哪些变化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">  pathname: <span class="string">'/me'</span>,</span><br><span class="line">  search: <span class="string">'?sort=asc'</span>,</span><br><span class="line">  hash: <span class="string">'#hash'</span>,</span><br><span class="line">  state: &#123; <span class="attr">fromHome</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p><code>Link</code> 组件最终会渲染为 <code>HTML</code> 标签 <code>&lt;a&gt;</code>，它的 <code>to、query、hash</code>属性会被组合在一起并渲染为 <code>href</code> 属性。虽然 <code>Link</code> 被渲染为超链接，但在内部实现上使用脚本<code>拦截了浏览器的默认行为</code>，然后调用了<code>history.pushState</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RouterContext &#125; <span class="keyword">from</span> <span class="string">"./BrowserRouter"</span>;</span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">"styled-components"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A = styled.a<span class="string">`</span></span><br><span class="line"><span class="string">  text-decoration: none;</span></span><br><span class="line"><span class="string">  padding: 5px;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Link</span>(<span class="params">&#123; children, to &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; history &#125; = useContext(RouterContext);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    history.push(to);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;A href=&#123;to&#125; onClick=&#123;onClick&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/A&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Link;</span></span><br></pre></td></tr></table></figure>

<h3 id="hash模式和history模式的区别"><a href="#hash模式和history模式的区别" class="headerlink" title="hash模式和history模式的区别"></a>hash模式和history模式的区别</h3><ul>
<li>hash虽然出现在URL中，但<code>不会被包括在HTTP请求中</code>，对后端完全没有影响，因此改变hash不会重新加载页面;history会</li>
<li>pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL</li>
<li>pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中</li>
<li>history模式需要后端配合将所有访问都重定向到index.html，否则用户刷新页面，会导致404错误</li>
</ul>
<p><strong>原生基于发布订阅实现</strong></p>
<p><strong>HASH</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.routers = []  <span class="comment">//存放我们的路由配置</span></span><br><span class="line">    &#125;</span><br><span class="line">    add(route,callback)&#123;</span><br><span class="line">        <span class="keyword">this</span>.routers.push(&#123;</span><br><span class="line">            path:route,</span><br><span class="line">            render:callback</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    listen(callback)&#123;</span><br><span class="line">        <span class="built_in">window</span>.onhashchange = <span class="keyword">this</span>.hashChange(callback);   <span class="comment">//监听onhashchange方法</span></span><br><span class="line">        <span class="keyword">this</span>.hashChange(callback)()  <span class="comment">//首次进入页面的时候没有触发hashchange，必须要就单独调用一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    hashChange(callback)&#123;</span><br><span class="line">        <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> hash = location.hash</span><br><span class="line">            <span class="built_in">console</span>.log(hash)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;self.routers.length;i++)&#123;</span><br><span class="line">                <span class="keyword">let</span> route = self.routers[i]</span><br><span class="line">                <span class="keyword">if</span>(hash===route.path)&#123;</span><br><span class="line">                    callback(route.render())</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> Router()</span><br><span class="line">router.add(<span class="string">'#index'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;这是首页内容&lt;/h1&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line">router.add(<span class="string">'#news'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">'&lt;h1&gt;这是新闻内容&lt;/h1&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line">router.listen(<span class="function">(<span class="params">renderHtml</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> app = <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">    app.innerHTML = renderHtml</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>HISTORY</strong></p>
<p>跟上面同理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">renderHtml(path)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.routers.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> route = <span class="keyword">this</span>.routers[i]</span><br><span class="line">        <span class="keyword">if</span>(path===route.path)&#123;</span><br><span class="line">            callback(route.render())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125; <span class="comment">//检测前进后退</span></span><br><span class="line"><span class="comment">//点击跳转，在react找那个用的合成的方法，每次执行this.props.history.push(）等，都会执行pushState的方法</span></span><br><span class="line">pushState(path,data=&#123;&#125;)&#123;</span><br><span class="line">    <span class="built_in">window</span>.history.pushState(data,<span class="string">''</span>,path)</span><br><span class="line">    <span class="keyword">this</span>.renderHtml(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">官方文档</a><br/><br><a href="https://github.com/hankzhuo/Blog/issues/11" target="_blank" rel="noopener">https://github.com/hankzhuo/Blog/issues/11</a><br/><br><a href="http://m.shanhuxueyuan.com/news/detail/137.html" target="_blank" rel="noopener">http://m.shanhuxueyuan.com/news/detail/137.html</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>React</category>
        <category>Router</category>
      </categories>
  </entry>
  <entry>
    <title>Redux源码解析</title>
    <url>/2019/02/17/workspace/Frame/react/react-redux/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Redux源码解析</strong></p>
<p>[[toc]]</p>
<h3 id="Redux三大原则"><a href="#Redux三大原则" class="headerlink" title="Redux三大原则"></a>Redux三大原则</h3><ul>
<li><strong>唯一数据源</strong><ul>
<li>整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中</li>
</ul>
</li>
<li><strong>保持只读状态</strong><ul>
<li>state是只读的，唯一改变state的方法就是触发action，action是一个用于描述以发生时间的普通对象<ul>
<li>store里面保存的都是普通Object，可直接修改他的值，官方文档说的“只有通过action才能修改状态”更多的是一种规则/约束，目的是使数据的流动过程变得清晰且可预测，而不是说通过其他方式（比如直接修改对象属性）会报错。当然这种方式是 <strong>无法触发props更新的</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>数据改变只能通过纯函数来执行</strong><ul>
<li>使用纯函数来执行修改，为了描述action如何改变state的，你需要编写reducers</li>
</ul>
</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H70eea0923b414f78a4a4d805e374147aX.gif" alt=""></p>
<h3 id="Action-amp-store-dispatch"><a href="#Action-amp-store-dispatch" class="headerlink" title="Action &amp; store.dispatch( )"></a>Action &amp; store.dispatch( )</h3><p><code>Action</code>是把数据从应用传到store的有效载荷。它是store数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。</p>
<ul>
<li>首先用户请求或者页面默认请求执行一个函数 例：myBoardList</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBoardList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dispatch,getState</span>)</span>&#123;<span class="comment">//这里是中间件穿进去的</span></span><br><span class="line">    request.get(<span class="string">`<span class="subst">$&#123;route.myBoard&#125;</span><span class="subst">$&#123;getState().loginReducer.user_id&#125;</span>`</span>).then(<span class="function">(<span class="params">&#123;data&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> my_list = data; <span class="comment">//这里一整理数据格式</span></span><br><span class="line">        <span class="comment">//Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置</span></span><br><span class="line">        <span class="keyword">const</span> action =&#123;</span><br><span class="line">              type:TYPES.BOARD_MY,</span><br><span class="line">              payload:&#123;</span><br><span class="line">                 my_list</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//store.dispatch()是页面发出Action的唯一方法。</span></span><br><span class="line">        dispatch(action)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面使用</span></span><br><span class="line"><span class="keyword">this</span>.props.dispatch(myBoardList())</span><br></pre></td></tr></table></figure>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p><code>Reducers</code>指定了应用状态的变化<code>如何响应</code>actions并发送到store的，actions只是描述了有事情发生了这一事实，并没有描述应用如何更新state。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> TYPES <span class="keyword">from</span> <span class="string">'actionTypes'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  my_list:[]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> tabBarReducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">     <span class="keyword">case</span> TYPES.BOARD_MY :</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, action.payload)</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> tabBarReducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer = combineReducers(&#123; <span class="comment">//合并所有的reducer导出，然后当做createStore的参数</span></span><br><span class="line">   tabBarReducer,</span><br><span class="line">   ....</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p><code>store</code>就是redux里面的一个容器，store本质上是一个状态树，保存了所有对象的状态。任何UI组件都可以直接从store访问特定对象的状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> reduxThunk <span class="keyword">from</span> <span class="string">"redux-thunk"</span></span><br><span class="line"><span class="keyword">import</span> reduxPromise <span class="keyword">from</span> <span class="string">"redux-promise"</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore, applyMiddleware&#125; <span class="keyword">from</span> <span class="string">"redux"</span></span><br><span class="line"><span class="keyword">import</span> &#123; composeWithDevTools &#125; <span class="keyword">from</span> <span class="string">'redux-devtools-extension'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">"./reducer"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = composeWithDevTools(createStore(reducer,applyMiddleware(reduxThunk, reduxPromise)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<h3 id="Redux源码"><a href="#Redux源码" class="headerlink" title="Redux源码 *"></a>Redux源码 *</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let combineReducers&#x3D;(renducers)&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;传入一个renducers管理组，返回的是一个renducer</span><br><span class="line">    return function(state&#x3D;&#123;&#125;,action&#x3D;&#123;&#125;)&#123;</span><br><span class="line">        let newState&#x3D;&#123;&#125;;</span><br><span class="line">        for(var attr in renducers)&#123;</span><br><span class="line">            newState[attr]&#x3D;renducers[attr](state[attr],action)</span><br><span class="line">        &#125;</span><br><span class="line">        return newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let createStore &#x3D; (reducer) &#x3D;&gt; &#123;</span><br><span class="line">    let state;</span><br><span class="line">    &#x2F;&#x2F;获取状态对象</span><br><span class="line">    &#x2F;&#x2F;存放所有的监听函数</span><br><span class="line">    let listeners &#x3D; [];</span><br><span class="line">    let getState &#x3D; () &#x3D;&gt; state;</span><br><span class="line">    &#x2F;&#x2F;提供一个方法供外部调用派发action</span><br><span class="line">    let dispath &#x3D; (action) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;调用管理员reducer得到新的state</span><br><span class="line">        state &#x3D; reducer(state, action);</span><br><span class="line">        &#x2F;&#x2F;执行所有的监听函数，相当于发布</span><br><span class="line">        listeners.forEach((l) &#x3D;&gt; l())</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;订阅状态变化事件，当状态改变发生之后执行监听函数</span><br><span class="line">    let subscribe &#x3D; (listener) &#x3D;&gt; &#123;</span><br><span class="line">        listeners.push(listener);</span><br><span class="line">       &#x2F;&#x2F;store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</span><br><span class="line">        return function unsubscribe() &#123;</span><br><span class="line">             const index &#x3D; listeners.indexOf(listener)</span><br><span class="line">             listeners.splice(index, 1)</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dispath();</span><br><span class="line">    return &#123;</span><br><span class="line">        getState,  &#x2F;&#x2F;获取当前的容器的状态</span><br><span class="line">        subscribe, &#x2F;&#x2F;当你对数据库发出一个指令，而且数据库根据这个指令已经计算得到新的状态以后需要执行的回调函数</span><br><span class="line">        dispath,   &#x2F;&#x2F;发出一个Action，告诉数据库你要干嘛。数据库会根据当前的状态以及你的命令类型计算得到新的状态。计算完成以后，我们要执行subscribe添加的所有的回调函数.</span><br><span class="line">        replaceReducer &#x2F;&#x2F;用一个新的store替换掉我们当前的store用来计算我们的新的state。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const store &#x3D; createStore(reducer);</span><br><span class="line">store.getState(); &#x2F;&#x2F; 获取数据</span><br><span class="line">store.dispatch(&#123;type: &#39;ADD_TODO&#39;&#125;); &#x2F;&#x2F; 更新数据</span><br><span class="line">store.subscribe(() &#x3D;&gt;  document.querySelector(&#39;#counter&#39;).innerHTML &#x3D; store.getState()); &#x2F;&#x2F; 注册订阅函数</span><br></pre></td></tr></table></figure>

<p>我们可以在应用初始化的时候，创建一个<code>window.store = createStore(reducer)</code>，<br>然后在需要的地方通过<code>store.getState()去获取数据</code>，<br>通过<code>store.dispatch去更新数据</code>，<br>通过<code>store.subscribe去订阅数据变化然后进行setState</code>…如果很多地方都这样做一遍，实在是不堪其重，而且，还是没有避免掉全局变量的不优雅。所以就需要<strong>react-redux</strong>了</p>
<h3 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h3><h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h4><p>由于全局变量有诸多的缺点，所有就需要用到Provider优化</p>
<p><code>Provider</code>其实就只是一个外层容器，它的作用就是通过配合<code>connect</code>来达到跨层级传递数据。使用时只需将Provider定义为整个项目最外层的组件，并设置好store。<br>那么整个项目都可以直接获取这个store。它的原理其实是通过React中的Context来实现的。它的核心代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"><span class="keyword">import</span> &#123;ReactReduxContext&#125; <span class="keyword">from</span> <span class="string">'./Context'</span>   <span class="comment">//就是利用上下文来达到跨层级传递数据</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">const</span> &#123;store&#125; = props</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            storeState: store.getState(),</span><br><span class="line">            store</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">this</span>._isMounted = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">this</span>.subscribe()</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.unsubscribe) <span class="keyword">this</span>.unsubscribe()  <span class="comment">//取消订阅</span></span><br><span class="line">        <span class="keyword">this</span>._isMounted = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.props.store !== prevProps.store) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.unsubscribe) <span class="keyword">this</span>.unsubscribe()</span><br><span class="line">            <span class="keyword">this</span>.subscribe()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    subscribe() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;store&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="comment">//store.subscribe返回的是取消订阅的方法</span></span><br><span class="line">        <span class="comment">//Store 允许使用store.subscribe方法设置监听函数，每次dispatch后，执行完reducer改变新的store后，都会重新发布这个含函数</span></span><br><span class="line">        <span class="keyword">this</span>.unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> newStoreState = store.getState()</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>._isMounted) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.setState(<span class="function"><span class="params">providerState</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 如果值相同，则跳过不必要的状态更新</span></span><br><span class="line">                <span class="keyword">if</span> (providerState.storeState === newStoreState) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">storeState</span>: newStoreState&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 可能在呈现和装载之间调度了操作-处理那些</span></span><br><span class="line">        <span class="keyword">const</span> postMountStoreState = store.getState()</span><br><span class="line">        <span class="keyword">if</span> (postMountStoreState !== <span class="keyword">this</span>.state.storeState) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;<span class="attr">storeState</span>: postMountStoreState&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> Context = <span class="keyword">this</span>.props.context || ReactReduxContext</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Context.Provider value=&#123;<span class="keyword">this</span>.state&#125;&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">Provider.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">    store: PropTypes.shape(&#123;</span></span><br><span class="line"><span class="regexp">        subscribe: PropTypes.func.isRequired,</span></span><br><span class="line"><span class="regexp">        dispatch: PropTypes.func.isRequired,</span></span><br><span class="line"><span class="regexp">        getState: PropTypes.func.isRequired</span></span><br><span class="line"><span class="regexp">    &#125;),</span></span><br><span class="line"><span class="regexp">    context: PropTypes.object,</span></span><br><span class="line"><span class="regexp">    children: PropTypes.any</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Provider</span></span><br></pre></td></tr></table></figure>
<h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><p><code>connect</code>的作用是连接React组件与Store，它包在我们的容器组件的外一层，它接收上面Provider提供的store里面的<code>state</code>和<code>dispatch</code>，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件。</p>
<p>它共有四个参数 <strong>mapStateToProps, mapDispatchToProps, mergeProps以及options</strong>。</p>
<p><code>mapStateToProps</code> 的作用是将store里的state（数据源）绑定到指定组件的props中</p>
<p><code>mapDispatchToProps</code> 的作用是将store里的action（操作数据的方法）绑定到指定组件的props中</p>
<p>其实就是利用上下文获取所有的store,然后执行store.getState()保证能获取最新的数据，然后在利用mapStateToProps，mapDispatchToProps 把需要用到的解构出来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mapStateToProps = <span class="function">(<span class="params">&#123;loginReducer,loading&#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">    userInfo: &#123;...loginReducer, ...loading&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> mapDispatchToProps =  <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> actions = bindActionCreators(&#123;...globalActions&#125;, dispatch);</span><br><span class="line">   <span class="keyword">return</span> &#123;...actions&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapDispatchToProps)(Index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过props获取用户信息</span></span><br><span class="line"><span class="keyword">this</span>.props.userInfo</span><br></pre></td></tr></table></figure>

<p>connect部分源码</p>
<p>新版的太复杂，看下老版本的，便于理解</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> connect = <span class="function">(<span class="params">mapStateToProps, mapDispatchToProps</span>) =&gt;</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">      store: PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">      <span class="keyword">super</span>()</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      <span class="comment">//使用subscribe，会实时检测store的变化</span></span><br><span class="line">      <span class="keyword">this</span>.unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setProps())</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnMount () &#123;</span><br><span class="line">        <span class="keyword">this</span>.unsubscribe()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setProps () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      <span class="keyword">let</span> stateProps = mapStateToProps</span><br><span class="line">        ? mapStateToProps(store.storeState(), <span class="keyword">this</span>.props)</span><br><span class="line">        : &#123;&#125;; <span class="comment">// 不传为空</span></span><br><span class="line">        </span><br><span class="line">      <span class="keyword">let</span> dispatchProps = mapDispatchToProps</span><br><span class="line">        ? mapDispatchToProps(store.dispatch,<span class="keyword">this</span>.props)</span><br><span class="line">        : mapDispatchToProps(<span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123; dispatch &#125;)); <span class="comment">// 默认传进去dispatch</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//mapDispatchToProps里面还可能会有bindActionCreators这个方法；bindActionCreators的作用是将一个或多个action和dispatch组合起来生成</span></span><br><span class="line">        <span class="comment">//通过dispatch将action包裹起来，这样可以通过bindActionCreators创建的方法，直接调用dispatch(action)(隐式调用），相当于直接组合成</span></span><br><span class="line">        <span class="comment">//dispatch(&#123;type:type.ADD_ITEM, text&#125;) </span></span><br><span class="line">        <span class="comment">//export function whenMapDispatchToPropsIsObject(mapDispatchToProps) &#123;</span></span><br><span class="line">        <span class="comment">//    return wrapMapToPropsConstant(dispatch =&gt;</span></span><br><span class="line">        <span class="comment">//        bindActionCreators(mapDispatchToProps, dispatch)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          ...stateProps,</span><br><span class="line">          ...dispatchProps,</span><br><span class="line">          ...this.props</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.state</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Connect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><h4 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h4><p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;  <span class="comment">//判别action的类型，如果action是函数，就调用这个函数</span></span><br><span class="line">        <span class="comment">//发现实参为dispatch和getState，因此我们在定义action为thunk函数是，一般形参为dispatch和getState。</span></span><br><span class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk;</span><br></pre></td></tr></table></figure>
<p> 上面的dispatch其实是中间件执行之后通过其他方法把store自带的dispatch覆盖，<br> 所以我们平时使用的store.dispatch(action)其实就是中间件执行之后的dispatch,<br> 而这里的next其实是store自带的dispatch，<strong>虽然最终还是通过store自带的dispatch实现的，</strong><br> 但是调用的确是中间件的方法，虽然都叫做dispatch。</p>
<p><strong>使用方式</strong></p>
<p>可以传入对象或者函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBoardList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dispatch,getState</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">const</span> action =&#123;</span><br><span class="line">            type:TYPES.BOARD_MY,</span><br><span class="line">            payload:&#123;</span><br><span class="line">               my_list</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     dispatch(action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong></p>
<p>thunk的缺点也是很明显的，thunk<code>仅仅做了执行</code>这个函数，<code>并不在乎函数主体内是什么</code><br/><br>thunk使得redux可以接受函数作为action,这就会使得异步操作<code>太为分散</code>【往往需要promise或者async/wait的支持才可以】</p>
<p>action的形式不统一</p>
<h4 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h4><p><strong>流程:</strong></p>
<p>异步操作——&gt;Effect函数——&gt;纯文本对象——&gt;saga-middleware——&gt;执行异步操作</p>
<p><strong>配置sage</strong></p>
<p><strong>effect.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  * <span class="keyword">as</span> Api <span class="keyword">from</span> <span class="string">"../services"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; call, put, takeEvery &#125; <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 副作用处理 effects：</span></span><br><span class="line"><span class="comment"> *  用于异步处理请求</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> effects = &#123;</span><br><span class="line">  <span class="comment">// 获取话题列表</span></span><br><span class="line">  *fetchTopics(&#123; payload &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">yield</span> call(Api.topics, payload);</span><br><span class="line">    <span class="keyword">if</span> (res.success) &#123;</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">'topics'</span>,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          topics: res.data,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  异步 action 监听： 所有的effect整合到了一块</span></span><br><span class="line"><span class="comment"> *  dispatch 对应的action时，调用对应的异步处理方法</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">watcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">'fetchTopics'</span>, effects.fetchTopics);</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">'aaa'</span>, effects.aaa);</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">'bbb'</span>, effects.bbb);</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>reducers.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个reducer 需要用到combineReducers合并</span></span><br><span class="line"><span class="comment">// 初始化State</span></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  topics: [],</span><br><span class="line">  topic: &#123;&#125;,</span><br><span class="line">  collected: [],</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纯函数 reducer：</span></span><br><span class="line"><span class="comment"> * 传入旧 state 和 action，从而返回一个信息state</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reducers = <span class="function">(<span class="params">state = initState, &#123; type, payload &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'topics'</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        topics: payload.topics,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的写法和redux-thunk中reducers写法一样</p>
<p><strong>index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统一导出reducers和effects</span></span><br><span class="line"><span class="keyword">import</span> &#123; reducers &#125; <span class="keyword">from</span> <span class="string">'./reducers'</span>; </span><br><span class="line"><span class="keyword">import</span> &#123; watcher &#125; <span class="keyword">from</span> <span class="string">"./effects"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  reducers,</span><br><span class="line">  watcher,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123; Provider &#125; from &#39;react-redux&#39;;</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &#39;redux&#39;;</span><br><span class="line">import createSagaMiddleware from &#39;redux-saga&#39;;</span><br><span class="line">import &#123;reducers,watcher&#125; from &#39;.&#x2F;redux&#39;;</span><br><span class="line"></span><br><span class="line">const sagaMiddleware &#x3D; createSagaMiddleware();</span><br><span class="line">const store &#x3D; createStore(</span><br><span class="line">    reducers,  &#x2F;&#x2F;这里是所有的reducer</span><br><span class="line">  applyMiddleware(sagaMiddleware), &#x2F;&#x2F;执行saga的中间件</span><br><span class="line">);</span><br><span class="line">sagaMiddleware.run(watcher); </span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">  &lt;&#x2F;Provider&gt;,</span><br><span class="line">  document.getElementById(&#39;app&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里的sagaMiddleware.run() 方法，主要是启动saga，<strong>用于监听actions请求</strong>，待匹配到定义的effects type时，转发调用effects方法，从而处理异步请求，然后再调用redux中的dispatch来触发新的action，来更新store！</p>
<p><strong>页面使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@connect(<span class="function">(<span class="params">&#123; topics, loading &#125;</span>) =&gt;</span> (&#123;  <span class="comment">//type的值</span></span><br><span class="line">  topics,</span><br><span class="line">  loading,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.props.dispatch(&#123;</span><br><span class="line">    type: <span class="string">'fetchTopics'</span>, <span class="comment">//effect的函数</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>处理步骤：</strong></p>
<ol>
<li><p>用户dispatch执行一个异步函数</p>
</li>
<li><p>调用redux-saga/effects中的方法 call，访问接口获取数据；</p>
</li>
<li><p>接口访问成功，使用redux-saga/effects中的方法put，发起action，这里的put方法和dispatch一样，都是用于发起action；</p>
</li>
<li><p>put发起action后，redux的reducers会收到action，从而更新state。</p>
</li>
</ol>
<p>集中处理了所有的异步操作，异步接口部分一目了然</p>
<p>异步操作的流程是可以控制的，可以随时取消相应的异步操作。</p>
<h3 id="redux-middleware-源码分析"><a href="#redux-middleware-源码分析" class="headerlink" title="redux middleware 源码分析"></a>redux middleware 源码分析</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以 redux-thunk、logger 中间件为例介绍中间件的使用</span></span><br><span class="line"><span class="keyword">const</span> enhancer = applyMiddleware(thunk, logger),  </span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, enhancer)</span><br></pre></td></tr></table></figure>
<p><strong>applyMiddleware 调用入口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过下面代码可以发现，如果 createStore 传入 2 个参数，第二个参数相当于就是 enhancer</span><br><span class="line">  if (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">    enhancer &#x3D; preloadedState</span><br><span class="line">    preloadedState &#x3D; undefined</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof enhancer !&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">    return enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述 createStore 源码发现，applyMiddleware 会进行 <code>applyMiddleware(thunk, logger)(createStore)(reducer, preloadedState)</code> 的调用。</p>
<p><strong>applyMiddleware 源码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function applyMiddleware(...middlewares) &#123;</span><br><span class="line">    &#x2F;&#x2F; 柯理化  ()&#x3D;&gt;()&#x3D;&gt;&#123;&#125;</span><br><span class="line">  return createStore &#x3D;&gt; (...args) &#x3D;&gt; &#123;</span><br><span class="line">    const store &#x3D; createStore(...args)  &#x2F;&#x2F;store  &#x3D;  &#123;getState,dispatch.....&#125;</span><br><span class="line">    let dispatch &#x3D; store.dispatch</span><br><span class="line">    let chain &#x3D; []</span><br><span class="line"></span><br><span class="line">    const middlewareAPI &#x3D; &#123;</span><br><span class="line">      getState: store.getState,                &#x2F;&#x2F; 调用 redux 原生方法，获取状态</span><br><span class="line">      dispatch: (...args) &#x3D;&gt; dispatch(...args) &#x2F;&#x2F; 调用 redux 原生 dispatch 方法</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 串行 middleware</span><br><span class="line">    chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI)) &#x2F;&#x2F; thunk的参数参数正是 (&#123; dispatch, getState &#125;)</span><br><span class="line">    dispatch &#x3D; compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch &#x2F;&#x2F; 返回加工过的 dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  &#x2F;&#x2F;然后 &lt;Provider store&#x3D;&#123;store&#125; &#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dispatch 是如何被加工的</strong></p>
<p>compose 的源码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; dispatch, getState &#125;) =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 经 compose 源码分析，此处 next 为 Store.dispatch</span></span><br><span class="line">   <span class="comment">// action  为 this.props.dispatch(`action`)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action(dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其 middleware 的内部串行调用方式如下，从而完成了 dispatch 功能的增强(支持如 this.props.dispatch(action) 的调用以及日志功能)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">action =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action(dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> store.dispatch(action)</span><br><span class="line">  &#125;)(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>applyMiddleware的核心就是 执行的createStore,在dispatch里面添加一些方法,最后返回加工过的 dispatch,这个dispatch 有中间价的一些处理</p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>React</category>
        <category>Redux源码解析</category>
      </categories>
  </entry>
  <entry>
    <title>React封装的组件</title>
    <url>/2019/03/17/workspace/Frame/react/reactComponent/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>React封装的组件</strong></p>
<p>[[toc]]</p>
<h3 id="高阶函数-，封装context"><a href="#高阶函数-，封装context" class="headerlink" title="高阶函数 ，封装context"></a>高阶函数 ，封装context</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component,createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Context = createContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContextProvider = <span class="function">(<span class="params">&#123; context, children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Context.Provider value=&#123;context&#125;&gt;</span><br><span class="line">            &#123;children&#125;</span><br><span class="line">        &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export const getChildrenContext = (contexts) =&gt; RealComponent =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    return class extends Component &#123;</span></span><br><span class="line"><span class="regexp">        render() &#123;</span></span><br><span class="line"><span class="regexp">            return (</span></span><br><span class="line"><span class="regexp">                &lt;Context.Consumer&gt;</span></span><br><span class="line"><span class="regexp">                    &#123;context =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                        /</span><span class="regexp">/ 将顶层的context分发到各层</span></span><br><span class="line"><span class="regexp">                        let mapContext = &#123;&#125;;</span></span><br><span class="line"><span class="regexp">                        if (Array.isArray(contexts)) &#123;</span></span><br><span class="line"><span class="regexp">                            contexts.map(item =&gt; mapContext[item] = context[item]);</span></span><br><span class="line"><span class="regexp">                        &#125; else &#123;</span></span><br><span class="line"><span class="regexp">                            mapContext = context;</span></span><br><span class="line"><span class="regexp">                        &#125;</span></span><br><span class="line"><span class="regexp">                        return (</span></span><br><span class="line"><span class="regexp">                            &lt;RealComponent &#123;...mapContext&#125; &#123;...this.props&#125; /</span>&gt;</span><br><span class="line">                        )</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                &lt;<span class="regexp">/Context.Consumer&gt;</span></span><br><span class="line"><span class="regexp">            );</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>

<h3 id="封装的裁剪功能-带压缩下载"><a href="#封装的裁剪功能-带压缩下载" class="headerlink" title="封装的裁剪功能 带压缩下载"></a>封装的裁剪功能 带压缩下载</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component, Fragment&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> lrz <span class="keyword">from</span> <span class="string">'lrz'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Upload, message, Button, Icon, Modal&#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Cropper <span class="keyword">from</span> <span class="string">'react-cropper'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'cropperjs/dist/cropper.css'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./index.less"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cropper</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        srcCropper: <span class="string">''</span>, <span class="comment">//cropper的图片路径</span></span><br><span class="line">        selectImgName: <span class="string">''</span>, <span class="comment">//文件名称</span></span><br><span class="line">        selectImgSize: <span class="string">''</span>, <span class="comment">//文件大小</span></span><br><span class="line">        selectImgSuffix: <span class="string">''</span>, <span class="comment">//文件类型</span></span><br><span class="line">        editImageModalVisible: <span class="literal">false</span>, <span class="comment">//打开控制裁剪弹窗的变量，为true即弹窗</span></span><br><span class="line">        imgData: [],</span><br><span class="line">        loading: <span class="literal">false</span>,</span><br><span class="line">        download: <span class="string">""</span></span><br><span class="line">    &#125;;</span><br><span class="line">    downLoadImg = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// this.refs.cropper.getCroppedCanvas(&#123;maxWidth: 4096, maxHeight: 4096&#125;);</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            download: <span class="keyword">this</span>.refs.cropper.getCroppedCanvas(&#123;</span><br><span class="line">                maxWidth: <span class="number">4096</span>,</span><br><span class="line">                maxHeight: <span class="number">4096</span></span><br><span class="line">            &#125;).toDataURL()</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    saveImg = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;loading&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">if</span> (loading) <span class="keyword">return</span>;<span class="comment">//防止重复提交</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            loading: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// lrz压缩</span></span><br><span class="line">        <span class="comment">// this.refs.cropper.getCroppedCanvas().toDataURL() 为裁剪框的base64的值</span></span><br><span class="line">        <span class="keyword">const</span> &#123;base64, base64Len&#125; = <span class="keyword">await</span> lrz(<span class="keyword">this</span>.refs.cropper.getCroppedCanvas().toDataURL(), &#123;<span class="attr">quality</span>: <span class="number">.6</span>&#125;);</span><br><span class="line">        <span class="keyword">const</span> &#123;imgData&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        imgData.push(base64);</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            imgData,</span><br><span class="line">            loading: <span class="literal">false</span></span><br><span class="line">        &#125;, () =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleCancel()</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// console.log(base64, base64Len / 1024);</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    beforeUpload = <span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isLt10M = file.size / <span class="number">1024</span> / <span class="number">1024</span> &gt;= <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// console.log(file.size / 1024 / 1024);</span></span><br><span class="line">        <span class="keyword">if</span> (isLt10M) &#123; <span class="comment">//添加文件限制</span></span><br><span class="line">            message.error(&#123;<span class="attr">content</span>: <span class="string">'文件大小不能超过10M'</span>&#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">        reader.readAsDataURL(file); <span class="comment">//开始读取文件</span></span><br><span class="line">        <span class="comment">// 因为读取文件需要时间,所以要在回调函数中使用读取的结果</span></span><br><span class="line">        reader.onload = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                srcCropper: e.target.result,</span><br><span class="line">                selectImgName: file.name,</span><br><span class="line">                selectImgSize: (file.size / <span class="number">1024</span> / <span class="number">1024</span>),</span><br><span class="line">                selectImgSuffix: file.type.split(<span class="string">"/"</span>)[<span class="number">1</span>],</span><br><span class="line">                editImageModalVisible: <span class="literal">true</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        reader.onerror = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'图片加载失败'</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    handleCancel = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            editImageModalVisible: <span class="literal">false</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;ratio, title&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">const</span> &#123;srcCropper, editImageModalVisible, imgData, loading, download&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">const</span> props = &#123;</span><br><span class="line">            name: <span class="string">'file'</span>,</span><br><span class="line">            accept: <span class="string">"image/*"</span>,<span class="comment">//文件类型</span></span><br><span class="line">            showUploadList: <span class="literal">false</span>, <span class="comment">//不以默认的列表显示</span></span><br><span class="line">            beforeUpload: <span class="keyword">this</span>.beforeUpload, <span class="comment">//阻止自动上传</span></span><br><span class="line">            onCancel: <span class="keyword">this</span>.handleCancel</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Fragment&gt;</span><br><span class="line">                &lt;Upload &#123;...props&#125;&gt;</span><br><span class="line">                    &lt;Button htmlType=&#123;<span class="string">'button'</span>&#125; type=<span class="string">"dashed"</span>&gt;</span><br><span class="line">                        &lt;Icon type=<span class="string">"upload"</span>/&gt;&#123;title&#125;</span><br><span class="line">                    &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>Upload&gt;</span><br><span class="line"></span><br><span class="line">                &lt;Modal</span><br><span class="line">                    title=<span class="string">"裁剪"</span></span><br><span class="line">                    visible=&#123;editImageModalVisible&#125;</span><br><span class="line">                    loading=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">                    closable=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">                    footer=&#123;[</span><br><span class="line">                        &lt;Button key=&#123;<span class="string">'取消'</span>&#125;</span><br><span class="line">                                icon=&#123;<span class="string">'redo'</span>&#125;</span><br><span class="line">                                htmlType=&#123;<span class="string">'button'</span>&#125;</span><br><span class="line">                                onClick=&#123;<span class="keyword">this</span>.handleCancel&#125;&gt;</span><br><span class="line">                            取消</span><br><span class="line">                        &lt;<span class="regexp">/Button&gt;,</span></span><br><span class="line"><span class="regexp">                        &lt;Button key=&#123;'保存'&#125;</span></span><br><span class="line"><span class="regexp">                                icon=&#123;'save'&#125;</span></span><br><span class="line"><span class="regexp">                                htmlType=&#123;'button'&#125;</span></span><br><span class="line"><span class="regexp">                                type="primary"</span></span><br><span class="line"><span class="regexp">                                onClick=&#123;this.saveImg&#125;</span></span><br><span class="line"><span class="regexp">                                loading=&#123;loading&#125;&gt;</span></span><br><span class="line"><span class="regexp">                            保存</span></span><br><span class="line"><span class="regexp">                        &lt;/</span>Button&gt;,</span><br><span class="line">                        &lt;Button key=&#123;<span class="string">'下载'</span>&#125;</span><br><span class="line">                                htmlType=&#123;<span class="string">'button'</span>&#125;</span><br><span class="line">                                icon=<span class="string">"download"</span></span><br><span class="line">                                type=<span class="string">"primary"</span></span><br><span class="line">                                onClick=&#123;<span class="keyword">this</span>.downLoadImg&#125;&gt;</span><br><span class="line"></span><br><span class="line">                            &lt;a href=&#123;download&#125;</span><br><span class="line">                               style=&#123;&#123;<span class="attr">color</span>: <span class="string">'#fff'</span>, <span class="attr">marginLeft</span>: <span class="number">5</span>&#125;&#125;</span><br><span class="line">                               download=<span class="string">"cropped.jpg"</span>&gt;下载&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">                        &lt;/</span>Button&gt;</span><br><span class="line">                    ]&#125;</span><br><span class="line">                &gt;</span><br><span class="line"></span><br><span class="line">                    &lt;Cropper</span><br><span class="line">                        key=&#123;<span class="string">'cropper'</span>&#125;</span><br><span class="line">                        ref=<span class="string">'cropper'</span></span><br><span class="line">                        src=&#123;srcCropper&#125;</span><br><span class="line">                        style=&#123;&#123;<span class="attr">height</span>: <span class="number">300</span>, <span class="attr">width</span>: <span class="string">'100%'</span>&#125;&#125;</span><br><span class="line">                        viewMode=&#123;<span class="number">1</span>&#125; <span class="comment">//定义cropper的视图模式</span></span><br><span class="line">                        zoomable=&#123;<span class="literal">true</span>&#125; <span class="comment">//是否允许放大图像</span></span><br><span class="line">                        aspectRatio=&#123;ratio&#125; <span class="comment">//image的纵横比</span></span><br><span class="line">                        guides=&#123;<span class="literal">true</span>&#125; <span class="comment">//显示在裁剪框上方的虚线</span></span><br><span class="line">                        background=&#123;<span class="literal">false</span>&#125; <span class="comment">//是否显示背景的马赛克</span></span><br><span class="line">                        rotatable=&#123;<span class="literal">false</span>&#125; <span class="comment">//是否旋转</span></span><br><span class="line">                    /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;<span class="regexp">/Modal&gt;</span></span><br><span class="line"><span class="regexp">                &lt;div className=&#123;'imgBox'&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    &#123;</span></span><br><span class="line"><span class="regexp">                        imgData.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                            return (&lt;img</span></span><br><span class="line"><span class="regexp">                                    src=&#123;item&#125;</span></span><br><span class="line"><span class="regexp">                                    alt=&#123;item&#125;</span></span><br><span class="line"><span class="regexp">                                    key=&#123;index&#125;/</span>&gt;</span><br><span class="line">                            )</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            &lt;/</span>Fragment&gt;</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> cropper;</span><br><span class="line">cropper.defaultProps = &#123;</span><br><span class="line">    ratio: <span class="number">1</span>,</span><br><span class="line">    src: <span class="string">'https://fengyuanchen.github.io/cropperjs/images/picture.jpg'</span>,</span><br><span class="line">    quality: <span class="number">0.6</span>,</span><br><span class="line">    title: <span class="string">'上传图片'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>React基本用法</title>
    <url>/2018/01/17/workspace/Frame/react/react/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>React基本用法</strong></p>
<p>[[toc]]</p>
<h3 id="路由传递参数"><a href="#路由传递参数" class="headerlink" title="路由传递参数"></a>路由传递参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">        pathname:<span class="string">"/"</span>,</span><br><span class="line">        search:<span class="string">"?lx=1"</span>,</span><br><span class="line">        hash:<span class="string">"#AA"</span>,</span><br><span class="line">        state: &#123;<span class="attr">id</span>: id&#125; </span><br><span class="line">    &#125;&#125; exact &gt;</span><br><span class="line">     首页</span><br><span class="line"> &lt;<span class="regexp">/Link&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>1.问号传参  基于location来完成处理  <strong>let {data, location: {<code>search</code>}} = this.props</strong> </p>
</li>
<li><p>2.地址栏传参基于match的params来完成处理 <strong>let {data, match: {<code>params</code>}} = this.prop</strong> </p>
</li>
<li><p>3.Link传参 循环进来的，此参数传参在浏览器看不见  <strong>let {data, location: {<code>state</code>}} = this.props</strong> </p>
</li>
<li><p>参数解析（问号传参）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种方式都行</span></span><br><span class="line"><span class="keyword">const</span> utils = &#123;</span><br><span class="line">   queryURLParameter(url) &#123;</span><br><span class="line">        <span class="keyword">let</span> regParam = <span class="regexp">/([^?&amp;=#]+)=?([^?&amp;=#]+)?/ig</span>,</span><br><span class="line">            obj = &#123;&#125;;</span><br><span class="line">        url.replace(regParam, (...arg) =&gt; &#123;</span><br><span class="line">            obj[arg[<span class="number">1</span>]] = arg[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">   &#125;,</span><br><span class="line">   queryStringToJson(queryString) &#123;</span><br><span class="line">        <span class="keyword">if</span> (queryString.indexOf(<span class="string">'?'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            queryString = queryString.split(<span class="string">'?'</span>)[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> pairs = queryString.split(<span class="string">'&amp;'</span>);</span><br><span class="line">        <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">        pairs.forEach(<span class="function"><span class="params">pair</span> =&gt;</span> &#123;</span><br><span class="line">            pair = pair.split(<span class="string">'='</span>);</span><br><span class="line">            result[pair[<span class="number">0</span>]] = <span class="built_in">decodeURIComponent</span>(pair[<span class="number">1</span>] || <span class="string">''</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> utils;</span><br></pre></td></tr></table></figure>

<h3 id="发起-AJAX-请求"><a href="#发起-AJAX-请求" class="headerlink" title="发起 AJAX 请求"></a>发起 AJAX 请求</h3><p>我们应当将AJAX 请求放到 <code>componentDidMount</code> 函数中执行，主要原因有下</p>
<ul>
<li><code>componentsDidMount</code>里面请求数据此时dom已经渲染上去，从用户友好角度来讲，我们更愿意让用户先看到一个没有数据的方式，再通过一个spin的动画，来加载数据;<code>componentsWillMount</code>里面请求数据，拿到数据之后setState的时机是不确定的，可能是render之前，也可能是render之后，并不是下一个时间段，这依赖于ajax的返回时间，所以不能准时的出现loading图，所以说会出现较长白屏的现象.</li>
<li>还有在rn中，用react做服务端的同构，或者更高技术的时候会有一系列的问题【componentWillMount时发生在服务端 componentDidMount在客户端，会冲突】。</li>
<li>React16 调和算法<code>Fiber</code>会通过开始或停止渲染的方式优化应用性能，其会影响到 <code>componentWillMount 的触发次数</code>。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount</li>
</ul>
<h3 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h3><p><code>JavaScript 是弱类型语言，所以请尽量声明 propTypes 对 props 进行校验，以减少不必要的问题。</code></p>
<p><strong><code>内置的 prop type 有：</code></strong></p>
<ul>
<li>PropTypes.array</li>
<li>PropTypes.bool</li>
<li>PropTypes.func</li>
<li>PropTypes.number</li>
<li>PropTypes.object</li>
<li>PropTypes.string</li>
<li>PropTypes.any</li>
<li>PropTypes.shape</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    a: <span class="number">0</span>,</span><br><span class="line">    b: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    a: PropTypes.number,</span><br><span class="line">    b: PropTypes.number,</span><br><span class="line">    store: PropTypes.shape(&#123;</span><br><span class="line">           subscribe: PropTypes.func.isRequired,</span><br><span class="line">           dispatch: PropTypes.func.isRequired,</span><br><span class="line">           getState: PropTypes.func.isRequired</span><br><span class="line">    &#125;),</span><br><span class="line">    data: PropTypes.array.isRequired<span class="comment">//必须有</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">查看更多</a></p>
<h3 id="Hooks为何能使用const-在下面声明的函数"><a href="#Hooks为何能使用const-在下面声明的函数" class="headerlink" title="Hooks为何能使用const 在下面声明的函数"></a>Hooks为何能使用const 在下面声明的函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思想</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> b();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>


<h3 id="组件传递参数"><a href="#组件传递参数" class="headerlink" title="组件传递参数"></a>组件传递参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父</span></span><br><span class="line">&lt;List onItem=&#123;(item) =&gt; <span class="keyword">this</span>.onItem(item)&#125;/&gt;</span><br><span class="line"><span class="comment">//子</span></span><br><span class="line">&#123;list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;styles.item&#125; key=&#123;index&#125;    </span><br><span class="line">     onClick=&#123;() =&gt; <span class="keyword">this</span>.props.onItem(item)&#125;&gt;</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父</span></span><br><span class="line">&lt;List onItem=&#123;<span class="keyword">this</span>.onItem&#125;/&gt;</span><br><span class="line"><span class="comment">//子</span></span><br><span class="line">&#123;list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;styles.item&#125; key=&#123;index&#125;    </span><br><span class="line">     onClick=&#123;() =&gt; <span class="keyword">this</span>.props.onItem(item)&#125;&gt;</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PureComponent原理"><a href="#PureComponent原理" class="headerlink" title="PureComponent原理"></a>PureComponent原理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate: <span class="function">(<span class="params">nextProps = &#123;&#125;, nextState = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> thisProps = <span class="keyword">this</span>.props || &#123;&#125;, thisState = <span class="keyword">this</span>.state || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(thisProps).length !== <span class="built_in">Object</span>.keys(nextProps).length ||</span><br><span class="line">      <span class="built_in">Object</span>.keys(thisState).length !== <span class="built_in">Object</span>.keys(nextState).length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Object</span>.is(thisProps[key], nextProps[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> nextState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (thisState[key] !== nextState[key] || !<span class="built_in">Object</span>.is(thisState[key], nextState[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="缓存路由"><a href="#缓存路由" class="headerlink" title="缓存路由"></a>缓存路由</h3><p><a href="https://juejin.im/post/5cef73a3e51d4510926a7aeb" target="_blank" rel="noopener">网址</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;matchPath&#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Route&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouteCache</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    include: PropTypes.oneOfType([</span><br><span class="line">      PropTypes.bool,</span><br><span class="line">      PropTypes.array</span><br><span class="line">    ])</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  cache = &#123;&#125;; <span class="comment">//缓存已加载过的组件</span></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;children, include = []&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> React.Children.map(children, child =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (React.isValidElement(child)) &#123; <span class="comment">// 验证是否为是react element</span></span><br><span class="line">        <span class="keyword">const</span> &#123;path&#125; = child.props;</span><br><span class="line">        <span class="keyword">const</span> match = matchPath(location.pathname, &#123;...child.props, path&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (match &amp;&amp; (include === <span class="literal">true</span> || include.includes(path))) &#123;</span><br><span class="line">          <span class="comment">//如果匹配，则将对应path的computedMatch属性加入cache对象里</span></span><br><span class="line">          <span class="comment">//当include为true时，缓存全部组件，当include为数组时缓存对应组件</span></span><br><span class="line">          <span class="keyword">this</span>.cache[path] = &#123;<span class="attr">computedMatch</span>: match&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以在computedMatch里追加入一个display属性，可以在路由组件的props.match拿到</span></span><br><span class="line">        <span class="keyword">const</span> cloneProps = <span class="keyword">this</span>.cache[path] &amp;&amp; <span class="built_in">Object</span>.assign(<span class="keyword">this</span>.cache[path].computedMatch, &#123;<span class="attr">display</span>: match ? <span class="string">'block'</span> : <span class="string">'none'</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;display:</span> <span class="attr">match</span> ? '<span class="attr">block</span>' <span class="attr">:</span> '<span class="attr">none</span>'&#125;&#125;&gt;</span>&#123;React.cloneElement(child, &#123;computedMatch: cloneProps&#125;)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">&lt;RouteCache include=&#123;[<span class="string">'/login'</span>, <span class="string">'/home'</span>]&#125;&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/login"</span> component=&#123;Login&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/home"</span> component=&#123;App&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/RouteCache&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="获取实际的DOM"><a href="#获取实际的DOM" class="headerlink" title="获取实际的DOM"></a>获取实际的DOM</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.findDOMNode(<span class="keyword">this</span>.sildeWrapper).clientWidth;   <span class="comment">//废弃  改用ref</span></span><br></pre></td></tr></table></figure>

<h3 id="添加DOM"><a href="#添加DOM" class="headerlink" title="添加DOM"></a>添加DOM</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>: <span class="string">'&lt;p&gt;123&lt;/p&gt;'</span>&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>


<h3 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import PowerList from &quot;.&#x2F;components&#x2F;PowerList&quot;</span><br><span class="line">const MemoPowerList &#x3D; memo(PowerList, (prevProps, nextProps) &#x3D;&gt; prevProps.data &#x3D;&#x3D;&#x3D; nextProps.data);</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line">     &lt;MemoPowerList&#x2F;&gt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  type,</span><br><span class="line">  &#123;props&#125;,</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; jsx 语法</span><br><span class="line">&lt;div id&#x3D;&#39;one&#39; class&#x3D;&#39;two&#39;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;spanOne&quot;&gt;this is spanOne&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;h1 id&#x3D;&quot;spanTwo&quot;&gt;this is spanTwo&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 转化为 js</span><br><span class="line">React.createElement(</span><br><span class="line">    &quot;div&quot;, &#123;id: &quot;one&quot;, className: &quot;two&quot;&#125;,</span><br><span class="line">    React.createElement(&quot;div&quot;, &#123;id: &quot;spanOne&quot;&#125;, &quot;this is spanOne&quot;),</span><br><span class="line">    React.createElement(&quot;h1&quot;, &#123;id: &quot;spanTwo&quot;&#125;, &quot;this is spanTwo&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="React-cloneElement"><a href="#React-cloneElement" class="headerlink" title="React.cloneElement"></a>React.cloneElement</h3><p>新的子元素将取代现有的子元素， <code>key</code>和<code>ref</code>将被保留</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">React.cloneElement(</span><br><span class="line">  element,</span><br><span class="line">  &#123;props&#125;,</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>适用于</strong> 父组件是<code>独立</code>的，子组件是<code>独立</code>的， 父组件数据改变，想要通知子组件，或者子组件想要改父组件的数据(也是通过回调)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Fragment, Component, useState, useEffect&#125; from &#39;react&#39;;</span><br><span class="line">class MyContainer extends Component &#123;</span><br><span class="line">    state &#x3D; &#123;count: 1&#125;;</span><br><span class="line">    handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        this.setState((&#123;count&#125;) &#x3D;&gt; &#123;</span><br><span class="line">            return &#123;count: count + 1&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123;count&#125; &#x3D; this.state;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Fragment&gt;</span><br><span class="line">                &#123;React.Children.map(this.props.children, (item, index) &#x3D;&gt; &#123;</span><br><span class="line">                    return React.cloneElement(item,</span><br><span class="line">                        &#123;</span><br><span class="line">                            parentState: count,</span><br><span class="line">                            handleClick: this.handleClick</span><br><span class="line">                        &#125;,</span><br><span class="line">                    )</span><br><span class="line">                &#125;)&#125;</span><br><span class="line">            &lt;&#x2F;Fragment&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function MySub(props) &#123;</span><br><span class="line">    const &#123;subInfo, parentState, handleClick&#125; &#x3D; props;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div style&#x3D;&#123;&#123;margin: &quot;15px&quot;, border: &quot;1px solid red&quot;, padding: 10&#125;&#125;&gt;</span><br><span class="line">            子元素:&#123;subInfo&#125;</span><br><span class="line">            &lt;br&#x2F;&gt;</span><br><span class="line">            父组件属性count值: &#123;parentState&#125;</span><br><span class="line">            &lt;br&#x2F;&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; handleClick()&#125;&gt;点击+1&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">function Index() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;MyContainer&gt;</span><br><span class="line">                &lt;MySub subInfo&#x3D;&#123;&quot;第一个&quot;&#125;&#x2F;&gt;</span><br><span class="line">                &lt;MySub subInfo&#x3D;&#123;&quot;第二个&quot;&#125;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;MyContainer&gt;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default Index;</span><br></pre></td></tr></table></figure>

<h3 id="ReactDOM-createPortal"><a href="#ReactDOM-createPortal" class="headerlink" title="ReactDOM.createPortal"></a>ReactDOM.createPortal</h3><p>react 中所有的组件都会位于#app下，而使用Portals提供了一种脱离#app的组件。</p>
<p>适用 <code>模态框，通知，警告，goTop</code> 等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Fragment, useState, useEffect&#125; from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;</span><br><span class="line"></span><br><span class="line">const modalRoot &#x3D; document.getElementById(&#39;modal&#39;);</span><br><span class="line"></span><br><span class="line">class Modal extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.el &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        modalRoot.appendChild(this.el);</span><br><span class="line">        console.log(document.getElementById(&#39;root&#39;).style.display &#x3D; &#39;none&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        modalRoot.removeChild(this.el);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return ReactDOM.createPortal(</span><br><span class="line">            this.props.children,</span><br><span class="line">            this.el,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function f() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Modal&gt;</span><br><span class="line">            妈的 DW</span><br><span class="line">        &lt;&#x2F;Modal&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default f;</span><br></pre></td></tr></table></figure>

<h3 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h3><p>就是给组件添加一个<code>值为函数</code>的属性，这个函数可以在<code>组件渲染</code>的时候调用</p>
<p><strong>适用于</strong> 父组件是独立的，子组件是独立的， 父组件数据改变，想要通知子组件，或者子组件想要改父组件的数据(也是通过回调)</p>
<p><strong>实现一个图片跟随鼠标的功能</strong></p>
<p>不知道这个功能之前可能这样实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> Cat = <span class="function">(<span class="params">&#123;mouse&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;img src=<span class="string">"https://ae01.alicdn.com/kf/H62563fe1dc6447aca248634b671b7a59W.png"</span></span><br><span class="line">             style=&#123;&#123;<span class="attr">position</span>: <span class="string">'absolute'</span>, <span class="attr">left</span>: mouse.x, <span class="attr">top</span>: mouse.y&#125;&#125; alt=&#123;<span class="string">''</span>&#125;/&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    handleMouseMove = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            x: event.clientX,</span><br><span class="line">            y: event.clientY</span><br><span class="line">        &#125;, () =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state) <span class="comment">//在这里传给父组件</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div style=&#123;&#123;<span class="attr">height</span>: <span class="string">'100vh'</span>&#125;&#125; onMouseMove=&#123;<span class="keyword">this</span>.handleMouseMove&#125;&gt;</span><br><span class="line">                &lt;h1&gt;移动鼠标&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;当前的鼠标定位 (X:&#123;this.state.x&#125;, Y:&#123;this.state.y&#125;)&lt;/</span>p&gt;</span><br><span class="line">                &#123;<span class="comment">/*<span class="doctag">TODO:</span>组件在里面渲染*/</span>&#125;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;  </span><br><span class="line">                </span><br><span class="line">                &#123;<span class="comment">/*<span class="doctag">TODO:</span>这种方式简单*/</span>&#125;</span><br><span class="line">                &#123;<span class="comment">/*&#123;*/</span>&#125;</span><br><span class="line">                &#123;<span class="comment">/*    React.Children.map(this.props.children, (item, index) =&gt; &#123;*/</span>&#125;</span><br><span class="line">                &#123;<span class="comment">/*        return React.cloneElement(item,*/</span>&#125;</span><br><span class="line">                &#123;<span class="comment">/*            &#123;*/</span>&#125;</span><br><span class="line">                &#123;<span class="comment">/*                mouse: this.state*/</span>&#125;</span><br><span class="line">                &#123;<span class="comment">/*            &#125;,*/</span>&#125;</span><br><span class="line">                &#123;<span class="comment">/*        )*/</span>&#125;</span><br><span class="line">                &#123;<span class="comment">/*    &#125;)*/</span>&#125;</span><br><span class="line">                &#123;<span class="comment">/*&#125;*/</span>&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">class Index extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    state = &#123; mouse: &#123;&#125; &#125;;  /</span><span class="regexp">/交给他们的父级来出来，然后重新state,把值传进来</span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        const &#123;mouse&#125; = this.state;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;Mouse render=&#123;(item) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                this.setState(&#123;mouse: item&#125;)</span></span><br><span class="line"><span class="regexp">            &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Cat mouse=&#123;mouse&#125;/</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/Mouse&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Index;</span></span><br></pre></td></tr></table></figure>

<p>现在可以这么实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> Cat = <span class="function">(<span class="params">&#123;mouse&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;img src=<span class="string">"https://ae01.alicdn.com/kf/H62563fe1dc6447aca248634b671b7a59W.png"</span></span><br><span class="line">             style=&#123;&#123;<span class="attr">position</span>: <span class="string">'absolute'</span>, <span class="attr">left</span>: mouse.x, <span class="attr">top</span>: mouse.y&#125;&#125; alt=&#123;<span class="string">''</span>&#125;/&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    handleMouseMove = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            x: event.clientX,</span><br><span class="line">            y: event.clientY</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div style=&#123;&#123;<span class="attr">height</span>: <span class="string">'100vh'</span>&#125;&#125; onMouseMove=&#123;<span class="keyword">this</span>.handleMouseMove&#125;&gt;</span><br><span class="line">                &lt;h1&gt;移动鼠标&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;当前的鼠标定位 (X:&#123;this.state.x&#125;, Y:&#123;this.state.y&#125;)&lt;/</span>p&gt;</span><br><span class="line">                &#123;<span class="comment">/*<span class="doctag">TODO:</span>在render里面执行的这个方法，不仅仅是执行当前这个函数还把函数在这里渲染出来了*/</span>&#125;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state)&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const Index = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const catRender=(item)=&gt;&lt;Cat mouse=&#123;item&#125;/</span>&gt;;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Mouse</span> <span class="attr">render</span>=<span class="string">&#123;catRender&#125;/</span>&gt;</span></span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index;</span><br></pre></td></tr></table></figure>

<h3 id="Error-Boundaries"><a href="#Error-Boundaries" class="headerlink" title="Error Boundaries"></a>Error Boundaries</h3><p><code>错误边界</code>是一种React组件，这种组件<strong>可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI</strong>，而不是渲染那些崩溃了的子组件树。<br>错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p>
<p><strong>static getDerivedStateFromError(error)</strong></p>
<p>当后代组件抛出错误时，首先会调用这个方法，并将抛出的错误作为参数。无论这个方法返回什么值，都将用于更新组件的状态。</p>
<p>在后代组件抛出错误之后，也会调用<strong>componentDidCatch</strong>方法除了抛出的错误之外，还会有另一个参数，这个参数包含了有关错误的更多信息</p>
<ul>
<li>getDerivedStateFromError是在reconciliation阶段触发，所以getDerivedStateFromError进行捕获错误后进行组件的状态变更，不允许出现副作用。</li>
<li>componentDidCatch因为在commit阶段，因此允许执行副作用。 它应该用于记录错误之类的情况</li>
</ul>
<p>::: warning 注意<br>错误边界无法捕获以下场景中产生的错误：</p>
<ul>
<li>事件处理（了解更多）</li>
<li>异步代码（例如 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 回调函数）</li>
<li>服务端渲染</li>
<li>它自身抛出来的错误（并非它的子组件）</li>
</ul>
<p><strong>只有 class 组件才可以成为错误边界组件</strong></p>
<p>自React16起，<code>任何未被错误边界捕获的错误</code>将会导致整个React组件树被卸载。</p>
<p><strong>错误边界的<code>粒度</code>由你来决定，可以将其包装在<code>最顶层的路由</code>组件并为用户展示一个 “Something went wrong” 的错误信息，<br>就像服务端框架经常处理崩溃一样。<br>你也可以将<code>单独的部件</code>包装在错误边界以保护应用其他部分不崩溃。</strong><br>:::</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, errorInfo) &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    logErrorToMyService(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Code-Splitting"><a href="#Code-Splitting" class="headerlink" title="Code Splitting"></a>Code Splitting</h3><p><strong>import()</strong>  </p>
<p>适用于函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;add.js</span><br><span class="line">export const sum &#x3D; (a, b) &#x3D;&gt; a + b;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;index.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">function Index() &#123;</span><br><span class="line">    const handleClick &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">        const &#123;sum&#125; &#x3D; await import(&#39;.&#x2F;add&#39;);</span><br><span class="line">        console.log(sum(1, 2));</span><br><span class="line">    &#125;;</span><br><span class="line">    return (</span><br><span class="line">        &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default Index;</span><br></pre></td></tr></table></figure>
<p><strong>React.lazy</strong></p>
<p>适用于组件 目前不支持服务端渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo &#x3D; React.lazy(() &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;Foo&#39;));</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">            &lt;Suspense fallback&#x3D;&#123;&lt;div&gt;loading...&lt;&#x2F;div&gt;&#125;&gt;</span><br><span class="line">                &lt;Foo&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Suspense&gt;</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>React.lazy 目前只支持默认导出（default exports)</code> 你可以创建一个中间模块，来重新导出为默认模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.jsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="comment">//middle.js</span></span><br><span class="line"><span class="keyword">export</span> &#123; A <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">"./a"</span>;   <span class="comment">//A就相当于默认导出</span></span><br><span class="line"><span class="comment">//index.jsx</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; lazy &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> A = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./middle"</span>));</span><br><span class="line"></span><br><span class="line">&lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;A/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/Suspense&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="React-StrictMode"><a href="#React-StrictMode" class="headerlink" title="React.StrictMode"></a>React.StrictMode</h3><p>开发模式会调用多次</p>
<p>StrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样，StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;React.StrictMode&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ComponentOne /&gt;</span><br><span class="line">          &lt;ComponentTwo /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>React.StrictMode&gt;</span><br><span class="line">      &lt;Footer /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>StrictMode 目前有助于：</strong></p>
<ul>
<li>识别不安全的生命周期</li>
<li>关于使用过时字符串 ref API 的警告（React.createRef();）</li>
<li>关于使用废弃的 findDOMNode 方法的警告（貌似没有）</li>
<li>检测遗留 context API</li>
<li>检测意外的副作用</li>
</ul>
<p>react 在检测意外的副作用时可能重复调用某些生命周期方法、hooks 或者 render 方法，其包括：</p>
<p>class 组件的 constructor，render 以及 shouldComponentUpdate 方法<br>class 组件的生命周期方法 getDerivedStateFromProps<br>函数组件<br>状态更新函数 (即 setState 的第一个参数）<br>函数组件中 useState，useMemo 或者 useReducer 中的函数<br>当 React 发现在重复调用这些方法时出现了内存泄漏、无限循环或者其他奇怪的表现时会在控制台输出错误，以供程序员快速定位错误。</p>
<p>简单来说就是我们在使用 hooks 或者在某些生命周期函数中不应该使用有副作用的代码。在开发模式的 StrictMode 下，React 会帮助我们发现这些不好的代码并给予提示。</p>
<p>StrictMode 的这个重复调用的特性只使用于开发模式，在生产模式下不会触发多次调用。</p>
<h3 id="ref-非受控"><a href="#ref-非受控" class="headerlink" title="ref(非受控)"></a>ref(非受控)</h3><p>React的ref有4种用法：</p>
<ul>
<li><p>字符串(已废弃)</p>
</li>
<li><p>回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取子组件的dom节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Parent(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      My input: &lt;CustomTextInput inputRef=&#123;props.inputRef&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Grandparent extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;Parent</span></span><br><span class="line"><span class="regexp">        inputRef=&#123;el =&gt; this.inputElement = el&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>React.createRef()</strong> （React16.3提供,无状态的组件也可以使用）</p>
</li>
<li><p>Hooks <strong>useRef()</strong> 用法类似createRef()</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> inputRef = useRef(<span class="literal">null</span>);</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        inputRef.current.focus();</span><br><span class="line">    &#125;, []);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;inputRef&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.myRef=React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.myRef.current);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;/</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无状态组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// textInput must be declared here so the ref can refer to it</span></span><br><span class="line">  <span class="keyword">let</span> textInput = React.createRef();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    textInput.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        ref=&#123;textInput&#125; /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"button"</span></span><br><span class="line">        value=<span class="string">"Focus the text input"</span></span><br><span class="line">        onClick=&#123;handleClick&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>React.forwardRef()</code>  同样是React 16.3版本后提供的，可以用来创建子组件，以传递ref。</li>
</ul>
<h3 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hbb3d522c7afa45d894e583388f1615f4p.jpg" alt=""></p>
<h3 id="antd"><a href="#antd" class="headerlink" title="antd"></a>antd</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">'~antd/es/style/themes/default.less'</span>;</span><br><span class="line"></span><br><span class="line">@pro-header-hover-bg: rgba(0, 0, 0, 0.025);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取from里面的数据集合</span></span><br><span class="line"> <span class="keyword">this</span>.props.form.getFieldsValue()</span><br><span class="line"><span class="comment">//重置from输入的内容，（参数不传默认是所有的）</span></span><br><span class="line"><span class="keyword">this</span>.props.form.resetFields(<span class="string">'search_product_name'</span>);</span><br><span class="line"><span class="comment">//抛出错误</span></span><br><span class="line"><span class="keyword">this</span>.props.form.setFields(&#123;</span><br><span class="line">   name: &#123;</span><br><span class="line">      value: val,</span><br><span class="line">        errors: [<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'forbid ha'</span>)],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//设置from的值</span></span><br><span class="line"><span class="keyword">this</span>.props.form.setFieldsValue(&#123;</span><br><span class="line">   points: <span class="number">1212121</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 提交数据滚动到该位置</span></span><br><span class="line"><span class="comment">* 参数1 只捕捉该字段的数据</span></span><br><span class="line"><span class="comment">* 参数2 定义 validateFieldsAndScroll 的滚动行为</span></span><br><span class="line"><span class="comment">* 参数3 获取数据，错误捕获</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">form.validateFieldsAndScroll( </span><br><span class="line">   [<span class="string">'user'</span>, <span class="string">'password'</span>],</span><br><span class="line">    &#123;</span><br><span class="line">      scroll: &#123;</span><br><span class="line">           offsetTop: <span class="number">60</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,(err, fieldsValue) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(err)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;     </span><br><span class="line">)</span><br><span class="line"><span class="comment">//自定义输入框额格式 </span></span><br><span class="line">&#123;getFieldDecorator(<span class="string">'user'</span>, &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#123;<span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'必填'</span>&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        validator: <span class="function">(<span class="params">rule, value, callback</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'不符合'</span>) &#123;</span><br><span class="line">                callback(<span class="string">'不符合'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            callback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ],</span><br><span class="line">    initialValue: <span class="string">''</span></span><br><span class="line">&#125;)(<span class="xml"><span class="tag">&lt;<span class="name">Input</span>/&gt;</span></span>)&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义环境变量"><a href="#定义环境变量" class="headerlink" title="定义环境变量"></a>定义环境变量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cross-env ANALYZE=<span class="literal">true</span> <span class="comment">// 设置环境变量</span></span><br><span class="line">process.env.ANALYZE=<span class="literal">true</span>  <span class="comment">// 获取环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">    ENV: <span class="built_in">JSON</span>.stringify(process.env.ENV), <span class="comment">// 可以设置环境变量在页面直接使用</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>react 默认测试环境 NODE_ENV为<code>development</code>，正式为<code>production</code></p>
<h3 id="dva-amp-effects"><a href="#dva-amp-effects" class="headerlink" title="dva &amp; effects"></a>dva &amp; effects</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局执行model</span></span><br><span class="line"><span class="built_in">window</span>.g_app </span><br><span class="line"></span><br><span class="line"><span class="comment">//effects基本用法</span></span><br><span class="line">*add(action,&#123;put,call,select&#125;)&#123;</span><br><span class="line">    <span class="keyword">yield</span> call(delay,<span class="number">1000</span>);<span class="comment">//yield 调用一个delay的方法，返回一个promise,会等待在这里。等待到promise变成完成态</span></span><br><span class="line">    <span class="keyword">yield</span> fork(delay,<span class="number">1000</span>);<span class="comment">//yield 调用一个delay的方法，返回一个promise,直接执行不会堵塞</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">yield</span> put(&#123;<span class="attr">type</span>:<span class="string">'counter/minus'</span>&#125;);<span class="comment">//put派发一个动作,相当于dispatch;注意： put 也是阻塞 effect</span></span><br><span class="line">    <span class="keyword">let</span> state = <span class="keyword">yield</span> select(<span class="function"><span class="params">state</span>=&gt;</span>state.counter);  <span class="comment">//获取store的数据相当于 store.getState()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> &#123;push&#125; = routerRedux;<span class="comment">//dva封装的router-redux，dva的核心库没有这个方法。</span></span><br><span class="line">    <span class="keyword">yield</span> put(push(action.to));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//effects里面调取公共的方法  例：</span></span><br><span class="line"> effects: &#123;</span><br><span class="line">    * a(action, person) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">8888</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    * b(action, person) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put(&#123;<span class="comment">//就是dispatch</span></span><br><span class="line">            type: <span class="string">'a'</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dva请求多个接口</span></span><br><span class="line"><span class="comment">//方法一 ：利用Promise.all</span></span><br><span class="line"><span class="keyword">const</span> [ary1,ary2] = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all([queryWxapps(scenicid()[<span class="string">'id'</span>]), queryWxapps(scenicid()[<span class="string">'id'</span>]), queryWxapps(scenicid()[<span class="string">'id'</span>])])</span><br><span class="line"><span class="built_in">console</span>.log(ary1);<span class="comment">//[&#123;&#125;,&#123;&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二 ：利用axios.all()</span></span><br><span class="line">axios.all([queryWxapps(scenicid()[<span class="string">'id'</span>]), queryWxapps(scenicid()[<span class="string">'id'</span>]), queryWxapps(scenicid()[<span class="string">'id'</span>]).then(axios.spread(<span class="function">(<span class="params">user, aside</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">  <span class="built_in">console</span>.log(aside);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">//方法三 ：sage提供的将会同步执行</span></span><br><span class="line"><span class="keyword">const</span> [a,b,c] = <span class="keyword">yield</span> [</span><br><span class="line">    call(groupbuysList, shopid()[<span class="string">'id'</span>], action.params),</span><br><span class="line">    call(groupbuysList, shopid()[<span class="string">'id'</span>], action.params),</span><br><span class="line">    call(groupbuysList, shopid()[<span class="string">'id'</span>], action.params)</span><br><span class="line">];</span><br><span class="line"><span class="comment">//方法四 ：sage提供的yield all</span></span><br><span class="line"> <span class="keyword">const</span> [a,b,c]  = <span class="keyword">yield</span> all([</span><br><span class="line">    call(groupbuysList, shopid()[<span class="string">'id'</span>], action.params),</span><br><span class="line">    call(groupbuysList, shopid()[<span class="string">'id'</span>], action.params),</span><br><span class="line">    call(groupbuysList, shopid()[<span class="string">'id'</span>], action.params),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>React</category>
        <category>React基本用法</category>
      </categories>
      <tags>
        <tag>React.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React-SSR</title>
    <url>/2020/06/13/workspace/Frame/react/ssr/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>React-SSR</strong></p>
<p>[[toc]]</p>
<hr>
<p>先附上github地址<a href="https://github.com/hzfvictory/react-ssr,方便大家更容易理解，不然后面很多地方会一头雾水。" target="_blank" rel="noopener">https://github.com/hzfvictory/react-ssr,方便大家更容易理解，不然后面很多地方会一头雾水。</a></p>
<p>欢迎大家点star,提issue，一起进步！😄 </p>
<h3 id="客户端渲染与服务端渲染"><a href="#客户端渲染与服务端渲染" class="headerlink" title="客户端渲染与服务端渲染"></a>客户端渲染与服务端渲染</h3><p><strong>CSR:</strong></p>
<p>页面渲染是JS负责进行的</p>
<p>浏览器发送请求–&gt;服务器返回HTML–&gt;浏览器发送bundle.js请求–&gt;服务器返回bundle.js–&gt;浏览器执行bundle.js中的react代码完成渲染</p>
<p><strong>SSR:</strong></p>
<p>服务器端直接返回HTML让浏览器直接渲染</p>
<p>浏览器发送请求–&gt;服务器运行React代码生成页面–&gt;服务器返回页面</p>
<p><strong>传统CSR的弊端:</strong></p>
<ol>
<li><p>由于页面显示过程要进行JS文件拉取和React代码执行，在这个渲染过程中至少涉及到两个 HTTP请求周期（html+js），所以会有一定的耗时，首屏加载时间会比较慢。</p>
</li>
<li><p>对于SEO(Search Engine Optimazition,即搜索引擎优化)，完全无能为力，因为搜索引擎爬虫只认识html结构的内容，而不能识别JS代码内容。</p>
</li>
</ol>
<p><strong>SSR的弊端:</strong></p>
<p>ssr的出现，就是为了解决这些传统CSR的弊端</p>
<p>在 React 中使用 ssr 技术，我们让 React 代码在服务器端先执行一次，使得用户下载的 HTML 已经包含了所有的页面展示内容，这样，页面展示的过程只需要经历一个 HTTP 请求周期，TTFP（Time To First Page） 时间得到一倍以上的缩减</p>
<p>但是使用 ssr 这种技术，将使原本简单的 React 项目变得非常复杂</p>
<ol>
<li><p>相对于仅仅需要提供静态文件的服务器，ssr中使用的渲染程序自然会占用更多的CPU和内存资源</p>
</li>
<li><p>在服务器生成的页面所以，一些常用的浏览器API可能无法正常使用，比如window、docment和alert等，如果使用的话需要对运行的环境加以判断</p>
</li>
<li><p>开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂</p>
</li>
<li><p>可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致，项目的可维护性会降低，代码问题的追溯也会变得困难</p>
</li>
</ol>
<p>所以，使用 ssr 在解决问题的同时，也会带来非常多的副作用，有的时候，这些副作用的伤害比起 ssr 技术带来的优势要大的多。一般建议ssr，除非你的项目特别依赖搜索引擎流量，或者对首屏时间有特殊的要求，否则不建议使用 ssr,如果只对seo有要求可使用 <a href="https://github.com/prerender/prerender" target="_blank" rel="noopener">prerender预渲染</a>。</p>
<h3 id="SSR的实现本质"><a href="#SSR的实现本质" class="headerlink" title="SSR的实现本质"></a>SSR的实现本质</h3><p>这里介绍的是ssr，是基于React 的SPA项目，不是像 thinkphp、jsp、nodeJs+ejs 这种纯后端直出渲染方式，所以这种大多数只是针对首屏的ssr,因为浏览器的路由跳转方式是用的H5的<code>history  API</code>的<code>window.history.pushState()</code> ，使得我们即可以修改 <code>url</code> 也可以不刷新页面，所以是不会走服务端的【可以通过预加载获取需要的数据】。</p>
<p><strong>ssr 之所以能够实现，本质上是因为虚拟 DOM 的存在</strong></p>
<p>ssr 的工程中，React 代码会在客户端和服务器端各执行一次,因为代码在 Node 环境下是没有DOM这个概念的，所以在React 框架中引入了一个概念叫做虚拟 DOM，React 在做页面操作时，实际上不是直接操作 DOM，而是操作虚拟 DOM，也就是操作普通的 JavaScript 对象，这就使得 ssr 成为了可能。在服务器，我可以操作 JavaScript 对象，判断环境是服务器环境，我们把虚拟 DOM 映射成字符串输出；在客户端，我也可以操作 JavaScript 对象，判断环境是客户端环境，我就直接将虚拟 DOM 映射成真实 DOM，完成页面挂载。</p>
<h3 id="方案筛选"><a href="#方案筛选" class="headerlink" title="方案筛选"></a>方案筛选</h3><ul>
<li><a href="[https://nextjs.frontendx.cn/docs/#%E5%AE%89%E8%A3%85](https://nextjs.frontendx.cn/docs/#安装)">next.js</a>/<a href="https://www.nuxtjs.cn/guide/installation" target="_blank" rel="noopener">nuxt.js</a>      成本低,安心的写页面就行了，无需过多关心服务端路由（多页面应用，新框架）</li>
<li><a href="https://github.com/hzfvictory/prerender" target="_blank" rel="noopener">prerender </a>实现spa项目的服务端预渲染</li>
<li>使用谷歌 <a href="https://github.com/hzfvictory/rendertron" target="_blank" rel="noopener">rendertron</a> 实现spa项目的服务端渲染 【据说会被判作弊的，降权处理】</li>
<li>秉承学习的态度了解下基本原理，选择了自己去搭，（中间断了一段时间，现在又重新拾起来），之前看到有人用 react + redux + Express 搭ssr的文章，所以基于对dva和koa的熟悉和特别喜好，就直接选择了dva-core + koa 做状态管理搭建。</li>
</ul>
<h3 id="Koa实现基础版本的SSR"><a href="#Koa实现基础版本的SSR" class="headerlink" title="Koa实现基础版本的SSR"></a>Koa实现基础版本的SSR</h3><h4 id="不使用koa-router"><a href="#不使用koa-router" class="headerlink" title="不使用koa-router"></a>不使用koa-router</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.path === <span class="string">'/'</span>) &#123;</span><br><span class="line">    ctx.body =</span><br><span class="line">      <span class="string">`</span></span><br><span class="line"><span class="string">     &lt;html&gt;</span></span><br><span class="line"><span class="string">       &lt;head&gt;</span></span><br><span class="line"><span class="string">         &lt;title&gt;禾口和ssr&lt;/title&gt;</span></span><br><span class="line"><span class="string">       &lt;/head&gt;</span></span><br><span class="line"><span class="string">       &lt;body&gt;</span></span><br><span class="line"><span class="string">         &lt;h1&gt;hello&lt;/h1&gt;</span></span><br><span class="line"><span class="string">         &lt;h2&gt;world&lt;/h2&gt;</span></span><br><span class="line"><span class="string">       &lt;/body&gt;</span></span><br><span class="line"><span class="string">     &lt;/html&gt;</span></span><br><span class="line"><span class="string">     `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> server = app.listen(<span class="string">'9999'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;port&#125; = server.address();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="使用koa-router"><a href="#使用koa-router" class="headerlink" title="使用koa-router"></a>使用koa-router</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> route = <span class="built_in">require</span>(<span class="string">"koa-router"</span>)() <span class="comment">// 这里也可以使用构造函数</span></span><br><span class="line"></span><br><span class="line">route.get(<span class="string">"/"</span>, (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body =</span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">   &lt;html&gt;</span></span><br><span class="line"><span class="string">       &lt;head&gt;</span></span><br><span class="line"><span class="string">         &lt;title&gt;禾口和ssr&lt;/title&gt;</span></span><br><span class="line"><span class="string">       &lt;/head&gt;</span></span><br><span class="line"><span class="string">       &lt;body&gt;</span></span><br><span class="line"><span class="string">         &lt;h1&gt;hello&lt;/h1&gt;</span></span><br><span class="line"><span class="string">         &lt;h2&gt;world&lt;/h2&gt;</span></span><br><span class="line"><span class="string">       &lt;/body&gt;</span></span><br><span class="line"><span class="string">     &lt;/html&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(route.routes());</span><br><span class="line">app.use(route.allowedMethods()); <span class="comment">//自动设置响应头ctx.status完善response响应头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = app.listen(<span class="string">'9999'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;port&#125; = server.address();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>这样一个简单的服务端渲染就搞定了，服务器端直接返回HTML让浏览器直接渲染，而且网页源代码中是有这些dom信息的对seo非常友好，我们react、vue这些都是通过webpack引入了js,所有的功能页面展示统统由js完成。</p>
<h3 id="实现React组件的服务端渲染"><a href="#实现React组件的服务端渲染" class="headerlink" title="实现React组件的服务端渲染"></a>实现React组件的服务端渲染</h3><p>到这一步已经不能直接用node启动服务了，因为没有<code>babel</code>，  React不会转化成<code>createElement</code>的形式，而且使用node也不能直接使用import导入方式。</p>
<p>随便编写一个React的组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/pages/home</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;Home组件&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure>

<p>然后我们把当前组件，使用服务员渲染出来，看下面配置：</p>
<h4 id="Webpack-base"><a href="#Webpack-base" class="headerlink" title="Webpack base"></a>Webpack base</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/webpack.base.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.js|jsx$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        presets: [<span class="string">'@babel/preset-react'</span>, [<span class="string">'@babel/preset-env'</span>, &#123;</span><br><span class="line">          targets: &#123;</span><br><span class="line">            browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="服务器端-Webpack-配置"><a href="#服务器端-Webpack-配置" class="headerlink" title="服务器端 Webpack 配置"></a>服务器端 Webpack 配置</h4><p>服务端运行的代码如果需要依赖 Node 核心模块或者第三方模块，<code>就不再需要把客户端的一些模块代码打包到最终代码中了</code>。因为环境已经安装这些依赖，可以直接引用。这样一来，就需要我们在 webpack 中配置：<code>target：node</code>，并借助 webpack-node-externals 插件，解决第三方依赖打包的问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/webpack.server.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>)</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serverConfig = &#123;</span><br><span class="line">  target: <span class="string">'node'</span>, <span class="comment">// 编译出能让node识别的代码  https://webpack.docschina.org/concepts/targets/</span></span><br><span class="line">  mode: <span class="string">'development'</span>, <span class="comment">// 这里的mode要特别注意</span></span><br><span class="line">  entry: <span class="string">'./src/server/index.js'</span>, <span class="comment">// 对应服务端的代码</span></span><br><span class="line">  <span class="comment">// https://webpack.docschina.org/configuration/externals/</span></span><br><span class="line">  externals: [nodeExternals()], <span class="comment">// 为了忽略node_modules文件夹中的所有模块</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../bundle'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = merge(config, serverConfig)</span><br></pre></td></tr></table></figure>



<p> <strong>target: ‘node’ 和 target: ‘web’ 的大致区别</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// target: 'node'</span></span><br><span class="line">exports.ids = [<span class="number">0</span>];</span><br><span class="line">exports.modules = &#123;&#125;;</span><br><span class="line"><span class="comment">// target: 'web' </span></span><br><span class="line">(<span class="built_in">window</span>[<span class="string">"webpackJsonp"</span>] = <span class="built_in">window</span>[<span class="string">"webpackJsonp"</span>] || []).push([[<span class="number">0</span>],&#123;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server/index.js</span></span><br><span class="line"><span class="keyword">import</span> Koa <span class="keyword">from</span> <span class="string">'koa'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"koa-router"</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>; <span class="comment">// 必须引入</span></span><br><span class="line"><span class="keyword">import</span> &#123;renderToString&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>; <span class="comment">// react-dom提供的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"../src/pages/home"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> route = <span class="keyword">new</span> Router()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">route.get(<span class="string">"/"</span>, (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body =</span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;html&gt;</span></span><br><span class="line"><span class="string">      &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;禾口和ssr&lt;/title&gt;</span></span><br><span class="line"><span class="string">      &lt;/head&gt;</span></span><br><span class="line"><span class="string">      &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;div id="root"&gt;<span class="subst">$&#123;content&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(route.routes());</span><br><span class="line">app.use(route.allowedMethods());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = app.listen(<span class="string">'9999'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;port&#125; = server.address();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>以上使用了<strong>renderToString</strong>, 我们都知道react-dom提供了四种服务端渲染函数,如下:</p>
<ol>
<li><strong>renderToString</strong>：将 React Component 转化为 HTML 字符串，生成的 HTML 的 DOM 会带有额外属性：各个 DOM 会有data-react-id属性，第一个 DOM 会有data-reactroot属性。</li>
<li><strong>renderToStaticMarkup</strong>：将 React Component 转化为 HTML 字符串，但是生成 HTML 的 DOM 不会有额外属性，从而节省 HTML 字符串的大小。</li>
<li><strong>renderToNodeStream:</strong> 以流的形式输出html, 不用像renderToString生成整个html才发送给客户端。相对于renderToString能更快的响应客户端，提升页面渲染速度。</li>
<li><strong>renderToStaticNodeStream</strong>：和 renderToNodeStream一样，也是输出流，但是html中不带data-reactroot等属性。</li>
</ol>
<p><strong>对于服务端渲染而言</strong></p>
<ul>
<li><strong>renderToString</strong>方法渲染的节点会带有data-react-id属性, 在前端 react 加载完成后, 前端 react 会认识之前服务端渲染的内容, 不会重新渲染 DOM 节点, 前端 react 会接管页面, 执行 <code>componentDidMout</code> 绑定浏览器事件等 这些在服务端没完成也不可能执行任务。</li>
<li><strong>renderToStaticMarkup</strong> 渲染出的是不带<code>data-react-id</code>的纯 html 在前端 react 加载完成后, 之前服务端渲染的页面会抹掉之前服务端的重新渲染(可能页面会闪一下). 换句话说 <strong>前端react就根本就不认识之前服务端渲染的内容</strong>, render 方法会使用 innerHTML 的方法重写 #react-target 里的内容</li>
</ul>
<p>在package添加启动配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"npm-run-all --parallel dev:build:server dev:start"</span>,</span><br><span class="line">    <span class="string">"dev:build:server"</span>: <span class="string">"webpack --config config/webpack.server.js --watch"</span>,</span><br><span class="line">    <span class="string">"dev:start"</span>: <span class="string">"nodemon ./bundle/bundle.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行  yarn dev ,打开 <a href="">http://localhost:9999/ </a>页面直接在浏览上显示， 到此，就初步实现了一个React组件是服务端渲染,加入你在组件Home里面添加一些方法或者调取接口，你会发现这些都没有执行，所以我们还需要接下来进一步完善。</p>
<h3 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h3><p>要解决上面上面的问题，就需要同构了，所谓同构，通俗的讲，就是一套React代码在服务器上运行一遍，到浏览器渲染时在运行一遍，服务端渲染完成页面结构，浏览器端渲染完成事件绑定接口调取（重复加载的js或者css客户端协调阶段时候会进行比对，如果一样则不渲染了）。</p>
<h4 id="客户端针对路由打包JS"><a href="#客户端针对路由打包JS" class="headerlink" title="客户端针对路由打包JS"></a>客户端针对路由打包JS</h4><p>把打包后的js,注入到html中，这样到浏览器就会再次请求，就可以完成事件绑定等行为操作。</p>
<p>我们要用到react-dom的<code>hydrate</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client/index.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Switch&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;renderRoutes&#125; <span class="keyword">from</span> <span class="string">'react-router-config'</span>;</span><br><span class="line"><span class="keyword">import</span> Loadable <span class="keyword">from</span> <span class="string">'react-loadable'</span>; <span class="comment">// 这里是我的一个路由拆分，你们可以不用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'../router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &#123;renderRoutes(routes.routes)&#125;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Router&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Loadable.preloadReady().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ReactDom.hydrate(</span><br><span class="line">    &lt;App/&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>hydrate() 描述的是 ReactDOM 复用 ReactDOMServer 服务端渲染的内容时尽可能保留结构，并补充事件绑定等 Client 特有内容的过程</p>
<p>说白了<code>render()</code> 标签上没有唯一的属性，但是要尽可能复用 ssr 的 HTML 结构,所以就出现了<code>hydrate()</code>,但是目前两者都是可以用的，17版本<code>render()</code>就不在支持<code>ssr</code></p>
<p><a href="https://www.zhihu.com/question/66068748" target="_blank" rel="noopener">知乎对 ReactDom.hydrate 的解释</a></p>
<p>然后配置客户端的webpack将其编译打包成js，在服务端html里面引入。</p>
<h4 id="客户端-Webpack-配置"><a href="#客户端-Webpack-配置" class="headerlink" title="客户端 Webpack 配置"></a>客户端 Webpack 配置</h4><p>客户端和服务端打包后的输出目录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/outputPath </span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  OUTPUTCLIENT: <span class="string">'static'</span>,</span><br><span class="line">  OUTPUTSERVER: <span class="string">'bundle'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/webpack.client.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;OUTPUTCLIENT&#125; = <span class="built_in">require</span>(<span class="string">"./outputPath"</span>)</span><br><span class="line"><span class="keyword">const</span> outputPath = <span class="string">`../<span class="subst">$&#123;OUTPUTCLIENT&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clientConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">'../client/index.js'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'index.[chunkhash:8].js'</span>, <span class="comment">// 这里我用的hash，目的是防止缓存</span></span><br><span class="line">    path: path.resolve(__dirname, outputPath),</span><br><span class="line">    publicPath: <span class="string">'/'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, &#123;<span class="comment">// 这里建议使用style-loader，少量的css直接采用客户端渲染了</span></span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            modules: <span class="literal">true</span>, <span class="comment">// 这要跟服务端保持一致，不然head里面有样式，客户端没有对应的class</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpeg|jpg|gif|svg)?$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">8000</span>,</span><br><span class="line">          outputPath: outputPath, <span class="comment">// 输入路径</span></span><br><span class="line">          publicPath: <span class="string">'/'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = merge(config, clientConfig)</span><br></pre></td></tr></table></figure>


<p>然后在上面的<code>package.json</code>,里面添加<code>&quot;dev:build:client&quot;: &quot;webpack --config webpack.client.js --watch&quot;</code>，就能对浏览器用到的一些js完成打包。</p>
<h4 id="服务端的路由逻辑"><a href="#服务端的路由逻辑" class="headerlink" title="服务端的路由逻辑"></a>服务端的路由逻辑</h4><p>服务器端路由代码相对要复杂一点，需要你把 <code>location</code>（当前请求路径）传递给 <code>StaticRouter</code> 组件，这样 <code>StaticRouter</code> 才能根据路径分析出当前所需要的组件是谁。（PS：<code>StaticRouter</code> 是 <code>React-Router</code>针对服务器端渲染专门提供的一个路由组件。）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server/index.js</span></span><br><span class="line"><span class="keyword">import</span> Koa <span class="keyword">from</span> <span class="string">'koa'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"koa-router"</span></span><br><span class="line"><span class="keyword">import</span> &#123;renderToString&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;StaticRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Loadable <span class="keyword">from</span> <span class="string">'react-loadable'</span>;</span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'@/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;renderRoutes, matchRoutes&#125; <span class="keyword">from</span> <span class="string">"react-router-config"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;renderHTML&#125; <span class="keyword">from</span> <span class="string">"./tem"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> route = <span class="keyword">new</span> Router()</span><br><span class="line"></span><br><span class="line">route.get([<span class="string">"/:route?"</span>, /\/<span class="function">(<span class="params">[\w|\d]+</span>)\/.*/], (<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> content = renderToString(</span><br><span class="line">    <span class="comment">// 重点是这</span></span><br><span class="line">    &lt;StaticRouter location=&#123;ctx.path&#125;&gt;</span><br><span class="line">        &#123;renderRoutes(routes.routes)&#125;</span><br><span class="line">    &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  ctx.body = renderHTML(content, &#123;&#125;)</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 这里要注意下中间件的先后顺序</span></span><br><span class="line"><span class="regexp">app.use(require('koa-static')(process.cwd() + '/</span><span class="keyword">static</span><span class="string">'));</span></span><br><span class="line"><span class="string">app.use(route.routes());</span></span><br><span class="line"><span class="string">app.use(route.allowedMethods());</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Loadable.preloadAll().then(() =&gt; &#123;</span></span><br><span class="line"><span class="string">  const server = app.listen('</span><span class="number">9999</span><span class="string">', () =&gt; &#123;</span></span><br><span class="line"><span class="string">    const &#123;port&#125; = server.address();</span></span><br><span class="line"><span class="string">    console.log(`\x1B[33m\x1B[4mhttp://localhost:$&#123;port&#125;\x1B[0m`)</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server/tem.js</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line"><span class="keyword">let</span> project = glob.sync(process.cwd() + <span class="string">'/static/index.*.js'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> path = project[<span class="number">0</span>].split(<span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> renderHTML = <span class="function">(<span class="params">content, store</span>) =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">    &lt;html lang="zh"&gt;</span></span><br><span class="line"><span class="string">      &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset="utf-8"&gt;</span></span><br><span class="line"><span class="string">        &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" /&gt;</span></span><br><span class="line"><span class="string">        &lt;meta name="theme-color" content="#000000"&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;禾口和ssr&lt;/title&gt;</span></span><br><span class="line"><span class="string">      &lt;/head&gt;</span></span><br><span class="line"><span class="string">      &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;div id="root"&gt;<span class="subst">$&#123;content&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;script src=/<span class="subst">$&#123;path[path.length - <span class="number">1</span>]&#125;</span>&gt;&lt;/script&gt; // 这个 '/' 一定要添加，坑了好久</span></span><br><span class="line"><span class="string">      &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS样式问题处理"><a href="#CSS样式问题处理" class="headerlink" title="CSS样式问题处理"></a>CSS样式问题处理</h3><p>正常的服务端渲染只是返回了 HTML 字符串，样式需要浏览器加载完 CSS 后才会加上，这个样式添加的过程就<code>会造成页面的闪动</code>，所以在服务端里面直接添加需要引用的CSS。</p>
<p>我们不能再使用 style-loader 了，因为这个 webpack loader 会在编译时将样式模块载入到 HTML header 中。但是在服务端渲染环境下，没有 window 对象，style-loader 进而会报错。一般我们换用 <code>isomorphic-style-loader</code> ,同时 <code>isomorphic-style-loader</code>也会解决页面样式闪动的问题，它的原理也不难理解：<code>isomorphic-style-loader</code>利用 context API，在渲染页面组件时获取所有 React 组件的样式信息，在服务器端输出 html 字符串的同时，也将样式插入到 html 字符串当中，将结果一同传送到客户端。</p>
<p>因为我们已经开启了cssmodules，所以直接导入到head里面是不会存在样式冲突的问题。<code>isomorphic-style-loader</code>已经给我们提供了一些导入css 的 高阶函数 <code>withsSyles</code></p>
<p>和 hooks <code>useStyles</code>，用的时候比较省事。</p>
<p><strong>看下代码配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/webpack.client.js</span></span><br><span class="line">&#123;</span><br><span class="line">  test: [<span class="regexp">/\.css|less$/</span>],</span><br><span class="line">    use: [</span><br><span class="line">      <span class="string">'style-loader'</span>, <span class="comment">// 也可以跟服务端的一样，就是麻烦点，每次使用css,都需要额外的手续</span></span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          modules: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'less-loader'</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/webpack.server.js</span></span><br><span class="line">&#123;</span><br><span class="line">  test: [<span class="regexp">/\.css|less$/</span>],</span><br><span class="line">    use: [</span><br><span class="line">      <span class="string">'isomorphic-style-loader'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          modules: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'less-loader'</span>  <span class="comment">// 必须配置 不然会当成css,视觉可能看不出来，因为客户端配置了less</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>服务端首页</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server/index.js </span></span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"><span class="keyword">const</span> css = <span class="keyword">new</span> <span class="built_in">Set</span>() <span class="comment">// 这个必须在路由函数里面，在外面的话，就会累加出现之前的css</span></span><br><span class="line"><span class="keyword">const</span> insertCss = <span class="function">(<span class="params">...styles</span>) =&gt;</span> styles.forEach(<span class="function"><span class="params">style</span> =&gt;</span> css.add(style._getCss()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = renderToString(</span><br><span class="line">  &lt;StaticRouter location=&#123;ctx.path&#125;&gt;</span><br><span class="line">        &lt;StyleContext.Provider value=&#123;&#123;insertCss&#125;&#125;&gt; </span><br><span class="line">           &#123;renderRoutes(routes.routes)&#125;</span><br><span class="line">      &lt;<span class="regexp">/StyleContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>StaticRouter&gt;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">ctx.body = renderHTML(content, &#123;&#125;, css)</span><br><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></figure>


<p><strong>客户端也需要配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client/index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;renderRoutes&#125; <span class="keyword">from</span> <span class="string">'react-router-config'</span>;</span><br><span class="line"><span class="keyword">import</span> Loadable <span class="keyword">from</span> <span class="string">'react-loadable'</span>;</span><br><span class="line"><span class="keyword">import</span> StyleContext <span class="keyword">from</span> <span class="string">'isomorphic-style-loader/StyleContext'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'../router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> insertCss = <span class="function">(<span class="params">...styles</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> removeCss = styles.map(<span class="function"><span class="params">style</span> =&gt;</span> style._insertCss &amp;&amp; style._insertCss());</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> removeCss.forEach(<span class="function"><span class="params">dispose</span> =&gt;</span> dispose &amp;&amp; dispose())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">        &#123;renderRoutes(routes.routes)&#125;</span><br><span class="line">    &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Loadable.preloadReady().then(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  ReactDom.hydrate(</span></span><br><span class="line"><span class="regexp">    &lt;StyleContext.Provider value=&#123;&#123;insertCss&#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;App/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/StyleContext.Provider&gt;, document.getElementById('root'));</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure>


<p>这样服务端和客户端都可以直接使用<code>isomorphic-style-loader</code>的一些API, <strong>有些<code>不重要</code>的页面，或者不重要的css可以直接采用客户端渲染</strong>,就不需要引入高阶函数或者useStyles。</p>
<p>在页面内具体使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数式组件</span></span><br><span class="line"><span class="keyword">import</span> useStyles <span class="keyword">from</span> <span class="string">'isomorphic-style-loader/useStyles'</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">"./index.css"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Index = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  useStyles(styles)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类组件使用</span></span><br><span class="line"><span class="keyword">import</span> withStyles <span class="keyword">from</span> <span class="string">'isomorphic-style-loader/withStyles'</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">"./index.css"</span></span><br><span class="line">@withStyles(styles) <span class="comment">// 需要在base里面额外配置</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用客户端渲染</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">"./index.css"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Index = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里也可以使用useStyles 部分使用客户端渲染</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1 className=&#123;styles[<span class="string">'title-center'</span>]&#125;&gt;message&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1 className=&#123;'title-center'&#125;&gt;message&lt;/</span>h1&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>


<p>然后打开网页的源代码就可以看见head里面已经有我们需要的css了。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2020/7/23/1737b44ea25a4b63?w=1251&h=881&f=png&s=177846" alt="image-20200702185101916"></p>
<h3 id="SSR中异步数据的获取-Dva的使用"><a href="#SSR中异步数据的获取-Dva的使用" class="headerlink" title="SSR中异步数据的获取 + Dva的使用"></a>SSR中异步数据的获取 + Dva的使用</h3><h4 id="Dva的使用"><a href="#Dva的使用" class="headerlink" title="Dva的使用"></a>Dva的使用</h4><p>之前项目一直用的dva，这里直接使用的dva-core代替的redux，不会配置的自行查下文档。</p>
<p>创建 <code>Store</code>：这一部分有坑，要注意避免，大家知道，在客户端渲染中，用户的浏览器中永远只存在一个 <code>Store</code>，所以代码上你可以这么写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dvaApp = createApp(&#123;</span><br><span class="line">  initialState: &#123;&#125;,</span><br><span class="line">  models: models,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> store = dvaApp.getStore();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p>然而在服务器端，这么写就有问题了，因为服务器端的 <code>Store</code> 是所有用户都要用的，如果像上面这样构建 <code>Store</code>，<code>Store</code> 变成了一个单例，所有用户共享 <code>Store</code>，显然就有问题了。所以在服务器端渲染中，<code>Store</code> 的创建应该i像下面这样，返回一个函数，每个用户访问的时候，这个函数重新执行，为每个用户提供一个独立的 <code>Store</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dvaApp = createApp(&#123;</span><br><span class="line">  initialState: &#123;&#125;,</span><br><span class="line">  models: models,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getStore =  <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> dvaApp.getStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>别慌，你如果这样的做的话，redux的数据还是所有客户同步公用，因为你的model是一个对象，是静态导入，这个时候你应该把model写成函数的形式，这样后台每次都能获取到最新的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> menuTree = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    namespace: <span class="string">'menuTree'</span>,</span><br><span class="line">    state: &#123;</span><br><span class="line">      routes: []</span><br><span class="line">    &#125;,</span><br><span class="line">    effects: &#123;</span><br><span class="line">      * reset(payload, &#123;call, put, select, update&#125;) &#123;</span><br><span class="line">         <span class="comment">// .........</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    reducers: &#123;</span><br><span class="line">      save(state, &#123;payload&#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;...state, ...payload&#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> menuTree</span><br></pre></td></tr></table></figure>

<p>换成函数的导出形式就OK了，然后在createApp的方法，原有的<code>models.forEach(model =&gt; app.model(model);</code>转换成 <code>models.forEach(model =&gt; app.model(model()));</code> 就OK了。</p>
<h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><p>数据获取的解决方案是配置路由 route-router-config，结合 <code>matchRoutes</code>，找到页面上相关组件所需的请求接口的方法并执行请求，这就要求开发者通过路由配置信息，显式地告知服务端请求内容。</p>
<p><strong>客户端路由改造</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/index.js</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/login'</span>,</span><br><span class="line">  exact: <span class="literal">true</span>,</span><br><span class="line">  component: Login,</span><br><span class="line">  loadData: Login.loadData, <span class="comment">// 这里就是请求数据的方法</span></span><br><span class="line">  title: <span class="string">'登录页'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端组件使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Index.loadData = <span class="keyword">async</span> (store) =&gt; &#123;</span><br><span class="line">  store.dispatch(&#123;</span><br><span class="line">    type: <span class="string">"menuTree/reset"</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我试试这个到底加载不'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index</span><br></pre></td></tr></table></figure>


<p><strong>服务端代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取请求的方法</span></span><br><span class="line"><span class="keyword">const</span> promises = [];</span><br><span class="line"></span><br><span class="line">matchedRoutes.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item.route.loadData) &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这里用了.then 所以组件里面必须使用async或者promise</span></span><br><span class="line">      item.route.loadData(store).then(resolve).catch(reject)</span><br><span class="line">    &#125;)</span><br><span class="line">    promises.push(promise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这里要注意的一个问题，你的方法可能是异步的，会出现 ctx.body 没有执行的问题，所以要把这个中间件设置为异步的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了确保组件的loadData的方法执行完毕</span></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> css = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 防止钩子函数执行两次</span></span><br><span class="line">  <span class="keyword">const</span> insertCss = <span class="function">(<span class="params">...styles</span>) =&gt;</span> styles.forEach(<span class="function"><span class="params">style</span> =&gt;</span> css.add(style._getCss()));</span><br><span class="line">  <span class="keyword">const</span> helmet = Helmet.renderStatic();</span><br><span class="line">  <span class="keyword">const</span> content = renderToString(</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;StaticRouter location=&#123;ctx.path&#125;&gt;</span><br><span class="line">          &lt;StyleContext.Provider value=&#123;&#123;insertCss&#125;&#125;&gt;</span><br><span class="line">            &#123;renderRoutes(routes.routes)&#125;</span><br><span class="line">          &lt;<span class="regexp">/StyleContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>StaticRouter&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">     )</span></span><br><span class="line"><span class="regexp">     ctx.body = renderHTML(content, store, css, helmet)</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure>


<h4 id="注水和脱水"><a href="#注水和脱水" class="headerlink" title="注水和脱水"></a>注水和脱水</h4><p><strong>涉及到数据的预获取，也是服务端渲染的真正意义。</strong></p>
<p>上面的代码正常运行是没问题了，但是发现客户端和服务端的store，存在不同步的问题。</p>
<p>其实也很好理解。当服务端拿到store并获取数据后，客户端的js代码又执行一遍，在客户端代码执行的时候又创建了一个空的store，两个store的数据不能同步。</p>
<p>所以 在服务器端渲染时，首先服务端请求接口拿到数据，并处理准备好数据状态（如果使用 Redux，就是进行 store 的更新），为了减少客户端的请求，我们需要保留住这个状态。一般做法是在服务器端返回 HTML 字符串的时候，将数据 JSON.stringify 一并返回，这个过程，叫做注水；在客户端，就不再需要进行数据的请求了，可以直接使用服务端下发下来的数据，这个过程叫脱水。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="built_in">window</span>.context = &#123;</span><br><span class="line">   <span class="comment">// 这里是注水</span></span><br><span class="line">   state: $&#123;serialize(store.getState())&#125;  <span class="comment">// serialize 是为了防止xss的攻击</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;create&#125; <span class="keyword">from</span> <span class="string">'dva-core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">opt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端的redux</span></span><br><span class="line"><span class="keyword">const</span> dvaApp = createApp(&#123;</span><br><span class="line">  initialState: &#123;&#125;,</span><br><span class="line">  models: models,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getStore = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> dvaApp.getStore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端的redux</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getClientStore = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 需要先拿到服务端的数据, 脱水</span></span><br><span class="line">  <span class="keyword">const</span> initialState = <span class="built_in">window</span>.context ? <span class="built_in">window</span>.context.state : &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> dvaClientApp = createApp(&#123;</span><br><span class="line">    initialState,</span><br><span class="line">    models: models,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dvaClientApp.getStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h4><p>服务端是没有域的存在，所以不会存在跨域的问题，但是在客户端调取接口还存在跨域的问题，所以还需要配置下代理，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> httpProxy <span class="keyword">from</span> <span class="string">'http-proxy-middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> k2c <span class="keyword">from</span> <span class="string">"koa2-connect"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转发代理</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.url.startsWith(<span class="string">'/api'</span>)) &#123; <span class="comment">//匹配有api字段的请求url</span></span><br><span class="line">    ctx.respond = <span class="literal">false</span> <span class="comment">// 绕过koa内置对象response ，写入原始res对象，而不是koa处理过的response</span></span><br><span class="line">    <span class="keyword">await</span> k2c(httpProxy(&#123;</span><br><span class="line">        target: <span class="string">'https://api.xxxxx.xxx'</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        secure: <span class="literal">false</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ))(ctx, next);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>还可以安装koa的代理模块 <code>koa2-proxy-middleware</code>,用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'koa2-proxy-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  targets: &#123;</span><br><span class="line">    <span class="string">'/user'</span>: &#123;</span><br><span class="line">      <span class="comment">// this is option of http-proxy-middleware</span></span><br><span class="line">      target: <span class="string">'http://localhost:3001'</span>, <span class="comment">// target host</span></span><br><span class="line">      changeOrigin: <span class="literal">true</span>, <span class="comment">// needed for virtual hosted sites</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'/user/:id'</span>: &#123;</span><br><span class="line">      target: <span class="string">'http://localhost:3001'</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'/api/*'</span>: &#123;</span><br><span class="line">      target: <span class="string">'http://localhost:3001'</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        <span class="string">'/passager/xx'</span>: <span class="string">'/mPassenger/ee'</span>, <span class="comment">// rewrite path</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">app.use(proxy(options));</span><br></pre></td></tr></table></figure>

<p>源码也没几行，有兴趣可以看下  <a href="https://github.com/sunyongjian/koa2-proxy-middleware/blob/master/lib/index.js" target="_blank" rel="noopener">koa2-proxy-middleware</a></p>
<h3 id="引入react-helmet"><a href="#引入react-helmet" class="headerlink" title="引入react-helmet"></a>引入react-helmet</h3><p>做更完整的SEO</p>
<p>App 组件嵌入到 <code>document.getElementById(&#39;root&#39;)</code> 节点当中，一般是不包含 head 标签的，但是单页应用在切换路由时，可能也会需要动态修改 head 标签信息，比如 title 内容。也就是说：在单页面应用切换页面，不会经过服务端渲染，但是我们仍然需要更改 document 的 title 内容。</p>
<p>如果直接改客户端的title,直接就可以使用<code>document.title</code>,但是我们现在要把SEO做好，然后我们要更改服务端head里面的meta title等内容,这里我们要用到  <a href="https://github.com/nfl/react-helmet" target="_blank" rel="noopener">react-helmet</a>。</p>
<p>具体代码非常简单</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端实现方式</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component, Fragment&#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> &#123;Helmet&#125; <span class="keyword">from</span> <span class="string">"react-helmet"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;Helmet&gt;</span><br><span class="line">          &lt;title&gt;这是login页&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">          &lt;meta name="description" content="这里是禾口和react-ssr的调研"/</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Helmet&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Fragment&gt;</span><br><span class="line">     )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端实现</span></span><br><span class="line"><span class="keyword">import</span> Koa <span class="keyword">from</span> <span class="string">'koa'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"koa-router"</span></span><br><span class="line"><span class="keyword">import</span> &#123;renderToString&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;StaticRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Helmet&#125; <span class="keyword">from</span> <span class="string">'react-helmet'</span>; <span class="comment">// 这里引入</span></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> route = <span class="keyword">new</span> Router()</span><br><span class="line"></span><br><span class="line">route.get([<span class="string">"/:route?"</span>, /\/<span class="function">(<span class="params">[\w|\d]+</span>)\/.*/], (<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">const</span> helmet = Helmet.renderStatic(); <span class="comment">// 这里获取下当前的head信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> content = renderToString(</span><br><span class="line">    &lt;StaticRouter location=&#123;ctx.path&#125;&gt;</span><br><span class="line">      &lt;StyleContext.Provider value=&#123;&#123;insertCss&#125;&#125;&gt;</span><br><span class="line">        &#123;renderRoutes(routes.routes)&#125;</span><br><span class="line">      &lt;<span class="regexp">/StyleContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>StaticRouter&gt;</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  ctx.body = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">      &lt;html lang="zh-Hans-CN"&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;</span></span><br><span class="line"><span class="string">          &lt;meta charset="utf-8"&gt;</span></span><br><span class="line"><span class="string">          <span class="subst">$&#123;helmet.title.toString()&#125;</span></span></span><br><span class="line"><span class="string">          <span class="subst">$&#123;helmet.meta.toString()&#125;</span></span></span><br><span class="line"><span class="string">          &lt;link rel="shortcut icon" href="/favicon.ico"&gt;</span></span><br><span class="line"><span class="string">          &lt;style&gt;<span class="subst">$&#123;[...css].join(<span class="string">''</span>)&#125;</span>&lt;/style&gt;</span></span><br><span class="line"><span class="string">        &lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string">          &lt;div id="root"&gt;<span class="subst">$&#123;content&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;script src=/index.js&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...  ...</span></span><br></pre></td></tr></table></figure>


<h3 id="请求token处理"><a href="#请求token处理" class="headerlink" title="请求token处理"></a>请求token处理</h3><p>客户端登录的时候，把登录的token，放到浏览器的cookie中并且存到redux一份，cookie在服务端可以通过请求的页面直接获取到；所以当用户刷新页面的时候，可以通过页面请求获取到token,然后向redux里面存放一份，这样客户端想要获取token就可以直接在redux里面拿了，loadDate函数可以通过第二个参数传进获取。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hab97bac5556440f787abf0ecde0a0f349.jpg" alt=""></p>
<h3 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h3><p>用<code>react-router-config</code>的<code>matchRoutes</code>方法，当捕获为空数组的时候，说明没有当前路由，跳转到404 页面，这里面有一个注意的点是，如说有二级或二级以上的路由，这个方法能捕获第一个路由的方法，所以要判断当前获取到的是不是一级路由，而且当前数据还不能为空。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server/index.js  </span></span><br><span class="line"><span class="comment">// 判断404</span></span><br><span class="line"><span class="keyword">let</span> hasRoute = matchedRoutes.length === <span class="number">1</span> &amp;&amp; !!matchedRoutes[<span class="number">0</span>].route.routes</span><br><span class="line"><span class="keyword">if</span> (hasRoute || !matchedRoutes.length) &#123;</span><br><span class="line">  ctx.response.redirect(<span class="string">'/404'</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 ‘/’ 重定向是一样的套路</span></span><br></pre></td></tr></table></figure>


<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>安全问题非常关键，尤其是涉及到服务端渲染，开发者要格外小心。这里提出一个点：我们前面提到了注水和脱水过程，其中的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">window</span>.context = &#123;</span><br><span class="line">    initialState: $&#123;<span class="built_in">JSON</span>.stringify(store.getState())&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>非常容易遭受 XSS 攻击，JSON.stringify 可能会造成 script 注入,使用 serialize-javascript 库进行处理，这也是同构应用中最容易被忽视的细节。</p>
<p><strong>另一个规避这种 XSS 风险的做法是</strong>：将数据传递个页面中一个隐藏的 textarea 的 value 中，textarea 的 value 自然就不怕 XSS 风险了。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol>
<li>客户端js拆包，压缩代码</li>
<li>客户端打包的js带有hash后缀</li>
<li>使用copy-webpack-plugin，直接把需要的文件，打包到对应的文件夹。</li>
<li>中间件转发代理 跨域等</li>
<li>静态资源使用cdn</li>
<li>服务端使用缓存</li>
<li>对服务端压力过大的时候，切换到客户端渲染</li>
<li>nodeJs/ReactJs的版本升级</li>
</ol>
<h3 id="遇到的问题汇总"><a href="#遇到的问题汇总" class="headerlink" title="遇到的问题汇总"></a>遇到的问题汇总</h3><ol>
<li><p>二级菜单的时候获取到静态资源的路径，带着第一级菜单的路径</p>
</li>
<li><p>服务端导入css 的时候，css是有做hash 处理不能正确的加载css (cssmodules)</p>
</li>
<li><p>服务端导入css时发生在componentWillMount周期函数，不能在componentDidMount,此时已经到客户端了。</p>
</li>
<li><p>koa的路由不像express那样不能直接使用 ***** ， （可能可以，在我这报错）</p>
</li>
<li><p>中间件的顺序、和异步时 ctx.body=’’ 的问题（如果有异步操作中间件就必须写成 async 函数）</p>
</li>
<li><p>react-helmet 使用时，服务端没有显示设置的title等信息  （在最外层导入）</p>
</li>
<li><p>注水的时候，注意redux客户端和服务端的区别和联系</p>
</li>
<li><p>注水异步加载的问题  promise.all()</p>
</li>
<li><p>客户端路由使用的history,跳转不访问koa的路由</p>
</li>
<li><p>ssr 部署代码体积特别大 ,添加并发，公共单独拆出、使用cdn</p>
</li>
<li><p>pm2环境变量的问题，</p>
</li>
<li><p>开启cssModules后把antd的样式也编译了</p>
</li>
<li><p>添加一个常量数组，用来表示那些必须用来服务端渲染(提高加载速度)，不能太多，影响性能【记得去重】</p>
</li>
<li><p>从别的页面跳转过来的，为什么打开网页源代码有渲染好的html,不应该只有首屏渲染吗？【打开控制台相当于重新渲染了】</p>
</li>
<li><p><a href="https://github.com/hzfvictory/react-ssr/blob/master/src/pages/home/model.js#L27" target="_blank" rel="noopener">服务端获取了数据，客户端怎么判断已经获取了，不再调取接口</a></p>
</li>
<li><p>服务端有了css客户端还需要吗？</p>
<p><strong>答案是需要的。</strong></p>
<p>服务端的css其实就是客户端给的！SSR的渲染只是针对页面的首屏，也就是用户 第一次打开的页面，当从首屏跳转到别的页面的时候，这时候还是需要客户端来渲染的，head的css也是通过js的高阶函数，传进去的，所以当客户端没有了css，服务端一定是没有css的。在react的项目中是没有真正的css的，所谓的css也是通过js来实现动态引入，所以css也是js,包括图片。</p>
</li>
<li><p>ssr怎么进行参数的传输和获取</p>
<ul>
<li><strong>直接使用问号传参</strong></li>
</ul>
<p>客户端path： /a/b?id=1008611<br>然后通过正则或者使用qs获取到id的值</p>
<ul>
<li><strong>地址栏传参</strong></li>
</ul>
<p><strong>方法一</strong></p>
<p>想要传参客户端路由在后台设置下，使它能直接获取到params<br>例如：route.get(‘detail/id:?’()=&gt;{}))<br>最好是把客户端所有要传参url都添加一样的前缀<br>页面A menu/homeDetail/1212<br>页面B menu/aboutDetail/3434</p>
<p>route.get(‘menu/:pageInfo?/:id?’()=&gt;{}))</p>
<p> <strong>方法二</strong><br> 也是我再用的方法，获取到当前的路由path和请求的url,通过正则获取到当前的id也可以直接用<code>path-to-regexp</code></p>
</li>
</ol>
<blockquote>
<p>上面的问题，均已解决，可能文章介绍的不具体，具体以源码为准。</p>
</blockquote>
<p><code>喜欢的mark👍</code> </p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://blog.poetries.top/2018/11/18/react-ssr/?utm_source=tuicool&utm_medium=referral" target="_blank" rel="noopener">从零到一搭建React SSR工程架构</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/66672794" target="_blank" rel="noopener">知乎 rendertron</a></p>
<p><a href="https://github.com/hzfvictory/react-ssr" target="_blank" rel="noopener">本文的github地址</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>React</category>
        <category>React-SSR</category>
      </categories>
  </entry>
  <entry>
    <title>RN基本用法</title>
    <url>/2019/11/17/workspace/Frame/react-native/guide/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>RN基本用法</strong></p>
<p>[[toc]]</p>
<h3 id="React-Native区分安卓-iOS平台"><a href="#React-Native区分安卓-iOS平台" class="headerlink" title="React Native区分安卓/iOS平台"></a>React Native区分安卓/iOS平台</h3><p><a href="https://reactnative.cn/docs/platform-specific-code/" target="_blank" rel="noopener">特定平台代码</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Platform &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(Platform)</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"OS"</span>:<span class="string">"android"</span>,<span class="string">"Version"</span>:<span class="number">25</span>,<span class="string">"is Testing"</span>:<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RN样式"><a href="#RN样式" class="headerlink" title="RN样式"></a>RN样式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;height, width&#125; = Dimensions.get(<span class="string">'window'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> styles = StyleSheet.create(&#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//添加阴影</span><br><span class="line">shadowColor: '0px 6px 10px 0px rgba(0,0,0,0.1)',</span><br><span class="line"><span class="selector-tag">shadowOffset</span>: &#123;<span class="attribute">width</span>: <span class="number">1</span>, height: <span class="number">1</span>&#125;,</span><br><span class="line"><span class="selector-tag">shadowOpacity</span>: 0<span class="selector-class">.1</span>,</span><br><span class="line"></span><br><span class="line">//平移</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-attr">[&#123;translateY: 100&#125;]</span>,</span><br><span class="line"></span><br><span class="line">//边框</span><br><span class="line">borderColor: '#F4F4F4',</span><br><span class="line"><span class="selector-tag">borderWidth</span>: 1,</span><br><span class="line"></span><br><span class="line">//圆角       </span><br><span class="line"><span class="selector-tag">borderTopLeftRadius</span>: 20,</span><br><span class="line"><span class="selector-tag">borderTopRightRadius</span>: 20,</span><br><span class="line"><span class="selector-tag">borderBottomRightRadius</span>: 20,</span><br><span class="line"><span class="selector-tag">borderBottomLeftRadius</span>: 20,</span><br></pre></td></tr></table></figure>

<h3 id="RN带有点击事件的标签"><a href="#RN带有点击事件的标签" class="headerlink" title="RN带有点击事件的标签"></a>RN带有点击事件的标签</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有任何视觉反馈,只支持一个子节点（不能没有子节点也不能多于一个),如果你希望包含多个子组件，可以用一个View来包装它们。</span></span><br><span class="line"> &lt;TouchableWithoutFeedback onPress=&#123;() =&gt; &#123;&#125;&#125;/&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//封装的视图的不透明度会降低,默认为0.2</span></span><br><span class="line">&lt;TouchableOpacity</span><br><span class="line"> style=&#123;styles.button&#125;</span><br><span class="line"> onPress=&#123;()=&gt;&#123;&#125;&#125;</span><br><span class="line"> activeOpacity=&#123;<span class="number">0</span><span class="number">-1</span>,默认<span class="number">0.2</span>&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;Text&gt; Touch Here &lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>TouchableOpacity&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装的视图的不透明度会降低，同时会有一个底层的颜色透过而被用户看到，使得视图变暗或变亮。</span></span><br><span class="line"> &lt;TouchableHighlight</span><br><span class="line">  activeOpacity=&#123;<span class="number">0</span><span class="number">-1</span>,默认为<span class="number">0.85</span>&#125;</span><br><span class="line">  underlayColor=&#123;<span class="string">'#ccc'</span>&#125;</span><br><span class="line">  onPress=&#123;<span class="keyword">this</span>._onPressButton&#125;</span><br><span class="line">  &gt;</span><br><span class="line">  &lt;FastImage</span><br><span class="line">    style=&#123;styles.button&#125;</span><br><span class="line">    source=&#123;<span class="built_in">require</span>(<span class="string">'./myButton.png'</span>)&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;<span class="regexp">/TouchableHighlight&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h3><p><a href="https://reactnative.cn/docs/textinput/" target="_blank" rel="noopener">textinput</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;TextInput</span><br><span class="line">     style=&#123;styles.postTitle&#125;</span><br><span class="line">     autoFocus</span><br><span class="line">     multiline</span><br><span class="line">     underlineColorAndroid=<span class="string">'transparent'</span></span><br><span class="line">     placeholder=<span class="string">'欢迎您的意见和建议…'</span></span><br><span class="line">     placeholderTextColor=<span class="string">'#9B9B9B'</span></span><br><span class="line">     value=&#123;note&#125;</span><br><span class="line">     onChangeText=&#123;setPostTitle&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//居顶显示</span></span><br><span class="line">textAlignVertical: <span class="string">'top'</span></span><br></pre></td></tr></table></figure>

<h3 id="获取盒子的位置信息"><a href="#获取盒子的位置信息" class="headerlink" title="获取盒子的位置信息"></a>获取盒子的位置信息</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> layout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = findNodeHandle(<span class="keyword">this</span>.progressBar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        UIManager.measure(handle, (x, y, width, height, pageX, pageY) =&gt; &#123;</span><br><span class="line">            resolve(&#123;</span><br><span class="line">                x,</span><br><span class="line">                y,</span><br><span class="line">                width,</span><br><span class="line">                height,</span><br><span class="line">                pageX,</span><br><span class="line">                pageY</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&lt;View ref=&#123;(c) =&gt; &#123;</span><br><span class="line">   <span class="keyword">this</span>.progressBar = c</span><br><span class="line">&#125;&#125; onLayout=&#123;<span class="keyword">this</span>.layout&#125; /&gt;</span><br></pre></td></tr></table></figure>


<h3 id="页面通信"><a href="#页面通信" class="headerlink" title="页面通信"></a>页面通信</h3><p><strong>方法一:callback函数刷新</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//接收页面</span></span><br><span class="line">_onPressBack=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.props.navigation.navigate(<span class="string">'list'</span>,&#123;</span><br><span class="line">        refresh:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">         <span class="keyword">this</span>._refresh();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">_refresh=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'refresh'</span>)</span><br><span class="line">    alert(<span class="string">'刷新哈!'</span>)</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&lt;TouchableOpacity onPress=&#123;<span class="keyword">this</span>._onPressBack&#125; activeOpacity=&#123;<span class="number">0.8</span>&#125;&gt;</span><br><span class="line">    &lt;FastImage source=&#123;backIcon&#125; style=&#123;styles.backIcon&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/TouchableOpacity&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/发送页面</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const goBack=()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">     this.props.navigation.goBack();</span></span><br><span class="line"><span class="regexp">     this.props.navigation.state.params.refresh();</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;TouchableOpacity onPress=&#123;goBack&#125; activeOpacity=&#123;0.8&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;FastImage source=&#123;backIcon&#125; style=&#123;styles.backIcon&#125;/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/TouchableOpacity&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>方法二:发送通知DeviceEventEmitter刷新</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收页面</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    View,</span><br><span class="line">    Text,</span><br><span class="line">    FlatList,</span><br><span class="line">    TouchableOpacity,</span><br><span class="line">    DeviceEventEmitter</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.queryList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.refreshSubScription = DeviceEventEmitter.addListener(<span class="string">'refresh'</span>, (&#123;refresh&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="keyword">this</span>.queryList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.refreshSubScription.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送页面</span></span><br><span class="line"><span class="keyword">const</span> goBack=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    DeviceEventEmitter.emit(<span class="string">'refresh'</span>, &#123;</span><br><span class="line">        <span class="string">'refresh'</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    NavigationService.goBack()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;TouchableOpacity onPress=&#123;goBack&#125; activeOpacity=&#123;<span class="number">0.8</span>&#125;&gt;</span><br><span class="line">    &lt;FastImage source=&#123;backIcon&#125; style=&#123;styles.backIcon&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/TouchableOpacity&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="RN插件"><a href="#RN插件" class="headerlink" title="RN插件"></a>RN插件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;TabView&#125; <span class="keyword">from</span> <span class="string">"react-native-tab-view"</span>;    <span class="comment">//tab切换组件</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> LinearGradient <span class="keyword">from</span> <span class="string">'react-native-linear-gradient'</span>    <span class="comment">//渐变色插件</span></span><br><span class="line"></span><br><span class="line">&lt;LinearGradient</span><br><span class="line">  colors=&#123;[<span class="string">'#FE6E50'</span>, <span class="string">'#FF4542'</span>]&#125;</span><br><span class="line">  start=&#123;&#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;&#125;</span><br><span class="line">  end=&#123;&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;Text style=&#123;styles.sure_text&#125;&gt;---&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>LinearGradient&gt;</span><br><span class="line"><span class="string">``</span><span class="string">`             </span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript          </span><br><span class="line"><span class="keyword">import</span> FastImage <span class="keyword">from</span> <span class="string">"react-native-fast-image"</span>;   <span class="comment">//图片的组件</span></span><br><span class="line"></span><br><span class="line">&lt;FastImage source=&#123;本地?本地:&#123;<span class="attr">uri</span>:url&#125;&#125; style=&#123;styles.img&#125;/&gt;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">import</span> DeviceInfo <span class="keyword">from</span> <span class="string">'react-native-device-info'</span>; <span class="comment">//获取设备的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'api版本:'</span>, DeviceInfo.getAPILevel());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'品牌:'</span>, DeviceInfo.getBrand());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'当前应用名称:'</span>, DeviceInfo.getApplicationName());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'应用编译版本号:'</span>, DeviceInfo.getBuildNumber());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'获取应用程序包标识符:'</span>, DeviceInfo.getBundleId());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'运营商名称:'</span>, DeviceInfo.getCarrier());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'设备所处国家:'</span>, DeviceInfo.getDeviceCountry());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'设备ID:'</span>, DeviceInfo.getDeviceId());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'设备地区:'</span>, DeviceInfo.getDeviceLocale());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'设备名称:'</span>, DeviceInfo.getDeviceName());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'获取应用初始安装时间:'</span>, DeviceInfo.getFirstInstallTime());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'设备字体大小:'</span>, DeviceInfo.getFontScale());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'剩余存储容量(字节):'</span>, DeviceInfo.getFreeDiskStorage());</span><br><span class="line">    <span class="keyword">await</span> DeviceInfo.getIPAddress().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'设备当前网络地址IP:'</span>, res);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'应用程序实例ID:'</span>, DeviceInfo.getInstanceID());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'获取应用上次更新时间:'</span>, DeviceInfo.getLastUpdateTime());</span><br><span class="line">    <span class="keyword">await</span> DeviceInfo.getMACAddress().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'网络适配器MAC地址:'</span>, res);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'设备制造商:'</span>, DeviceInfo.getManufacturer());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'获取JVM试图使用的最大内存量(字节):'</span>, DeviceInfo.getMaxMemory());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'获取设备模式:'</span>, DeviceInfo.getModel());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'获取电话号码:'</span>, DeviceInfo.getPhoneNumber());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'获取应用程序可读版本:'</span>, DeviceInfo.getReadableVersion());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'设备唯一序列号:'</span>, DeviceInfo.getSerialNumber());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'获取系统名称:'</span>, DeviceInfo.getSystemName());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'获取系统版本:'</span>, DeviceInfo.getSystemVersion());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'系统时区:'</span>, DeviceInfo.getTimezone());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'完整磁盘空间大小(字节):'</span>, DeviceInfo.getTotalDiskCapacity());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'设备总内存(字节):'</span>, DeviceInfo.getTotalMemory());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'设备唯一ID:'</span>, DeviceInfo.getUniqueID());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'设备用户代理:'</span>, DeviceInfo.getUserAgent());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'设备版本:'</span>, DeviceInfo.getVersion());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'用户偏好是否设置为24小时格式:'</span>, DeviceInfo.is24Hour());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'程序是否允许在模拟器中:'</span>, DeviceInfo.isEmulator());</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">'是否是平板电脑:'</span>, DeviceInfo.isTablet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BoxShadow,BorderShadow&#125; <span class="keyword">from</span> <span class="string">'react-native-shadow'</span>     <span class="comment">//解决安卓阴影</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ProgressBar <span class="keyword">from</span> <span class="string">'react-native-progress/Bar'</span>; <span class="comment">//进度条</span></span><br><span class="line"></span><br><span class="line">&lt;ProgressBar</span><br><span class="line">    color=&#123;<span class="string">'red'</span>&#125;</span><br><span class="line">    animated=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">    width=&#123;width&#125;</span><br><span class="line">    height=&#123;<span class="number">2</span>&#125;</span><br><span class="line">    borderWidth=&#123;<span class="number">0</span>&#125;</span><br><span class="line">    progress=&#123;progress&#125; <span class="comment">//0-1</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NavigationEvents ,NavigationActions , StackActions，withNavigation &#125; <span class="keyword">from</span> <span class="string">'react-navigation'</span>;</span><br><span class="line"></span><br><span class="line">onWillFocus=&#123;payload =&gt; <span class="built_in">console</span>.log(<span class="string">'will focus'</span>)&#125;<span class="comment">//将要被点击</span></span><br><span class="line">onDidFocus=&#123;payload =&gt; <span class="keyword">this</span>.imagePicker() &#125;<span class="comment">//被点击</span></span><br><span class="line">onWillBlur=&#123;payload =&gt; <span class="built_in">console</span>.log(<span class="string">'will blur'</span>, payload)&#125;<span class="comment">//将要离开</span></span><br><span class="line">onDidBlur=&#123;payload =&gt; <span class="built_in">console</span>.log(<span class="string">'did blur'</span>, payload)&#125;<span class="comment">//离开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空所有的路由</span></span><br><span class="line"> <span class="keyword">const</span> resetAction = StackActions.reset(&#123;</span><br><span class="line">   index: <span class="number">1</span>,</span><br><span class="line">    actions: [</span><br><span class="line">        NavigationActions.navigate(&#123;<span class="attr">routeName</span>: <span class="string">"Tab"</span>&#125;),</span><br><span class="line">        NavigationActions.navigate(&#123;<span class="attr">routeName</span>: <span class="string">"LoginPage"</span>&#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br><span class="line">navigation.dispatch(resetAction);</span><br><span class="line"><span class="comment">//navigation在pages声明过得页面才会添加，否则可以用withNavigation(Index)高阶下</span></span><br></pre></td></tr></table></figure>

<h3 id="屏蔽黄屏"><a href="#屏蔽黄屏" class="headerlink" title="屏蔽黄屏"></a>屏蔽黄屏</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; YellowBox&#125; <span class="keyword">from</span> <span class="string">'react-native'</span></span><br><span class="line"></span><br><span class="line">YellowBox.ignoreWarnings([</span><br><span class="line">    <span class="string">'Warning: isMounted(...) is deprecated'</span>,</span><br><span class="line">    <span class="string">'Module RCTImageLoader requires main queue setup'</span>,</span><br><span class="line">    <span class="string">'Module RNFetchBlob requires main queue setup'</span>,</span><br><span class="line">    <span class="string">'Module AudioRecorderManager requires main queue setup'</span>,</span><br><span class="line">    <span class="string">'Module RCTVideoManager requires main queue setup'</span>,</span><br><span class="line">    <span class="string">'Class RCTCxxModule was not exported'</span>,</span><br><span class="line">    <span class="string">'RCTBridge required dispatch_sync to load RCTDevLoadingView.'</span>,</span><br><span class="line">    <span class="string">'Require cycle:'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h3 id="阻止安卓快速双击退出应用"><a href="#阻止安卓快速双击退出应用" class="headerlink" title="阻止安卓快速双击退出应用"></a>阻止安卓快速双击退出应用</h3><p><strong>需求</strong></p>
<ul>
<li>需要监听安卓的返回键，点击安卓返回键的时候可以正常返回</li>
<li>但是当在tabs的几个页面中按返回键做如下的几个处理<ul>
<li>如果在首页tab，那么在连续点击两次返回键后退出应用</li>
<li>在其他tab，按返回键不做处理</li>
</ul>
</li>
</ul>
<p><strong>app.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Platform,</span><br><span class="line">  BackHandler</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (Platform.OS === <span class="string">'android'</span>) &#123;</span><br><span class="line">      BackHandler.addEventListener(<span class="string">'hardwareBackPress'</span>, <span class="keyword">this</span>.onAndroidBackPress);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (Platform.OS === <span class="string">'android'</span>) &#123;</span><br><span class="line">      BackHandler.removeEventListener(<span class="string">'hardwareBackPress'</span>,<span class="keyword">this</span>.onAndroidBackPress);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//BACK物理按键监听</span></span><br><span class="line">  onAndroidBackPress = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(store.dataFixStore.route)</span><br><span class="line">    <span class="keyword">const</span> &#123;route&#125; = store.dataFixStore;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (route != <span class="string">'Home'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//true 表示返回上一页</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.lastBackPressed &amp;&amp; <span class="keyword">this</span>.lastBackPressed + <span class="number">500</span> &gt;= <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">//最近0.5秒内按过back键，可以退出应用。</span></span><br><span class="line">      <span class="keyword">this</span>.lastBackPressed = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Home.jsx</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>  </span><br><span class="line">    &lt;View&gt;</span><br><span class="line">        &lt;NavigationEvents</span><br><span class="line">            onDidFocus=&#123; ()=&gt;&#123;</span><br><span class="line">              <span class="comment">//使用redux把带有tab的页面存起来，如果有对应的就让其回到桌面</span></span><br><span class="line">                 dispatch(&#123;</span><br><span class="line">		            type: <span class="string">"setRouter/changeItem"</span>,</span><br><span class="line">		            payload: &#123;</span><br><span class="line">		                router: <span class="string">'Home'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;);</span><br><span class="line">              &#125;&#125;</span><br><span class="line">            /&gt;    </span><br><span class="line">   &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h3 id="禁止IOS返回手势"><a href="#禁止IOS返回手势" class="headerlink" title="禁止IOS返回手势"></a>禁止IOS返回手势</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//禁止所有页面手势返回</span></span><br><span class="line"><span class="keyword">const</span> RootStackNavigator = StackNavigator(</span><br><span class="line">  &#123;</span><br><span class="line">    Login: &#123;</span><br><span class="line">      screen: LoginScreen</span><br><span class="line">    &#125;,</span><br><span class="line">    Main: &#123;</span><br><span class="line">      screen: MainDrawerNavigator</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    index: <span class="number">0</span>,</span><br><span class="line">    initialRouteName: <span class="string">'Login'</span>,</span><br><span class="line">    headerMode: <span class="string">'none'</span>,</span><br><span class="line">    navigationOptions: &#123;</span><br><span class="line">      gesturesEnabled: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 禁用某个页面的手势</span></span><br><span class="line"><span class="keyword">static</span> navigationOptions = &#123;</span><br><span class="line">     ...</span><br><span class="line">     gesturesEnabled: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>ReactNative</category>
        <category>ReactNative基本用法</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title>XCODE模拟器报错修复</title>
    <url>/2019/11/17/workspace/Frame/react-native/bug/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>XCODE模拟器报错修复</strong></p>
<h1 id="XCODE模拟器报错修复"><a href="#XCODE模拟器报错修复" class="headerlink" title="XCODE模拟器报错修复"></a><code>XCODE模拟器报错修复</code></h1><p><strong>1.MAC上调试工具React-native-debugger下载缓慢及其解决办法。</strong></p>
<p>我们可以下载React-native-debugger,用于RN项目的 调试</p>
<p>我在下载的时候，遇到两个无语的问题</p>
<p>这玩意儿是没有官网的，你只能从github上下载，我这里给一个点击就能直接下载的链接：<a href="https://github.com/jhen0409/react-native-debugger/releases/download/v0.10.0/rn-debugger-macos-x64.zip" target="_blank" rel="noopener">https://github.com/jhen0409/react-native-debugger/releases/download/v0.10.0/rn-debugger-macos-x64.zip</a><br>这个东西大概90M左右，下载慢不说，而且因为网络原因，经常下载到快完成的时候失败！ 加快下载速度的方式如下：<br>打开你的VPN<br>打开上面的链接：<a href="https://github.com/jhen0409/react-native-debugger/releases/download/v0.10.0/rn-debugger-macos-x64.zip，很快就能下好" target="_blank" rel="noopener">https://github.com/jhen0409/react-native-debugger/releases/download/v0.10.0/rn-debugger-macos-x64.zip，很快就能下好</a></p>
<p><strong>2.调试中，可能偶尔就会出现让人非常无语的红屏问题，报（Could not connect to development server）</strong></p>
<p>比如下面的这个不能连接到服务器就是我偶尔或经常遇到的问题，</p>
<p>解决方法：一般刷新几次就好了，如果刷新多次无效，那么重新通过react-native启动项目</p>
<p>（如果IOS模拟器是个人我已经想要打死他了。。。）</p>
<p><strong>3.调试中报错：Missing request token for request</strong></p>
<p>解决方法：反正重启就万完事了。。。不行就再重启</p>
<p><strong>4. 导入新的图片image后，显示红屏（非法字符 Error on load image on React-native: Unexpected character ）</strong></p>
<p>解决方法：1.关闭项目，重新通过命令行启动。 2.如果还不行，那么再重试多次，一般会行的</p>
<p><strong>5.红屏，提示 JSON value ‘XXXX’  of type NSString cannot be converted to  a YGValue. Did you forget the % or pt suffix ?</strong></p>
<p><strong>6.红屏，和上面一样，但提示的文字是“Runtime is not ready for debugging”</strong></p>
<p>这一般是这种情况： 就是你先打开了调试器（React-Native-debugger），然后才启动的项目，项目认为“自己还没有准备好调试”，所以报了这个错误</p>
<p>解决方法</p>
<p>调出控制台菜单（IOS模拟器下通过control + D开启）<br>选择Stop Remote JS Debugging</p>
<p><strong>7.红屏，和上面一样，提示文字: “Unhandled JS Exception:  global.nativeTraceBeginSection is not a function”</strong></p>
<p>这个问题据说不少人遇到过，解决方法是：在模拟器上删掉APP，然后重新编译安装，</p>
<p>它属于“完全的不可抗力”，不是因为你做错了什么，但问题恰恰就这样出现了。。。。。</p>
<p>参考链接 <a href="https://cloud.tencent.com/developer/ask/216506/answer/333025" target="_blank" rel="noopener">https://cloud.tencent.com/developer/ask/216506/answer/333025</a></p>
<p><strong>8. 发现程序有错但是控制台看不到红色错误（error）???</strong></p>
<p>这是因为。。。。。。。报的错误可能不是红色的，而是白色的</p>
<p>下面的这位error老弟，我还是第一次看到长得这么“白白净净” 的Error, 难道你不应该是“红脸关公”🐎 ？</p>
<p>解决办法：认真从一大堆输出中通过过滤掉其他信息的方式，定位到白色色块的error输出</p>
<p><strong>9.调出React-Native-Debugger的时候,报警告：Another debugger is already connected</strong></p>
<p>一般情况下，这是因为你的浏览器页面打开了debugger页面，长这样的</p>
<p>解决办法：把浏览器的debugger关掉就可以了</p>
<p><strong>10.解决MAC和IOS模拟器之间的复制粘贴问题</strong></p>
<p>用过IOS模拟器的人就会发现一个问题，MAC上的东东是不能直接粘贴到模拟器的APP上的</p>
<p>解决办法： <a href="https://www.jianshu.com/p/a34ab4933211" target="_blank" rel="noopener">https://www.jianshu.com/p/a34ab4933211</a></p>
<p><strong>11.如果报错：组件不是class/function,而是undefined</strong></p>
<p>不一定是当前组件没有正确导入，还可能是当前组件的子组件没有正确导入</p>
<p><strong>12.涉及图片引用改变的时候，偶尔会出现热重载失效的现象</strong></p>
<p>你说失效，辣就是失效，不狡辩（证据确凿，百口莫辩）</p>
<p><strong>13.IOS模拟器使用起来非常缓慢，如同乌龟和树獭一般，而且卡顿死机看心情</strong></p>
<p>解决办法：毫无办法，听天由命</p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>ReactNative</category>
        <category>XCODE模拟器报错修复</category>
      </categories>
  </entry>
  <entry>
    <title>RN IOS环境搭建</title>
    <url>/2019/11/17/workspace/Frame/react-native/base/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>RN IOS环境搭建</strong></p>
<p>[[toc]]</p>
<h3 id="iOS-安装CocoaPods"><a href="#iOS-安装CocoaPods" class="headerlink" title="iOS 安装CocoaPods"></a>iOS 安装CocoaPods</h3><p>1、升级Ruby环境</p>
<p>sudo gem update –system</p>
<p>如果失败</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ERROR:  While executing gem ... (Errno::EPERM)</span><br><span class="line">    Operation not permitted @ rb_sysopen - <span class="regexp">/System/</span>Library/Frameworks/Ruby.framework/Versions/<span class="number">2.3</span>/usr/bin/gem</span><br></pre></td></tr></table></figure>
<p>则执行<br>sudo gem install -n /usr/local/bin cocoapods</p>
<p>2、更换Ruby镜像</p>
<p>首先移除现有的Ruby镜像<br/><br>终端输入：gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="noopener">https://rubygems.org/</a></p>
<p>然后添加国内最新镜像源（淘宝的Ruby镜像已经不更新了）<br/><br>终端输入：gem sources -a <a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">https://gems.ruby-china.com/</a></p>
<p>执行完毕之后输入gem sources -l来查看当前镜像<br>终端输入：gem sources -l</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//gems.ruby-china.com</span></span><br></pre></td></tr></table></figure>

<p>3、安装CocoaPods</p>
<p>终端输入：sudo gem install cocoapods</p>
<p>如果出现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">While executing gem ... (Gem::FilePermissionError)</span><br><span class="line">   You don<span class="string">'t have write permissions for the /usr/bin directory.</span></span><br></pre></td></tr></table></figure>

<p>改为 sudo gem install -n /usr/local/bin cocoapods</p>
<p>4.pod切换源</p>
<p>查看源 <br/><br>终端输入： pod repo</p>
<p>执行：<br/><br>git clone <a href="https://git.coding.net/CocoaPods/Specs.git" target="_blank" rel="noopener">https://git.coding.net/CocoaPods/Specs.git</a> ~/.cocoapods/repos/master<br/><br>时间有点久</p>
<p>最后切记要：<br/><br>pod repo update</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">master</span><br><span class="line">- Type: git (master)</span><br><span class="line">- URL:  https:<span class="comment">//git.coding.net/CocoaPods/Specs.git</span></span><br><span class="line">- Path: <span class="regexp">/Users/</span>leiming/.cocoapods/repos/master</span><br></pre></td></tr></table></figure>


<h3 id="fatal-unable-to-access-‘https-chromium-googlesource-com-webm-libwebp-39-解决方法"><a href="#fatal-unable-to-access-‘https-chromium-googlesource-com-webm-libwebp-39-解决方法" class="headerlink" title="fatal: unable to access ‘https://chromium.googlesource.com/webm/libwebp/&#39;解决方法"></a>fatal: unable to access ‘<a href="https://chromium.googlesource.com/webm/libwebp/&#39;解决方法" target="_blank" rel="noopener">https://chromium.googlesource.com/webm/libwebp/&#39;解决方法</a></h3><p>::: danger<br>[!] Error installing libwebp<br>[!] /usr/local/bin/git clone <a href="https://chromium.googlesource.com/webm/libwebp" target="_blank" rel="noopener">https://chromium.googlesource.com/webm/libwebp</a> /var/folders/pw/vctwmfjd5h9cg9dgql17_25m0000gn/T/d20191023-10469-1unjlyk –template= –single-branch –depth 1 –branch v1.0.3</p>
<p>Cloning into ‘/var/folders/pw/vctwmfjd5h9cg9dgql17_25m0000gn/T/d20191023-10469-1unjlyk’…<br>fatal: unable to access ‘<a href="https://chromium.googlesource.com/webm/libwebp/&#39;" target="_blank" rel="noopener">https://chromium.googlesource.com/webm/libwebp/&#39;</a>: Failed to connect to chromium.googlesource.com port 443: Operation timed out<br>:::</p>
<p>主要是clone <a href="https://chromium.googlesource.com/webm/libwebp/" target="_blank" rel="noopener">https://chromium.googlesource.com/webm/libwebp/</a> 这个google的git地址出的错(并且我开的全局模式的代理软件也无效)</p>
<p><strong>解决方法:</strong></p>
<p>Finder -&gt; 前往文件夹 (⇧⌘G) -&gt; ~/.cocoapods/repos/master/Specs/1/9/2/libwebp</p>
<p>选择最新版本   进入 libwebp.podspec.json </p>
<p>把<a href="https://chromium.googlesource.com/webm/libwebp" target="_blank" rel="noopener">https://chromium.googlesource.com/webm/libwebp</a> 替换为 <a href="https://github.com/webmproject/libwebp.git" target="_blank" rel="noopener">https://github.com/webmproject/libwebp.git</a> 并保存</p>
<p>接着pod install</p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>ReactNative</category>
        <category>RN IOS环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title>微前端</title>
    <url>/2020/09/01/workspace/Frame/mic/mic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>微前端</strong></p>
<p>[[toc]]</p>
<p>代码的天敌就是代码量</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://s.pc.qq.com/tousu/img/20200910/1008611_1599722415.jpg" alt=""></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>什么是微前端 ？？</strong></p>
<p>微前端是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将单页面前端应用由单一的单体应用转变为把多个小型前端应用聚合起来的应用。各个前端应用可以使用不同的技术栈独立开发、独立运行、独立部署</p>
<p><strong>微前端架构具备以下几个<code>核心价值：</code></strong></p>
<ul>
<li><p>技术栈无关，接入友好<br>主框架不限制接入应用的技术栈，子应用具备完全自主权</p>
</li>
<li><p>独立开发、独立部署（业务域）<br>子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</p>
</li>
<li><p>增量升级</p>
<p>在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</p>
</li>
<li><p>独立运行时<br>每个子应用之间状态隔离，运行时状态不共享</p>
</li>
</ul>
<p><strong>解决的问题</strong>！！</p>
<p>微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，随之而来的应用不可维护的问题，这类问题在企业级 Web 应用中尤其常见。</p>
<h3 id="Why-Not-Iframe？"><a href="#Why-Not-Iframe？" class="headerlink" title="Why Not Iframe？"></a>Why Not Iframe？</h3><p><a href="https://www.yuque.com/kuitos/gky7yw/gesexv" target="_blank" rel="noopener">https://www.yuque.com/kuitos/gky7yw/gesexv</a></p>
<p>iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。</p>
<ol>
<li>url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。</li>
<li>UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..</li>
<li>全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。</li>
<li>慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。</li>
</ol>
<p>其中有的问题比较好解决(问题1)，有的问题我们可以睁一只眼闭一只眼(问题4)，但有的问题我们则很难解决(问题3)甚至无法解决(问题2)，而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案。</p>
<h3 id="跟-iFrame、Web-Components、NPM包、路由分发、插件有什么区别"><a href="#跟-iFrame、Web-Components、NPM包、路由分发、插件有什么区别" class="headerlink" title="跟 iFrame、Web Components、NPM包、路由分发、插件有什么区别?"></a>跟 iFrame、Web Components、NPM包、路由分发、插件有什么区别?</h3><table>
<thead>
<tr>
<th>微前端</th>
<th align="left"><a href="[https://baike.baidu.com/item/%E5%BE%AE%E4%BB%B6/8626501?fromtitle=Widget&fromid=127396&fr=aladdin](https://baike.baidu.com/item/微件/8626501?fromtitle=Widget&fromid=127396&fr=aladdin)">Widget</a> / 业务组件</th>
</tr>
</thead>
<tbody><tr>
<td>架构体系。用来实现大型Web应用</td>
<td align="left">以库(外联/npm)的形式实现复用</td>
</tr>
<tr>
<td>生产方式</td>
<td align="left">生产工具</td>
</tr>
<tr>
<td><code>通过隔离机制实现技术栈无关</code></td>
<td align="left"><code>需要人工解决依赖和冲突问题</code></td>
</tr>
<tr>
<td>单独构建 \ 单独发布 \ 热升级</td>
<td align="left">整体构建 \ 整体发布</td>
</tr>
<tr>
<td>体系化治理，可控性强</td>
<td align="left">可控性差</td>
</tr>
<tr>
<td>主从关系(路由映射、消息机制)</td>
<td align="left">相互无关</td>
</tr>
<tr>
<td>微应用是产品的子集(粒度大)</td>
<td align="left">通用功能(粒度小)</td>
</tr>
<tr>
<td>变化快</td>
<td align="left">变化小</td>
</tr>
<tr>
<td>若干微应用的组合</td>
<td align="left">“外挂”</td>
</tr>
</tbody></table>
<h3 id="微前端架构实践中的问题"><a href="#微前端架构实践中的问题" class="headerlink" title="微前端架构实践中的问题"></a>微前端架构实践中的问题</h3><ul>
<li><p>SPA VS MPA</p>
<p>MPA 方案的优点在于 部署简单、各应用之间硬隔离，天生具备技术栈无关、独立开发、独立部署的特性。缺点则也很明显，应用之间<strong>切换会造成浏览器重刷</strong>，由于产品域名之间相互跳转，流程体验上会存在断点。</p>
<p>SPA 则天生具备体验上的优势，应用直接无刷新切换，能极大的保证多产品之间流程操作串联时的流程性。缺点则在于各应用技术栈之间是强耦合的。</p>
<p>那我们有没有可能将 MPA 和 SPA 两者的优势结合起来，构建出一个相对完善的微前端架构方案呢？</p>
</li>
<li><p>构建时组合 VS 运行时组合</p>
</li>
<li><p>JS Entry vs HTML Entry</p>
<p>优势就是html-entry 巧妙的避开了js-entry加载子应用js的hash问题</p>
<p>html entry 的好处是子应用依赖的资源不用过于关心</p>
</li>
<li><p>样式隔离</p>
<p>微前端只能做到子应用之间是不会相互干扰的，父应用一般做的很少，就只有左侧菜单个顶部导航栏，很少会有跟子应用之间有样式之间的冲突，如果有的话就把父应用的权重提高就行了。</p>
<ul>
<li><p>Shadow DOM</p>
<p>基于  <a href="https://www.jianshu.com/p/29ff55319003" target="_blank" rel="noopener">Web Components</a> 的 Shadow DOM 能力（内外完全没联系），我们可以将每个子应用包裹到一个 Shadow DOM 中，保证其运行时的样式的绝对隔离。</p>
<p>但 Shadow DOM 方案在工程实践中会碰到一个常见问题，比如我们这样去构建了一个在 Shadow DOM 里渲染的子应用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shadow = <span class="built_in">document</span>.querySelector(<span class="string">'#hostElement'</span>).attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'open'</span>&#125;);</span><br><span class="line">shadow.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;style&gt;</span></span><br><span class="line"><span class="string">    h2&#123;</span></span><br><span class="line"><span class="string">    color:red</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &lt;/style&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Shadow&lt;/h2&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<p>由于子应用的样式作用域仅在 shadow 元素下，那么一旦子应用中出现运行时越界跑到外面构建 DOM 的场景，必定会导致构建出来的 DOM 无法应用子应用的样式的情况。</p>
<p>比如 sub-app 里调用了 antd modal 组件，由于 modal 是动态挂载到 document.body 的，而由于 Shadow DOM 的特性 antd 的样式只会在 shadow 这个作用域下生效，结果就是弹出框无法应用到 antd 的样式。解决的办法是把 antd 样式上浮一层，丢到主文档里，但这么做意味着子应用的样式直接泄露到主文档了。gg…</p>
</li>
<li><p>CSS Module?    BEM?</p>
<p>社区通常的实践是通过约定 css 前缀的方式来避免样式冲突(人肉不推荐)，即各个子应用使用特定的前缀来命名 class，或者直接基于 css module 方案写样式。对于一个全新的项目，这样当然是可行，但是通常微前端架构更多的目标是解决<strong>存量/遗产</strong> 应用的接入问题。<strong>很显然遗产应用通常是很难有动力做大幅改造的</strong>。</p>
<p>最主要的是，约定的方式有一个无法解决的问题，假如子应用中使用了三方的组件库，三方库在写入了大量的<strong>全局样式</strong>的同时又不支持定制化前缀？比如 a 应用引入了 antd 2.x，而 b 应用引入了 antd 3.x，两个版本的 antd 都写入了全局的 <code>.menu class</code>，但又彼此不兼容怎么办？<a href="https://ant.design/components/config-provider-cn/" target="_blank" rel="noopener">antd</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Dynamic Stylesheet</p>
<p><strong>动态  加载/卸载  样式表</strong></p>
<p>解决方案其实很简单，我们只需要在应用切出/卸载后，同时卸载掉其样式表即可，原理是浏览器会对所有的样式表的插入、移除做整个 CSSOM 的重构，从而达到 插入、卸载 样式的目的。这样即能保证，在一个时间点里，只有一个应用的样式表是生效的。</p>
<p>上文提到的 HTML Entry 方案则天生具备样式隔离的特性，因为应用卸载后会直接移除去 HTML 结构，从而自动移除了其样式表。</p>
<p>比如 HTML Entry 模式下，子应用加载完成的后的 DOM 结构可能长这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span> <span class="attr">id</span>=<span class="string">"subApp"</span>&gt;</span></span><br><span class="line">      // 子应用完整的 html 结构</span><br><span class="line">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"//alipay.com/subapp.css"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span>....<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当子应用被替换或卸载时，<code>subApp</code> 节点的 innerHTML 也会被复写，<code>//alipay.com/subapp.css</code> 也就自然被移除样式也随之卸载了。</p>
</li>
</ul>
<ul>
<li><p>JS 隔离</p>
<p>基于proxy</p>
<p>解决了样式隔离的问题后，有一个更关键的问题我们还没有解决：如何确保各个子应用之间的全局变量不会互相干扰，从而保证每个子应用之间的软隔离？</p>
<p>这个问题比样式隔离的问题更棘手，社区的普遍玩法是给一些全局副作用加各种前缀从而避免冲突。但其实我们都明白，这种通过团队间的”口头“约定的方式往往低效且易碎，所有依赖人为约束的方案都很难避免由于人的疏忽导致的线上 bug。那么我们是否有可能打造出一个好用的且完全无约束的 JS 隔离方案呢？</p>
<p>针对 JS 隔离的问题，我们独创了一个运行时的 JS 沙箱。简单画了个架构图：</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://s.pc.qq.com/tousu/img/20200916/1008611_1600242604.jpg" alt=""></p>
<p>即在应用的 bootstrap 及 mount 两个生命周期开始之前分别给全局状态打下快照，然后当应用切出/卸载时，将状态回滚至 bootstrap 开始之前的阶段，确保应用对全局状态的污染全部清零。而当应用二次进入时则再恢复至 mount 前的状态的，从而确保应用在 remount 时拥有跟第一次 mount 时一致的全局上下文。</p>
<p>当然沙箱里做的事情还远不止这些，其他的还包括一些对全局事件监听的劫持等，以确保应用在切出之后，对全局事件的监听能得到完整的卸载，同时也会在 remount 时重新监听这些全局事件，从而模拟出与应用独立运行时一致的沙箱环境。            </p>
</li>
<li><p>资源预加载基座</p>
<p>在浏览器空闲时间预加载（fetch  跨域）未打开的子应用资源，加速子应用打开速度。</p>
</li>
</ul>
<h3 id="子应用的划分"><a href="#子应用的划分" class="headerlink" title="子应用的划分"></a>子应用的划分</h3><p>在微前端架构中，我们应该按业务划分出对应的子应用，而不是通过功能模块划分子应用。这么做的原因有两个：</p>
<ol>
<li>在微前端架构中，子应用并不是一个模块，而是一个独立的应用，我们将子应用按业务划分可以拥有更好的可维护性和解耦性。</li>
<li><code>**</code> 子应用应该具备独立运行的能力，防止应用间频繁的通信(减少耦合)</li>
</ol>
<h3 id="接入qiankun"><a href="#接入qiankun" class="headerlink" title="接入qiankun"></a>接入qiankun</h3><h4 id="构建主应用基座"><a href="#构建主应用基座" class="headerlink" title="构建主应用基座"></a>构建主应用基座</h4><p>这里用vue作为主应用，接入其他的子应用</p>
<p>乾坤提供的<a href="https://qiankun.umijs.org/zh/api/" target="_blank" rel="noopener">API</a>,一共没几个，接入方式特别简单。</p>
<p>子应用注册信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-vue-main/src/micro/app.js</span></span><br><span class="line"><span class="comment">// https://github.com/hzfvictory/mic/blob/master/micro-app-vue-main/src/micro/apps.js#L20-L26</span></span><br><span class="line"><span class="keyword">const</span> isProduction = process.env.NODE_ENV === <span class="string">'production'</span>;</span><br><span class="line"><span class="keyword">const</span> isEnter = isProduction ? <span class="string">'120.79.229.197'</span> : <span class="string">'localhost'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genActiveRule</span>(<span class="params">routerPrefix</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回 true 就激活了子应用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">location</span> =&gt;</span> location.pathname.startsWith(routerPrefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apps = [</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * name: 微应用名称 - 具有唯一性</span></span><br><span class="line"><span class="comment">   * entry: 微应用入口 - 通过该地址加载微应用</span></span><br><span class="line"><span class="comment">   * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上</span></span><br><span class="line"><span class="comment">   * activeRule: 浏览器url发生变化会调用这个函数，activeRule 返回 true 时表明该子应用需要被激活。</span></span><br><span class="line"><span class="comment">   * props 向子组件传递信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"ReactMicroApp"</span>,</span><br><span class="line">    entry: <span class="string">`//<span class="subst">$&#123;isEnter&#125;</span>:10100`</span>,</span><br><span class="line">    container: <span class="string">"#wrapper"</span>,</span><br><span class="line">    activeRule: genActiveRule(<span class="string">"/menu/react"</span>),</span><br><span class="line">    props: &#123;<span class="attr">data</span>:[]&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> apps;</span><br></pre></td></tr></table></figure>



<p>介入乾坤声明周期，错误捕获，导出启动函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-vue-main/src/micro/index.js</span></span><br><span class="line"><span class="comment">// https://github.com/hzfvictory/mic/blob/master/micro-app-vue-main/src/micro/index.js#L27</span></span><br><span class="line"><span class="keyword">import</span> &#123;Notification&#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进度条插件*/</span></span><br><span class="line"><span class="keyword">import</span> NProgress <span class="keyword">from</span> <span class="string">"nprogress"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"nprogress/nprogress.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  registerMicroApps,</span><br><span class="line">  addGlobalUncaughtErrorHandler,</span><br><span class="line">  start,</span><br><span class="line">  removeGlobalUncaughtErrorHandler</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"qiankun"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子应用注册信息*/</span></span><br><span class="line"><span class="keyword">import</span> apps <span class="keyword">from</span> <span class="string">"./apps"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * registerMicroApps</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;array&#125;</span> <span class="variable">apps</span></span> - 必选，子应用的一些注册信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;function&#125;</span> <span class="variable">lifeCycles</span></span> - 可选，全局的子应用生命周期钩子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;object&#125;</span> <span class="variable">opts</span></span> - 可选</span></span><br><span class="line"><span class="comment"> *            fetch - Function - 可选</span></span><br><span class="line"><span class="comment"> *            getPublicPath - (url: string) =&gt; string - 可选</span></span><br><span class="line"><span class="comment"> *            getTemplate - (tpl: string) =&gt; string - 可选</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">registerMicroApps(apps, &#123;</span><br><span class="line">  <span class="comment">/*qiankun 生命周期钩子 - 加载前*/</span></span><br><span class="line">  beforeLoad: <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 加载子应用前，加载进度条</span></span><br><span class="line">    NProgress.start();</span><br><span class="line">    NProgress.set(<span class="number">0.4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`%c挂载前 <span class="subst">$&#123;app.name&#125;</span>`</span>, <span class="string">`color:rgb(255, 208, 75);font-size:18px;`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/*qiankun 生命周期钩子 - 挂载后*/</span></span><br><span class="line">  afterMount: <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 加载子应用前，进度条加载完成</span></span><br><span class="line">    NProgress.done();</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`%c挂载后 <span class="subst">$&#123;app.name&#125;</span>`</span>, <span class="string">`color:rgb(255, 208, 75);font-size:18px`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加全局的未捕获异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addGlobalUncaughtErrorHandler(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(event);</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">message</span>: msg&#125; = event;</span><br><span class="line">  <span class="comment">/*加载失败时提示*/</span></span><br><span class="line">  <span class="keyword">if</span> (msg &amp;&amp; msg.includes(<span class="string">"died in status LOADING_SOURCE_CODE"</span>)) &#123;</span><br><span class="line">    Notification(&#123;</span><br><span class="line">      title: <span class="string">'加载失败'</span>,</span><br><span class="line">      message: <span class="string">'子应用加载失败，请检查应用是否可运行'</span>,</span><br><span class="line">      type: <span class="string">'error'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">removeGlobalUncaughtErrorHandler(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'移除未捕获的错误'</span>, err);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*导出 qiankun 的启动函数*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> start;</span><br></pre></td></tr></table></figure>

<p>然后在mainJs里面启动该函数主应用的任务就完成了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-vue-main/src/main.js</span></span><br><span class="line"><span class="comment">// https://github.com/hzfvictory/mic/blob/master/micro-app-vue-main/src/main.js#L47</span></span><br><span class="line"><span class="keyword">import</span> startQiankun <span class="keyword">from</span> <span class="string">"./micro"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* prefetch  预渲染</span></span><br><span class="line"><span class="comment">* singular  是否为 单实例 场景</span></span><br><span class="line"><span class="comment">* jsSandbox 是否开启沙箱  关闭后兼容IE（但要承担关掉沙箱后子应用之间可能造成冲突的风险）</span></span><br><span class="line"><span class="comment">* fetch     自定义的fetch方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line">startQiankun(&#123;<span class="attr">singular</span>: <span class="literal">true</span>, <span class="attr">prefetch</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>到这一步，我们的主应用基座就创建好啦！</p>
<h4 id="接入子应用"><a href="#接入子应用" class="headerlink" title="接入子应用"></a>接入子应用</h4><p>首先，我们在 <code>React</code> 的入口文件 <code>index.js</code> 中，导出 <code>qiankun</code> 主应用所需要的三个生命周期钩子函数，代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-react/src/index.jsx</span></span><br><span class="line"><span class="comment">// https://github.com/hzfvictory/mic/blob/master/micro-app-react/src/index.js#L46</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ConfigProvider&#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> zhCN <span class="keyword">from</span> <span class="string">'antd/es/locale/zh_CN'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'moment/locale/zh-cn'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 渲染函数</span></span><br><span class="line"><span class="comment"> * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;ConfigProvider</span><br><span class="line">      autoInsertSpaceInButton=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">      locale=&#123;zhCN&#125;&gt;</span><br><span class="line">      &lt;App/&gt;</span><br><span class="line">    &lt;<span class="regexp">/ConfigProvider&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 独立运行时，直接挂载应用</span></span><br><span class="line"><span class="regexp">if (!window.__POWERED_BY_QIANKUN__) &#123;</span></span><br><span class="line"><span class="regexp">  render();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。</span><br><span class="line"> * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">export async function bootstrap() &#123;</span></span><br><span class="line"><span class="regexp">  console.log("ReactMicroApp bootstraped");</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法</span><br><span class="line"> * props 是注册的时候传进来的</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">export async function mount(props) &#123;</span></span><br><span class="line"><span class="regexp">  console.log("ReactMicroApp mount", props);</span></span><br><span class="line"><span class="regexp">  render(props);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">export async function unmount() &#123;</span></span><br><span class="line"><span class="regexp">  console.log("销毁");</span></span><br><span class="line"><span class="regexp">  ReactDOM.unmountComponentAtNode(document.getElementById("root"));</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在配置好了入口文件 <code>index.js</code> 后，我们还需要配置路由命名空间，以确保主应用可以正确加载微应用，代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-react/src/app.jsx</span></span><br><span class="line"><span class="comment">// https://github.com/hzfvictory/mic/blob/master/micro-app-react/src/App.js#L11</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="keyword">const</span> BASE_NAME = <span class="built_in">window</span>.__POWERED_BY_QIANKUN__ ? <span class="string">"/menu/react"</span> : <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;Router basename=&#123;BASE_NAME&#125;&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &#123;renderRoutes(routes.routes)&#125;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Router&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>



<p>接下来要配置webpack</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> packageName = <span class="built_in">require</span>(<span class="string">'./package.json'</span>).name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  webpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// https://webpack.js.org/configuration/output/#outputlibrary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微应用的包名，这里与主应用中注册的微应用名称一致</span></span><br><span class="line">    config.output.library = <span class="string">`<span class="subst">$&#123;packageName&#125;</span>App`</span>;</span><br><span class="line">    <span class="comment">// 将你的 library 暴露为所有的模块定义下都可运行的方式</span></span><br><span class="line">    <span class="comment">// https://zhuanlan.zhihu.com/p/71168066</span></span><br><span class="line">    config.output.libraryTarget = <span class="string">"umd"</span>;</span><br><span class="line">    <span class="comment">// 按需加载相关，设置为 webpackJsonp_VueMicroApp 即可</span></span><br><span class="line">    config.output.jsonpFunction = <span class="string">`webpackJsonp_<span class="subst">$&#123;packageName&#125;</span>App`</span></span><br><span class="line"></span><br><span class="line">    config.resolve.alias = &#123;</span><br><span class="line">      ...config.resolve.alias,</span><br><span class="line">      <span class="string">"@"</span>: path.resolve(__dirname, <span class="string">"src"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: <span class="function"><span class="keyword">function</span> (<span class="params">configFunction</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">proxy, allowedHost</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> config = configFunction(proxy, allowedHost);</span><br><span class="line">      <span class="comment">// 关闭主机检查，使微应用可以被 fetch</span></span><br><span class="line">      config.disableHostCheck = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 配置跨域请求头，解决开发环境的跨域问题</span></span><br><span class="line">      config.headers = &#123;</span><br><span class="line">        <span class="string">"Access-Control-Allow-Origin"</span>: <span class="string">"*"</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 配置 history 模式</span></span><br><span class="line">      config.historyApiFallback = <span class="literal">true</span>;</span><br><span class="line">      config.hot = <span class="literal">true</span>;</span><br><span class="line">      config.open = <span class="literal">false</span>;  <span class="comment">// 子应用设置false</span></span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们需要重点关注一下 <code>output</code> 选项，当我们把 <code>libraryTarget</code> 设置为 <code>umd</code> 后，我们的 <code>library</code> 就暴露为所有的模块定义下都可运行的方式了，主应用就可以获取到微应用的生命周期钩子函数了。</p>
<p>到这里，<code>React</code> 微应用就接入成功了！其他的技术栈接入方式大同小异，不在一一列举，具体看下方github。</p>
<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p><strong>示例：子应用跳转到另一个子应用（通过主应用做媒介）</strong></p>
<h4 id="基于浏览器原生事件做通信"><a href="#基于浏览器原生事件做通信" class="headerlink" title="基于浏览器原生事件做通信"></a>基于浏览器原生事件做通信</h4><p><a href="http://blog.jing999.cn/2020/08/28/workspace/Js/dispatchEvent/" target="_blank" rel="noopener">CustomEvent API 详情</a></p>
<p><strong>父应用</strong></p>
<p>首先，我们在主应用中初始化CustomEvent，挂载到window上，然后添加我们要传递的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-vue-main/src/app.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   mounted() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">createEvent</span>(<span class="params">params, eventName = <span class="string">'emit'</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 数据必须挂载到detail上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomEvent(eventName, &#123;<span class="attr">detail</span>: params&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 初始化</span></span><br><span class="line">      <span class="built_in">window</span>.cEvt = createEvent(&#123;<span class="attr">handelData</span>: <span class="keyword">this</span>.handelData, <span class="attr">jumpUrl</span>: <span class="keyword">this</span>.jumpUrl&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handelData(...opt) &#123;</span><br><span class="line">        <span class="comment">// 为了避免重新渲染 obj 可以放到外面声明</span></span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="built_in">Object</span>.assign(<span class="keyword">this</span>.obj, ...opt);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.obj</span><br><span class="line">      &#125;,</span><br><span class="line">      jumpUrl(url)&#123;</span><br><span class="line">        <span class="comment">// 跳转</span></span><br><span class="line">        <span class="keyword">this</span>.$router.history.push(url)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子应用</strong></p>
<p>然后子应用在函数中添加事件监听，执行跳转操作触发事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-react/src/pages/detail/index.jsx</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Fragment, useEffect, useRef&#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Index = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> msgRef = useRef(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'emit'</span>, queryData);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 移除事件监听器</span></span><br><span class="line">      <span class="built_in">document</span>.removeEventListener(<span class="string">'emit'</span>, queryData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">const</span> queryData = <span class="function">(<span class="params">&#123;detail: &#123;handelData, jumpUrl&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(handelData(&#123;<span class="attr">msg</span>: msgRef.current&#125;));</span><br><span class="line">    jumpUrl(<span class="string">'/menu/vue/list'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> dispatchData = <span class="function">(<span class="params">msg</span>) =&gt;</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    msgRef.current = msg</span><br><span class="line">    <span class="comment">/* 触发自定义事件 通信*/</span></span><br><span class="line">    <span class="built_in">document</span>.dispatchEvent(<span class="built_in">window</span>.cEvt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">       &lt;h2 onClick=&#123;dispatchData(<span class="string">'hzf'</span>)&#125;&gt;跳转&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Fragment&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index</span><br></pre></td></tr></table></figure>

<p><strong>别忘了移除事件监听器</strong></p>
<p>为了防止子应用独立运行的时候报错需要在子应用加载的时候加上错误提示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-react/src/index.jsx</span></span><br><span class="line"><span class="comment">// 独立运行时，直接挂载应用</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createEvent</span>(<span class="params">params, eventName = <span class="string">'emit'</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomEvent(eventName, &#123;<span class="attr">detail</span>: params&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.cEvt = createEvent(&#123;</span><br><span class="line">    handelData: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'不能运行'</span>),</span><br><span class="line">    jumpUrl: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'不能运行'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种优势就是纯原生方便包装，使用简单，适合简单的通信。</p>
<h4 id="基于qiankun提供的API"><a href="#基于qiankun提供的API" class="headerlink" title="基于qiankun提供的API"></a>基于qiankun提供的API</h4><p><code>qiankun</code> 内部提供了 <code>initGlobalState</code> 方法用于注册 <code>MicroAppStateActions</code> 实例用于通信，该实例有三个方法，分别是：</p>
<ul>
<li><code>setGlobalState</code>：设置 <code>globalState</code> - 设置新的值时，内部将执行 <code>浅检查</code>，如果检查到 <code>globalState</code> 发生改变则触发通知，通知到所有的 <code>观察者</code> 函数。</li>
<li><code>onGlobalStateChange</code>：注册 <code>观察者</code> 函数 - 响应 <code>globalState</code> 变化，在 <code>globalState</code> 发生改变时触发该 <code>观察者</code> 函数。</li>
<li><code>offGlobalStateChange</code>：取消 <code>观察者</code> 函数 - 该实例不再响应 <code>globalState</code> 变化</li>
</ul>
<p><strong>主应用</strong></p>
<p>首先，我们在主应用中注册一个 <code>MicroAppStateActions</code> 实例并导出，代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-vue-main/src/shared/actions.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;initGlobalState&#125; <span class="keyword">from</span> <span class="string">"qiankun"</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'@/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  jumpUrl: <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">    router.history.push(url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> actions = initGlobalState(initialState);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> actions;</span><br></pre></td></tr></table></figure>

<p>在注册 <code>MicroAppStateActions</code> 实例后，我们在需要通信的组件中使用该实例，并注册 <code>观察者</code> 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-vue-main/src/app.vue</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">"@/shared/actions"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   mounted() &#123;</span><br><span class="line">     actions.onGlobalStateChange(<span class="function">(<span class="params">state, prevState</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// state: 变更后的状态; prevState: 变更前的状态</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"主应用观察者：改变前的 "</span>, prevState);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"主应用观察者：改变后的 "</span>, state);</span><br><span class="line">      &#125;, </span><br><span class="line">     <span class="comment">// 第二个参数表示立即执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子应用</strong></p>
<p>我们首先来改造我们的 <code>Vue</code> 子应用，首先我们设置一个 <code>Actions</code> 实例，代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-vue-main/src/shared/actions.js</span></span><br><span class="line"><span class="keyword">const</span> emptyAction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">"当前执行的actions为空!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actions</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 默认值为空 Action</span></span><br><span class="line">  actions = &#123;</span><br><span class="line">    onGlobalStateChange: emptyAction,</span><br><span class="line">    setGlobalState: emptyAction</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 设置 actions</span></span><br><span class="line">  setActions(actions) &#123;</span><br><span class="line">    <span class="keyword">this</span>.actions = actions;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 映射</span></span><br><span class="line">  onGlobalStateChange(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.actions.onGlobalStateChange(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 映射</span></span><br><span class="line">  setGlobalState(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.actions.setGlobalState(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = <span class="keyword">new</span> Actions();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> actions;</span><br></pre></td></tr></table></figure>

<p>我们创建 <code>actions</code> 实例后，我们需要为其注入真实 <code>Actions</code>。我们在入口文件 <code>main.js</code> 的 <code>render</code> 函数中注入，代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-vue-main/src/main.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">props</span>) </span>&#123; <span class="comment">// mount方法传递进来的</span></span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 注入 actions 实例</span></span><br><span class="line">    actions.setActions(props);</span><br><span class="line">  &#125;</span><br><span class="line">  router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">// 运行在主应用中时，添加路由命名空间 /vue</span></span><br><span class="line">    base: <span class="built_in">window</span>.__POWERED_BY_QIANKUN__ ? <span class="string">"/menu/vue"</span> : <span class="string">"/"</span>,</span><br><span class="line">    mode: <span class="string">"history"</span>,</span><br><span class="line">    routes,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解决ElementUI导航栏中的vue-router在3.0版本以上重复点菜单报错问题</span></span><br><span class="line">  <span class="keyword">const</span> originalPush = VueRouter.prototype.push</span><br><span class="line">  VueRouter.prototype.push = <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> originalPush.call(<span class="keyword">this</span>, location).catch(<span class="function"><span class="params">err</span> =&gt;</span> err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 挂载应用</span></span><br><span class="line">  instance = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">  &#125;).$mount(<span class="string">"#app"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在列表页引入当前的actions，执行跳转的方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /mic/micro-app-vue/src/shared/actions.js</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">"@/shared/actions"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        jumpUrl: <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    inject: [<span class="string">"reload"</span>],</span><br><span class="line">    created() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$nextTick(<span class="keyword">this</span>.queryList);</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      actions.onGlobalStateChange(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.jumpUrl = state.jumpUrl</span><br><span class="line">      &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      jumpReactDetail(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.jumpUrl(<span class="string">`/menu/react/detail/<span class="subst">$&#123;options.id&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这种的优势就是轻量，官方自带，适合业务划分清晰，比较简单的微前端应用</p>
<h4 id="基于redux"><a href="#基于redux" class="headerlink" title="基于redux"></a>基于redux</h4><p><strong>父应用</strong></p>
<p>首先我们需要在主应用中创建 <code>store</code> 用于管理全局状态池</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-vue-main/src/shared/store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'@/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  jumpUrl: <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">    router.history.push(url)</span><br><span class="line">  &#125;,</span><br><span class="line">  detail: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个reducer用combineReducers合并</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"SET_DETAIL"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        detail: action.payload</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>



<p>然后，我们需要将 <code>store</code> 实例通过 <code>props</code> 传递给子应用，代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-vue-main/src/micro/app.js</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">"@/shared/store"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apps = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"ReactMicroApp"</span>,</span><br><span class="line">    entry: <span class="string">`//<span class="subst">$&#123;isEnter&#125;</span>:10100`</span>,</span><br><span class="line">    container: <span class="string">"#wrapper"</span>,</span><br><span class="line">    activeRule: genActiveRule(<span class="string">"/menu/react"</span>),</span><br><span class="line">    <span class="comment">// 通过 props 将 shared 传递给子应用</span></span><br><span class="line">    props: &#123;store&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"VueMicroApp"</span>,</span><br><span class="line">    entry: <span class="string">`//<span class="subst">$&#123;isEnter&#125;</span>:10200`</span>,</span><br><span class="line">    container: <span class="string">"#wrapper"</span>,</span><br><span class="line">    activeRule: genActiveRule(<span class="string">"/menu/vue"</span>),</span><br><span class="line">    props: &#123;store&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> apps;</span><br></pre></td></tr></table></figure>



<p><strong>子应用</strong></p>
<p>子应用一般会有自己的状态管理，主应用通信的也不多，所以直接简单处理提示下就行了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-react/src/shared/store.js</span></span><br><span class="line"><span class="keyword">const</span> emptyRedux = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">"当前执行的redux不存在!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  actions = &#123;</span><br><span class="line">    dispatch: emptyRedux,</span><br><span class="line">    getState: emptyRedux,</span><br><span class="line">    replaceReducer: emptyRedux,</span><br><span class="line">    subscribe: emptyRedux</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 重载</span></span><br><span class="line">  setStore(actions) &#123;</span><br><span class="line">    <span class="keyword">this</span>.actions = actions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispatch(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.actions.dispatch(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getState() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.actions.getState() || &#123;</span><br><span class="line">      jumpUrl: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125; <span class="comment">// 这里redux传进来的方法，不然子应用单独打开运行会报错</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  replaceReducer(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.actions.replaceReducer(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  subscribe(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.actions.subscribe(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Store();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>



<p>然后在入口文件处注入<code>store</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-react/src/pages/app.jsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (props &amp;&amp; props.store) &#123;</span><br><span class="line">    <span class="comment">// 注入redux 实例</span></span><br><span class="line">    store.setStore(props.store)</span><br><span class="line">  &#125;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">      &lt;App/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在项目中就可以直接引入使用了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mic/micro-app-react/src/pages/detail/index.jsx</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Fragment, useEffect&#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">"@/shared/store"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Index = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 返回值是取消订阅</span></span><br><span class="line">    <span class="keyword">const</span> unSubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 注册订阅函数</span></span><br><span class="line">      <span class="built_in">console</span>.log(store.getState(), <span class="string">'订阅方法'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      unSubscribe()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,[])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> dispatchRedux = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    store.dispatch(&#123;</span><br><span class="line">      type: <span class="string">'SET_DETAIL'</span>,</span><br><span class="line">      payload: &#123;<span class="attr">data</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="attr">kkk</span>: <span class="number">121</span>&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> jumpUrl = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    store.getState().jumpUrl(<span class="string">'/menu/vue/table-detail'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">       &lt;h2 onClick=&#123;jumpUrl&#125;&gt;跳转&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">			 &lt;h2 onClick=&#123;dispatchRedux&#125;&gt;修改&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Index</span></span><br></pre></td></tr></table></figure>

<p>这种的优势就是避免状态随意污染，而且redux提供状态跟踪的插件，适合较为复杂的微前端应用。</p>
<h3 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h3><p>由于 qiankun 是通过 fetch 去获取子应用的引入的静态资源的，所以必须要求这些静态资源支持跨域</p>
<p>如果是自己的脚本，可以通过开发服务端跨域来支持。如果是三方脚本且无法为其添加跨域头，可以将脚本拖到本地，由自己的服务器 serve 来支持跨域。</p>
<p><strong>子应用nginx处添加  Access-Control-Allow-Origin，如果不想设置 ‘*’，也可以指定对多个ip开放中间逗号隔开就好。</strong></p>
<p><strong>需要注意的一个有关CORS的点：</strong></p>
<blockquote>
<p>对于附带身份凭证的请求(即服务器设置<strong>Access-Control-Allow-Credentials: true</strong>)，服务器不得设置 Access-Control-Allow-Origin 的值为“*”，则请求将会失败。</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">10200</span>; <span class="comment"># 监听端口</span></span><br><span class="line">        <span class="attribute">server_name</span> <span class="number">120.79.229.197</span> ; <span class="comment"># 请求到达的服务器名</span></span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.php default.html default.htm default.php;</span><br><span class="line">        <span class="attribute">root</span> /home/wwwroot/mic200.jing999.cn/dist; <span class="comment"># 指定运行路径</span></span><br><span class="line">  </span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html; <span class="comment"># 重定向</span></span><br><span class="line"></span><br><span class="line">            <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">              <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;</span><br><span class="line">              <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>;</span><br><span class="line">              <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Headers'</span></span><br><span class="line">              <span class="string">'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'</span>;</span><br><span class="line">              <span class="attribute">add_header</span> <span class="string">'Access-Control-Max-Age'</span> <span class="number">1728000</span>;</span><br><span class="line">              <span class="attribute">add_header</span> <span class="string">'Content-Type'</span> <span class="string">'text/plain charset=UTF-8'</span>;</span><br><span class="line">              <span class="attribute">add_header</span> <span class="string">'Content-Length'</span> <span class="number">0</span>;</span><br><span class="line">              <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">'POST'</span>) &#123;</span><br><span class="line">              <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;</span><br><span class="line">              <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>;</span><br><span class="line">              <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Headers'</span></span><br><span class="line">              <span class="string">'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">'GET'</span>) &#123;</span><br><span class="line">              <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;</span><br><span class="line">              <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>;</span><br><span class="line">              <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Headers'</span></span><br><span class="line">              <span class="string">'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">include</span> rewrite/none.conf;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">include</span> enable-php.conf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span></span><br><span class="line"><span class="regexp"></span>        &#123;</span><br><span class="line">            <span class="comment"># 静态图片 允许跨域请求</span></span><br><span class="line">            <span class="attribute">add_header</span> Access-Control-Allow-Origin <span class="string">'*'</span>;</span><br><span class="line">            <span class="attribute">add_header</span> Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">            <span class="attribute">add_header</span> Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(js|css)?$</span></span><br><span class="line"><span class="regexp"></span>        &#123;</span><br><span class="line">            <span class="comment"># 允许跨域请求</span></span><br><span class="line">            <span class="attribute">add_header</span> Access-Control-Allow-Origin <span class="string">'*'</span>;</span><br><span class="line">            <span class="attribute">add_header</span> Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">            <span class="attribute">add_header</span> Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">12h</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ /.well-known</span> &#123;</span><br><span class="line">       		<span class="attribute">allow</span> all;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ /\.</span></span><br><span class="line"><span class="regexp"></span>        &#123;</span><br><span class="line">       		 <span class="attribute">eny</span> all;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       	<span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p>版本管理、监控方案（埋点） 、 回滚方案</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://zhuanlan.zhihu.com/p/78362028" target="_blank" rel="noopener">蚂蚁 有知(乾坤)  沙盒内容</a></p>
<p><a href="https://juejin.im/post/6844904158085021704?utm_source=gold_browser_extension" target="_blank" rel="noopener">基于 qiankun 的微前端最佳实践（万字长文） - 从 0 到 1 篇</a></p>
<p><a href="https://github.com/a1029563229/micro-front-template/tree/feature-inject-sub-apps" target="_blank" rel="noopener">微前端架构模板</a></p>
<p><a href="https://github.com/single-spa/single-spa" target="_blank" rel="noopener">微服务的JavaScript框架 single-spa</a></p>
<p><a href="https://qiankun.umijs.org/zh" target="_blank" rel="noopener">乾坤文档</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/141576317" target="_blank" rel="noopener">一些关于微前端的文章</a></p>
<p><a href="https://xiaomi-info.github.io/2020/04/14/fe-microfrontends-practice/" target="_blank" rel="noopener">微前端在小米 CRM 系统的实践</a></p>
<p><a href="https://v.youku.com/v_show/id_XNDUwNTc0MTUwNA==.html?spm=a2hbt.13141534.app.5~5!2~5!2~5~5~5!2~5~5!2~5!2~5!2~5~5!19~A" target="_blank" rel="noopener">d2峰会 微前端视频有三篇</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>微前端</category>
      </categories>
  </entry>
  <entry>
    <title>Node生成模板</title>
    <url>/2019/07/01/workspace/Frame/taro/template/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Node生成模板</strong></p>
<p>[[toc]]</p>
<p><strong>基于nodejs编写自动生成路由需要的文件</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pages模版快速生成脚本,执行命令 npm run tep `文件名`</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dirName = process.argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dirName) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件夹名称不能为空！'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'示例：yarn template goodMenu/test'</span>);</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> array = str.toLowerCase().split(<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        array[i] = array[i][<span class="number">0</span>].toUpperCase() + array[i].substring(<span class="number">1</span>, array[i].length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> string = array.join(<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面模版</span></span><br><span class="line"><span class="keyword">const</span> indexTep = <span class="string">`</span></span><br><span class="line"><span class="string">import React, &#123;Component, Fragment&#125; from 'react';</span></span><br><span class="line"><span class="string">import &#123;connect&#125; from 'react-redux'</span></span><br><span class="line"><span class="string">import PropTypes from "prop-types"</span></span><br><span class="line"><span class="string">import &#123;Form, Input, Button, DatePicker, Checkbox, InputNumber, Upload, Icon, Modal, Radio, Drawer, Card&#125; from 'antd';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import "./index.less"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Index extends Component &#123;</span></span><br><span class="line"><span class="string">    constructor(props) &#123;</span></span><br><span class="line"><span class="string">        super(props);</span></span><br><span class="line"><span class="string">        this.state = &#123;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    componentDidMount() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    render() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return (</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                111</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default Index;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Index.defaultProps = &#123;</span></span><br><span class="line"><span class="string">    data:[]</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">Index.propTypes = &#123;</span></span><br><span class="line"><span class="string">    data: PropTypes.array.isRequired//必须有</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// less文件模版</span></span><br><span class="line"><span class="keyword">const</span> lessTep = <span class="string">``</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// model文件模版</span></span><br><span class="line"><span class="keyword">const</span> modelTep = <span class="string">`</span></span><br><span class="line"><span class="string">import &#123;queryShopList&#125; from './service';</span></span><br><span class="line"><span class="string">import &#123;scenicid, shopid&#125; from '@/utils/scenicid';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">    namespace: 'groupBuy',</span></span><br><span class="line"><span class="string">    state: &#123;</span></span><br><span class="line"><span class="string">        data: [],</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    effects: &#123;</span></span><br><span class="line"><span class="string">        * fetch(action, &#123;call, put&#125;) &#123;</span></span><br><span class="line"><span class="string">            // const &#123; banner &#125; = yield select(state =&gt; state.home);</span></span><br><span class="line"><span class="string">            const &#123;data&#125; = yield call(queryShopList, scenicid()['id']);</span></span><br><span class="line"><span class="string">            yield put(&#123;</span></span><br><span class="line"><span class="string">                type: 'save',</span></span><br><span class="line"><span class="string">                payload: &#123;</span></span><br><span class="line"><span class="string">                    data: data,</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">            &#125;);</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    reducers: &#123;</span></span><br><span class="line"><span class="string">        save(state, &#123;payload&#125;) &#123;</span></span><br><span class="line"><span class="string">            return &#123;...state, ...payload&#125;;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service页面模版</span></span><br><span class="line"><span class="keyword">const</span> serviceTep = <span class="string">`</span></span><br><span class="line"><span class="string">import axios from '@/api/axios';</span></span><br><span class="line"><span class="string">import &#123;url&#125; from '@/api/config'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import &#123;getCookie&#125; from "@/utils/cookie";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export const queryShopList = (id) =&gt; &#123;</span></span><br><span class="line"><span class="string">    const baseUrl = '';</span></span><br><span class="line"><span class="string">    return axios.get(baseUrl);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs.mkdirSync(<span class="string">`./src/pages/<span class="subst">$&#123;dirName&#125;</span>`</span>); <span class="comment">// mkdir $1</span></span><br><span class="line">process.chdir(<span class="string">`./src/pages/<span class="subst">$&#123;dirName&#125;</span>`</span>); <span class="comment">// cd $1</span></span><br><span class="line"></span><br><span class="line">fs.writeFileSync(<span class="string">'index.js'</span>, indexTep);</span><br><span class="line">fs.writeFileSync(<span class="string">'index.less'</span>, lessTep);</span><br><span class="line">fs.writeFileSync(<span class="string">'model.js'</span>, modelTep);</span><br><span class="line">fs.writeFileSync(<span class="string">'service.js'</span>, serviceTep);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`模版<span class="subst">$&#123;dirName&#125;</span>已创建,请手动增加models`</span>);</span><br><span class="line"></span><br><span class="line">process.exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Taro</category>
      </categories>
  </entry>
  <entry>
    <title>单元测试框架Jest学习总结</title>
    <url>/2019/07/01/workspace/Frame/unit-test/jest/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>单元测试框架Jest学习总结</strong></p>
<p>[[toc]]</p>
<h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p><code>Mocha+chai</code>(断言库)<br/><br>yarn add mocha chai -D</p>
<p><code>Jest</code><br/><br>yarn add jest -D</p>
<h3 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h3><ul>
<li>业务比较复杂</li>
<li>公司非常注重代码质量，想尽一切办法杜绝线上出bug</li>
<li>需要长期维护的项目。它们需要测试来保障代码可维护性、功能的稳定性</li>
<li>被多次复用的部分，比如一些通用组件和库函数。因为多处复用，更要保障质量</li>
<li>开源项目</li>
</ul>
<h3 id="测试的步骤"><a href="#测试的步骤" class="headerlink" title="测试的步骤"></a>测试的步骤</h3><ul>
<li>写测试说明，针对你的每条测试说明测试了什么功能，预期结果是什么。</li>
<li>写测试主体，通常是 输入 -&gt; 输出。</li>
<li>判断测试结果，拿输出和预期做对比。如果输出和预期相符，则测试通过。反之，不通过。</li>
</ul>
<p><strong>yarn add jest @types/jest  babel-jest babel-core babel-preset-env regenerator-runtime -D</strong></p>
<p>Jest本身是不支持es6的，但是在react中已经配置好babel等，可以直接使用ES6的语法特性进行单元测试</p>
<p><strong>使用方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">expect(<span class="number">1</span>).not.toBe(<span class="number">2</span>)<span class="comment">//判断不等</span></span><br></pre></td></tr></table></figure>

<p><code>toBe()</code> 绝对相等<br/><br><code>toEqual()</code> 判断对象或者数组是否相等<br/><br><code>toBeNull()</code>只匹配null<br/><br><code>toContain()</code>检测数组中是否包含特定某一项<br/><br><code>toBeUndefined()</code>只匹配undefined<br/><br><code>toBeDefine()</code>与toBeUndefined相反<br/><br><code>toBeTruthy()</code>匹配任何if语句为真<br/><br><code>toBeFalsy()</code>匹配任何if语句为假<br/><br><code>toBeCloseTo(0.3)</code> 浮点数判断相等<br/></p>
<p> <strong>数字匹配器</strong><br/><br><code>toBeGreaterThan()</code>大于<br/><br><code>toBeGreaterThanOrEqual()</code>大于或者等于<br/><br><code>toBeLessThan()</code>小于<br/><br><code>toBeLessThanOrEqual()</code>小于或等于<br/></p>
<h3 id="react项目package里面关于jest的配置"><a href="#react项目package里面关于jest的配置" class="headerlink" title="react项目package里面关于jest的配置"></a>react项目package里面关于jest的配置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">   <span class="string">"test"</span>:<span class="string">"jest"</span>, <span class="comment">//全部测试</span></span><br><span class="line">   <span class="string">"app"</span>:<span class="string">"jest /test/app.test.js --watch"</span>  <span class="comment">//单个测试  --watch持续检测</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"jest"</span>: &#123;</span><br><span class="line">   <span class="string">"collectCoverage"</span>:<span class="literal">true</span>,  <span class="comment">//查看覆盖的文件  `可以直接输入 jest --coverage 生成测试覆盖率报告`</span></span><br><span class="line">   <span class="string">"collectCoverageFrom"</span>: [ <span class="comment">//哪些文件需要收集覆盖率信息 </span></span><br><span class="line">     <span class="string">"src/**/*.&#123;js,jsx,ts,tsx&#125;"</span>,</span><br><span class="line">     <span class="string">"!src/**/*.d.ts"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"coverageDirectory"</span>: <span class="string">"tests/coverage"</span>, <span class="comment">//覆盖的文件输入到tests文件夹下</span></span><br><span class="line">   <span class="string">"resolver"</span>: <span class="string">"jest-pnp-resolver"</span>,</span><br><span class="line">   <span class="string">"setupFiles"</span>: [</span><br><span class="line">     <span class="string">"react-app-polyfill/jsdom"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"testMatch"</span>: [ <span class="comment">//设置识别哪些文件是测试文件</span></span><br><span class="line">     <span class="string">"&lt;rootDir&gt;/test/**/__tests__/**/*.&#123;js,jsx,ts,tsx&#125;"</span>,</span><br><span class="line">     <span class="string">"&lt;rootDir&gt;/test/**/?(*.)(spec|test).&#123;js,jsx,ts,tsx&#125;"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"testEnvironment"</span>: <span class="string">"jsdom"</span>,</span><br><span class="line">   <span class="string">"testURL"</span>: <span class="string">"http://localhost"</span>,</span><br><span class="line">   <span class="string">"transform"</span>: &#123;</span><br><span class="line">     <span class="string">"^.+\\.(js|jsx|ts|tsx)$"</span>: <span class="string">"&lt;rootDir&gt;/node_modules/babel-jest"</span>,</span><br><span class="line">     <span class="string">"^.+\\.css$"</span>: <span class="string">"&lt;rootDir&gt;/config/jest/cssTransform.js"</span>,</span><br><span class="line">     <span class="string">"^(?!.*\\.(js|jsx|ts|tsx|css|json)$)"</span>: <span class="string">"&lt;rootDir&gt;/config/jest/fileTransform.js"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"transformIgnorePatterns"</span>: [</span><br><span class="line">     <span class="string">"[/\\\\]node_modules[/\\\\].+\\.(js|jsx|ts|tsx)$"</span>,</span><br><span class="line">     <span class="string">"^.+\\.module\\.(css|sass|scss|less)$"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"moduleNameMapper"</span>: &#123; </span><br><span class="line">     <span class="string">"^react-native$"</span>: <span class="string">"react-native-web"</span>,</span><br><span class="line">     <span class="string">"^.+\\.module\\.(css|sass|scss|less)$"</span>: <span class="string">"identity-obj-proxy"</span>, <span class="comment">//css module的问题</span></span><br><span class="line">     <span class="string">"^@(.*)$"</span>: <span class="string">"&lt;rootDir&gt;/src$1"</span> <span class="comment">//jest的别名设置</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"moduleFileExtensions"</span>: [ <span class="comment">//测试文件的类型</span></span><br><span class="line">     <span class="string">"js"</span>,</span><br><span class="line">     <span class="string">"ts"</span>,</span><br><span class="line">     <span class="string">"tsx"</span>,</span><br><span class="line">     <span class="string">"json"</span>,</span><br><span class="line">     <span class="string">"jsx"</span>,</span><br><span class="line">     <span class="string">"node"</span></span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h3><p>可以查看你那些代码没有被覆盖，帮助你发现盲点</p>
<ul>
<li>在命令行中通过 “–coverage” flag 指定</li>
<li>在 package.json 中手动配置</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H90bd3a97f33a427ebe9de0b3a3e42a2dc.png" alt=""></p>
<p><strong>Uncovered Line</strong> 是哪行没有被覆盖</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>编写测试文件时遵循的命名规范：<code>测试文件的文件名</code> = <code>被测试模块名</code> + .test.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//function.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    fetchUser() &#123;</span><br><span class="line">        <span class="keyword">return</span> axios.get(<span class="string">'http://jsonplaceholder.typicode.com/users/1'</span>)</span><br><span class="line">            .then(<span class="function"><span class="params">res</span> =&gt;</span> res.data)</span><br><span class="line">            .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br><span class="line">    &#125;,</span><br><span class="line">    sum(a, b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//function.test.js</span></span><br><span class="line"><span class="keyword">import</span> functions <span class="keyword">from</span> <span class="string">'../src/functions'</span>;</span><br><span class="line">test(<span class="string">'fetchUser() 可以请求到一个含有name属性值为Leanne Graham的对象'</span>, () =&gt; &#123;</span><br><span class="line">    expect.assertions(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> functions.fetchUser()</span><br><span class="line">        .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            expect(data.name).toBe(<span class="string">'Leanne Graham'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">it(<span class="string">'fetchUser() 可以请求到一个含有name属性值为Leanne Graham的对象  async -- await'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    expect.assertions(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> functions.fetchUser();</span><br><span class="line"></span><br><span class="line">    expect(data.name).toBe(<span class="string">'Leanne Graham'</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">describe(<span class="string">'加法函数测试'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'1加2应该等于3'</span>, () =&gt; &#123;</span><br><span class="line">        expect(functions.sum(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">test(<span class="string">'sum(2 + 2) 等于 4'</span>, () =&gt; &#123;</span><br><span class="line">    expect(functions.sum(<span class="number">2</span>, <span class="number">2</span>)).toBe(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line">test(<span class="string">'sum(2 + 2) 等于 4'</span>, () =&gt; &#123;</span><br><span class="line">    expect(functions.sum(<span class="number">2</span>, <span class="number">2</span>)).not.toBe(<span class="number">1008611</span>);</span><br><span class="line">&#125;);</span><br><span class="line">test(<span class="string">'there is no I in team'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="string">'team'</span>).not.toMatch(<span class="regexp">/I/</span>);</span><br><span class="line">&#125;);</span><br><span class="line">test(<span class="string">'but there is a “stop” in Christoph'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="string">'Christoph'</span>).toMatch(<span class="regexp">/stop/</span>);</span><br><span class="line">&#125;);</span><br><span class="line">test(<span class="string">'测试浮点数是否相等'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="number">0.003</span> + <span class="number">0.01</span>).toBeCloseTo(<span class="number">0.013</span>);  <span class="comment">//这里不能使用toBe</span></span><br><span class="line">&#125;);</span><br><span class="line">test(<span class="string">'对象判断是否相等'</span>, () =&gt; &#123;</span><br><span class="line">    expect(&#123;<span class="attr">test</span>: <span class="string">"11111"</span>&#125;).toEqual(&#123;<span class="attr">test</span>: <span class="string">"11111"</span>&#125;); <span class="comment">//</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe(<span class="string">"筛选数组"</span>, () =&gt; &#123;</span><br><span class="line">    test(<span class="string">"it should filter by a search term (link)"</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> input = [</span><br><span class="line">            &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">url</span>: <span class="string">"https://www.url1.dev"</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">url</span>: <span class="string">"https://www.url2.dev"</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">url</span>: <span class="string">"https://www.link3.dev"</span>&#125;</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> output = [&#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">url</span>: <span class="string">"https://www.link3.dev"</span>&#125;];</span><br><span class="line"></span><br><span class="line">        expect(filterByTerm(input, <span class="string">"link"</span>)).toEqual(output);</span><br><span class="line"></span><br><span class="line">        expect(filterByTerm(input, <span class="string">"LINK"</span>)).toEqual(output);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterByTerm</span>(<span class="params">inputArr, searchTerm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(searchTerm, <span class="string">"i"</span>);</span><br><span class="line">    <span class="keyword">const</span> a = inputArr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">arrayElement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrayElement.url.match(regex);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h3><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://zh-hans.reactjs.org/docs/test-utils.html" target="_blank" rel="noopener">*ReactTestUtils</a></p>
<p><a href="https://www.jianshu.com/p/aee9a19d5e6a" target="_blank" rel="noopener">参考文档</a></p>
<p><a href="https://www.jianshu.com/p/aee9a19d5e6a" target="_blank" rel="noopener">参考文档2</a></p>
<p><a href="http://www.voidcn.com/article/p-ftetcszg-btt.html" target="_blank" rel="noopener">jest 别名</a></p>
<p><a href="https://juejin.im/post/5df73d35e51d45581509a1c2?utm_source=gold_browser_extension" target="_blank" rel="noopener">Jest 入门教程</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Jest</category>
      </categories>
  </entry>
  <entry>
    <title>Taro一些配置</title>
    <url>/2019/07/01/workspace/Frame/taro/taroAdvanced/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Taro一些配置</strong></p>
<p>[[toc]]</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*获取当前页url*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getCurrentPageUrl = (): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'h5'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.location.pathname</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pages = Taro.getCurrentPages();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'tt'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pages[pages.length - <span class="number">1</span>][<span class="string">'__route__'</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentPage = pages[pages.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> currentPage.route;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*基于Promise二次封装Taro.request*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Taro <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;BASE_URL, HTTP_ERROR&#125; <span class="keyword">from</span> <span class="string">"./config.default"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;getCurrentPageUrl&#125; <span class="keyword">from</span> <span class="string">"../utils/common"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  request(options: <span class="built_in">any</span>, method?: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;url, data&#125; = options;</span><br><span class="line">    <span class="keyword">let</span> contentType = <span class="string">"application/json"</span>;</span><br><span class="line">    contentType = options.contentType || contentType;</span><br><span class="line">    <span class="comment">//基于Promise二次封装，方便使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> params: <span class="built_in">any</span> = &#123;</span><br><span class="line">        url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">        data: data,</span><br><span class="line">        method: method || <span class="string">'GET'</span>,</span><br><span class="line">        header: &#123;</span><br><span class="line">          <span class="string">'content-type'</span>: contentType,</span><br><span class="line">          <span class="string">'Authorization'</span>: Taro.getStorageSync(<span class="string">"Authorization"</span>),</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      Taro.request(params).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;statusCode, data&#125; = res;</span><br><span class="line">        <span class="keyword">if</span> (statusCode &gt;= <span class="number">200</span> &amp;&amp; statusCode &lt; <span class="number">300</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> resolve(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (statusCode === <span class="number">401</span>) &#123;</span><br><span class="line">            Taro.setStorageSync(<span class="string">"Authorization"</span>, <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">let</span> path = getCurrentPageUrl();</span><br><span class="line">            <span class="keyword">if</span> (path !== <span class="string">"pages/login/login"</span>) &#123;</span><br><span class="line">              Taro.navigateTo(&#123;</span><br><span class="line">                url: <span class="string">"/pages/login/login"</span></span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(HTTP_ERROR[statusCode]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">'服务器正在维护中!'</span>);</span><br><span class="line">        <span class="keyword">if</span> (err.msg) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'服务器正在维护中!'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>(url: <span class="built_in">String</span>, data: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> params = &#123;url, data&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request(params)</span><br><span class="line">  &#125;,</span><br><span class="line">  post(url: <span class="built_in">String</span>, data: <span class="built_in">any</span>) &#123;</span><br><span class="line">    data = qs.stringify(data);</span><br><span class="line">    <span class="keyword">const</span> params = &#123;url, data&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request(params, <span class="string">'POST'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  put(url: <span class="built_in">String</span>, data: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> params = &#123;url, data&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request(params, <span class="string">'PUT'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">delete</span>(url: <span class="built_in">String</span>, data: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> params = &#123;url, data&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request(params, <span class="string">'DELETE'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*路由的跳转*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> jumpUrl = <span class="function">(<span class="params">url: <span class="built_in">string</span>, options = &#123;&#125; <span class="keyword">as</span> IOptions</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pages: <span class="built_in">any</span>[] = [];</span><br><span class="line">    <span class="keyword">if</span> (process.env.TARO_ENV !== <span class="string">'h5'</span>) &#123;</span><br><span class="line">        pages = Taro.getCurrentPages();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> method = options.method || <span class="string">'navigateTo'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tabList = [</span><br><span class="line">        <span class="string">'pages/functionArea/index'</span>,</span><br><span class="line">        <span class="string">'pages/personCenter/index'</span>,</span><br><span class="line">        <span class="string">'pages/message/index'</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tabList.findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="string">'/'</span> + x == url) != <span class="number">-1</span>) &#123;</span><br><span class="line">            Taro[<span class="string">'switchTab'</span>](&#123;</span><br><span class="line">                url</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method == <span class="string">'navigateTo'</span> &amp;&amp; pages.length === PAGE_LEVEL_LIMIT) &#123;</span><br><span class="line">            Taro[<span class="string">'redirectTo'</span>](&#123;</span><br><span class="line">                url</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method == <span class="string">'redirectTo'</span>) &#123;</span><br><span class="line">            Taro[<span class="string">'redirectTo'</span>](&#123;</span><br><span class="line">                url</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Taro[<span class="string">'navigateTo'</span>](&#123;</span><br><span class="line">                url</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> page: <span class="built_in">any</span> = Taro.getCurrentPages().pop();</span><br><span class="line">              <span class="keyword">if</span> (page === <span class="literal">undefined</span> || page === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">              page.onLoad()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Taro</category>
        <category>Taro一些配置</category>
      </categories>
  </entry>
  <entry>
    <title>Taro基本用法</title>
    <url>/2019/07/01/workspace/Frame/taro/taroBase/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Taro基本用法</strong></p>
<p>[[toc]]</p>
<h3 id="常用的小方法"><a href="#常用的小方法" class="headerlink" title="常用的小方法"></a>常用的小方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;运行时的尺寸转换</span><br><span class="line">Taro.pxTransform(10) &#x2F;&#x2F; 小程序：rpx，H5：rem</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;tabbar右上角的数字</span><br><span class="line">Taro.setTabBarBadge(&#123;</span><br><span class="line">    index: 0,</span><br><span class="line">    text: &#39;1&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;弹框</span><br><span class="line"> Taro.showToast(&#123;</span><br><span class="line">    title: &#39;成功&#39;,</span><br><span class="line">    icon: &#39;loading&#39;,</span><br><span class="line">    duration: 2000</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;loading图</span><br><span class="line">Taro.showLoading(&#123;</span><br><span class="line">    title: &#39;加载中...&#39;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打电话</span><br><span class="line">Taro.makePhoneCall(&#123;</span><br><span class="line">    phoneNumber: &#39;18331883557&#39;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 屏幕最亮 0-1</span><br><span class="line">Taro.setScreenBrightness(&#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 震动</span><br><span class="line">Taro.vibrateShort() &#x2F; Taro.vibrateLong()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;弹框</span><br><span class="line">Taro.showToast(&#123;</span><br><span class="line">    title: &#39;成功&#39;,</span><br><span class="line">    icon: &#39;success&#39;,</span><br><span class="line">    duration: 2000</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;动态修改title</span><br><span class="line">Taro.setNavigationBarTitle(&#123;</span><br><span class="line">    title: &#39;当前页面&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;底部对话框</span><br><span class="line">Taro.showActionSheet(&#123;</span><br><span class="line">     itemList: [&quot;不感兴趣&quot;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;点击tabbar,仅weapp支持</span><br><span class="line">onTabItemTap(res) &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;监听用户下拉刷新事件</span><br><span class="line">onPullDownRefresh() </span><br><span class="line">需要在全局配置的 window 选项中或页面配置中开启 enablePullDownRefresh</span><br><span class="line">Taro.startPullDownRefresh()&#x2F;&#x2F;触发下拉刷新</span><br><span class="line">Taro.stopPullDownRefresh()  &#x2F;&#x2F;停止当前页面的下拉刷新</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;上拉加载</span><br><span class="line">onReachBottom()  </span><br><span class="line">可以在全局配置的 window 选项中或页面配置中设置触发距离 onReachBottomDistance</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;监听用户滑动页面事件</span><br><span class="line">onPageScroll(res)&#123;</span><br><span class="line">   console.log(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;滚定到顶部</span><br><span class="line">Taro.pageScrollTo(&#123;</span><br><span class="line">     scrollTop: 0</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;转发按钮</span><br><span class="line">onShareAppMessage(res) &#123;</span><br><span class="line">  if (res.from &#x3D;&#x3D;&#x3D; &#39;button&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 来自页面内转发按钮</span><br><span class="line">        console.log(res.target)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;imageUrl:&#39;https:&#x2F;&#x2F;storage.360buyimg.com&#x2F;mtd&#x2F;home&#x2F;111543234387022.jpg&#39;</span><br><span class="line">    return &#123;</span><br><span class="line">        title: &#39;工作台&#39;,</span><br><span class="line">        path: &#39;&#x2F;pages&#x2F;functionArea&#x2F;index&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 页面内部转发</span><br><span class="line">&lt;Button open-type&#x3D;&quot;share&quot; onClick&#x3D;&#123;this.onShareAppMessage&#125;&gt;分享&lt;&#x2F;Button&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取系统信息同步接口。</span><br><span class="line">const res &#x3D; Taro.getSystemInfoSync()</span><br><span class="line">console.log(res.model)&#x2F;&#x2F;手机型号</span><br><span class="line">console.log(res.pixelRatio)&#x2F;&#x2F;设备像素比</span><br><span class="line">console.log(res.windowWidth)&#x2F;&#x2F;可使用窗口宽度</span><br><span class="line">console.log(res.windowHeight)&#x2F;&#x2F;可使用窗口高度</span><br><span class="line">console.log(res.language)&#x2F;&#x2F;微信设置的语言</span><br><span class="line">console.log(res.version)&#x2F;&#x2F;微信版本号</span><br><span class="line">console.log(res.platform)&#x2F;&#x2F;客户端平台</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打开设置页面</span><br><span class="line">Taro.openSetting(&#123;</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    console.log(res.authSetting)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;向用户发起授权请求</span><br><span class="line"> Taro.getSetting(&#123; &#x2F;&#x2F;查看用户授权结果</span><br><span class="line">  success(res) &#123;</span><br><span class="line">    if (!res.authSetting[&#39;scope.userLocation&#39;]) &#123;</span><br><span class="line">      Taro.authorize(&#123;</span><br><span class="line">        scope: &#39;scope.userLocation&#39;,</span><br><span class="line">        success() &#123;</span><br><span class="line">          console.log(&#39;打开userLocation&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导航栏展示loading</span><br><span class="line">Taro.showNavigationBarLoading(); &#x2F;&#x2F; open</span><br><span class="line">Taro.hideNavigationBarLoading(); &#x2F;&#x2F; close</span><br></pre></td></tr></table></figure>

<h3 id="路由功能"><a href="#路由功能" class="headerlink" title="路由功能"></a>路由功能</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳转到目的页面，打开新页面</span></span><br><span class="line">Taro.navigateTo(&#123;</span><br><span class="line">  url: <span class="string">'/pages/page/path/name'</span>,</span><br><span class="line">  success:<span class="function"><span class="keyword">function</span>,</span></span><br><span class="line"><span class="function">  <span class="title">fail</span>:<span class="title">function</span>,</span></span><br><span class="line"><span class="function">  <span class="title">complete</span>:<span class="title">function</span></span></span><br><span class="line"><span class="function">&#125;)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 跳转到目的页面，在当前页面打开</span></span><br><span class="line"><span class="function"><span class="title">Taro</span>.<span class="title">redirectTo</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  url: <span class="string">'/pages/page/path/name'</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//跳转到 <span class="title">tabBar</span> 页面，并关闭其他所有非 <span class="title">tabBar</span> 页面</span></span><br><span class="line"><span class="function"><span class="title">Taro</span>.<span class="title">switchTab</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  url: <span class="string">'/pages/page/path/name'</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//关闭当前页面，返回上一页面或多级页面</span></span><br><span class="line"><span class="function"><span class="title">Taro</span>.<span class="title">navigateBack</span>(<span class="params">&#123; delta: <span class="number">2</span> &#125;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//关闭所有页面，打开到应用内的某个页面</span></span><br><span class="line"><span class="function"><span class="title">wx</span>.<span class="title">reLaunch</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  url: <span class="string">'test?id=1'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>)</span></span><br><span class="line"><span class="function">// 传入参数 <span class="title">id</span>=2&amp;<span class="title">type</span>=<span class="title">test</span></span></span><br><span class="line"><span class="function"><span class="title">Taro</span>.<span class="title">navigateTo</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  url: <span class="string">'/pages/page/path/name?id=2&amp;type=test'</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//<span class="title">his</span>.<span class="title">$router</span>.<span class="title">params</span> 获取到传入的参数</span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">C</span> <span class="title">extends</span> <span class="title">Taro</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$router.params) <span class="comment">// 输出 &#123; id: 2, type: 'test' &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取历史记录的条数</span></span><br><span class="line">Taro.getCurrentPages()</span><br></pre></td></tr></table></figure>

<h3 id="组件的外部样式和全局样式"><a href="#组件的外部样式和全局样式" class="headerlink" title="组件的外部样式和全局样式"></a>组件的外部样式和全局样式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在taro 中</span></span><br><span class="line">#a &#123; &#125; /* 在组件中不能使用 */</span><br><span class="line">[a] &#123; &#125; <span class="comment">/* 在组件中不能使用 */</span></span><br><span class="line">button &#123; &#125; <span class="comment">/* 在组件中不能使用 */</span></span><br><span class="line">.a &gt; .b &#123; &#125; <span class="comment">/* 除非 .a 是 view 组件节点，否则不一定会生效 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 该自定义组件的默认样式 支持 */</span></span><br><span class="line">:host &#123;</span><br><span class="line">  color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>外部样式类</strong></p>
<p>如果想传递样式给引用的自定义组件，直接传递 className）不可行，在react是可以的，在taro中：</p>
<p><code>注意：externalClasses 需要使用 短横线命名法 (kebab-case)，而不是 React 惯用的 驼峰命名法 (camelCase)。否则无效。</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CustomComp.js 子组件*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> externalClasses = [<span class="string">'my-class'</span>]</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">className</span>=<span class="string">"my-class"</span>&gt;</span>这段文本的颜色由组件外的 class 决定<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* MyPage.js 父组件*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">CustomComp</span> <span class="attr">my-class</span>=<span class="string">"red-text"</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* MyPage.scss 父组件的样式*/</span></span><br><span class="line">.red-text &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用taro注意事项"><a href="#使用taro注意事项" class="headerlink" title="使用taro注意事项"></a>使用taro注意事项</h3><p><code>1.必须声明 Taro 和组件</code></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">即使变量 View 没有被调用，但也必须从 @tarojs/components 中引入声明。变量 Taro 也是一个必须引入声明的变量，因为我们在编译期和运行时会依赖这个变量做一些特殊处理。**当你引入了其他组件时，一定要使用，不要出现没有使用的变量**。</span><br><span class="line"></span><br><span class="line">当你只用支持微信小程序时，可以不用引入组件例如 View 这样的声明。但我们仍然强烈推荐你在顶部引入你将要使用的组件，这样编辑器/IDE 能更好地提前发现可能出现的问题，也为将来可能需要的多端转换留有余地。</span><br></pre></td></tr></table></figure>

<p><code>2.首字母大写与驼峰式命名</code></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;home_page message="Hello World!" /&gt;  //不支持</span><br><span class="line">&lt;Home_Page message="Hello World!" /&gt;  //支持</span><br><span class="line">&lt;HomePage message="Hello World!" /&gt;   //支持</span><br></pre></td></tr></table></figure>

<p><code>3.JavaScript 表达式</code></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">不能在包含 JSX 元素的 map 循环中使用 if 表达式;</span><br><span class="line">解决方案:尽量在 map 循环中使用条件表达式或逻辑表达式。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不能在 JSX 参数中使用对象展开符</span></span><br><span class="line">&lt;View &#123;...this.props&#125; /&gt;</span><br><span class="line"><span class="comment">//解决</span></span><br><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id, title &#125; = obj</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">id</span>=<span class="string">&#123;id&#125;</span> <span class="attr">title</span>=<span class="string">&#123;title&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>4.JS 编码必须用单引号</code></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在 Taro 中，JS 代码里必须书写单引号，特别是 JSX 中，如果出现双引号，可能会导致编译错误。</span><br></pre></td></tr></table></figure>
<p><code>5.组件传递函数属性名以 on 开头</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 v1.3.0-beta.0 之后，自定义组件间的事件传递可以不用 on 开头，但内置组件的事件依然是以 on 开头的，为了一致性我们仍然推荐你以 on 开头命名你的事件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Taro 中，父组件要往子组件传递函数，属性名必须以 on 开头</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleEvent () &#123;&#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Custom onTrigger=&#123;<span class="keyword">this</span>.handleEvent&#125;&gt;&lt;<span class="regexp">/Custom&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>6.小程序端不要在组件中打印传入的函数</code><br><code>7.小程序端不要在组件中打印 this.props.children</code><br><code>8.小程序端不要将在模板中用到的数据设置为 undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">由于小程序不支持将 data 中任何一项的 value 设为 <span class="literal">undefined</span> ，在 setState 的时候也请避免这么用。你可以使用 <span class="literal">null</span> 来替代。</span><br></pre></td></tr></table></figure>
<p><code>9.组件 state 与 props 里字段重名的问题</code></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">不要在 state 与 props 上用同名的字段，因为这些字段在微信小程序中都会挂在 data 上。</span><br></pre></td></tr></table></figure>
<p><code>10.小程序中页面生命周期 componentWillMount 不一致问题</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于微信小程序里页面在 onLoad 时才能拿到页面的路由参数，而页面 onLoad 前组件都已经 attached 了。因此页面的 componentWillMount 可能会与预期不太一致。例如：</span></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line">render () &#123;</span><br><span class="line">  <span class="comment">// 在 willMount 之前无法拿到路由参数</span></span><br><span class="line">  <span class="keyword">const</span> abc = <span class="keyword">this</span>.$router.params.abc</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Custom</span> <span class="attr">adc</span>=<span class="string">&#123;abc&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line">componentWillMount () &#123;</span><br><span class="line">  <span class="keyword">const</span> abc = <span class="keyword">this</span>.$router.params.abc</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    abc</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">render () &#123;</span><br><span class="line">  <span class="comment">// 增加一个兼容判断</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.state.abc &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Custom</span> <span class="attr">adc</span>=<span class="string">&#123;abc&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于不需要等到页面 willMount 之后取路由参数的页面则没有任何影响。</span></span><br></pre></td></tr></table></figure>
<p><code>11.环境变量 process.env 的使用</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法，不支持</span></span><br><span class="line"><span class="keyword">const</span> &#123; NODE_ENV = <span class="string">'development'</span> &#125; = process.env</span><br><span class="line"><span class="keyword">if</span> (NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>12.要添加包裹的元素</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Block = <span class="function">(<span class="params">props</span>) =&gt;</span>  props.children</span><br><span class="line"><span class="keyword">const</span> Block = <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure>

<p><code>13.小程序</code></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">若使用 微信小程序预览模式 ，则需下载并使用微信开发者工具添加项目进行预览，此时需要注意微信开发者工具的项目设置</span><br><span class="line">需要设置关闭 ES6 转 ES5 功能，开启可能报错</span><br><span class="line">需要设置关闭上传代码时样式自动补全，开启可能报错</span><br><span class="line">需要设置关闭代码压缩上传，开启可能报错</span><br></pre></td></tr></table></figure>

<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><blockquote>
<p>跟react 基本保持一致</p>
</blockquote>
<p><strong>使用 <code>this.$componentType</code> 来判断当前 <code>Taro.Component</code> 是页面还是组件</strong><br><code>this.$componentType</code> 可能取值分别为 <code>PAGE</code> 和<code>COMPONEN</code>T，开发者可以根据此变量的取值分别采取不同逻辑。</p>
<p><code>使用 PropTypes 检查类型</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">随着应用日渐庞大，你可以通过类型检查捕获大量错误。要检查组件的属性，你需要配置特殊的 propTypes 属性：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;Hello, &#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">Greeting.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: 'word'</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">Greeting.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  name: PropTypes.string</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>

<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p><code>使用匿名函数</code> 自 v1.2.9 开始支持<br><br/><br><code>柯里化</code> 自 v1.3.0-beta.1 开始支持</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleClick = <span class="function">(<span class="params">index</span>) =&gt;</span> <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.stopPropagation()</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      currentIndex: index</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>函数式组件</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [c1, setC1] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [c3, setC3] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> increment = <span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有 useCallback 对应的 c1的值改变时，才会返回新的函数</span></span><br><span class="line">  <span class="keyword">const</span> increment1 = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setC1(increment), [c1]);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Text</span>&gt;</span> Counter 1 is &#123;c1&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">Text</span>&gt;</span> Counter 3 is &#123;c3&#125; <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &lt;Button onClick=&#123;increment1&#125;&gt;Increment Counter 1&lt;/Button&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; setC3(increment)&#125;&gt;Increment Counter 3&lt;/Button&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>任何组件的事件传递都要以 on 开头</code> 在 v1.3.0-beta.0 之后，自定义组件间的事件传递可以不用 on 开头，但内置组件的事件依然是以 on 开头的，为了一致性我们仍然推荐你以 on 开头命名你的事件。</p>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p><code>if-else</code><br><code>逻辑运算符 &amp;&amp;</code><br><code>三元运算符（条件表达式）</code><br><code>枚举条件渲染</code> 第一次看到，感觉还挺好玩的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Loading</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; loadingText, LOADING_STATUS, loadingStatus, onRetry &#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View className=<span class="string">'loading-status'</span>&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">'loading'</span>: loadingText,</span><br><span class="line">          <span class="string">'fail'</span>: <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">onClick</span>=<span class="string">&#123;onRetry&#125;</span>&gt;</span> 加载失败, 点击重试 <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>,</span><br><span class="line">          <span class="string">'no-more'</span>: <span class="string">'没有更多了'</span></span><br><span class="line">        &#125;[loadingStatus] <span class="comment">/** loadingStatus 是 `loading`、`fail`、`no-more`  其中一种状态 **/</span></span><br><span class="line">      &#125;</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Refs-引用"><a href="#Refs-引用" class="headerlink" title="Refs 引用"></a>Refs 引用</h3><p><code>使用字符串创建 ref</code>  此方法在react中已经废弃</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="comment">// 如果 ref 的是小程序原生组件，那只有在 didMount 生命周期之后才能通过</span></span><br><span class="line">    <span class="comment">// this.refs.input 访问到小程序原生组件</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'weapp'</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里 this.refs.input 访问的时候通过 `wx.createSeletorQuery` 取到的小程序原生组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'h5'</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里 this.refs.input 访问到的是 `@tarojs/components` 的 `Input` 组件实例</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">ref</span>=<span class="string">'input'</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>通过函数创建 ref</code>  <strong>Taro推荐使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  refCat = <span class="function">(<span class="params">node</span>) =&gt;</span> <span class="keyword">this</span>.cat = node <span class="comment">// `this.cat` 会变成 `Cat` 组件实例的引用</span></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Cat</span> <span class="attr">ref</span>=<span class="string">&#123;this.refCat&#125;</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>通过 createRef 创建 ref</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.cat = Taro.createRef()</span><br><span class="line">  componentDidMount(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.cat.current</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Cat</span> <span class="attr">ref</span>=<span class="string">&#123;this.cat&#125;</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内置环境变量"><a href="#内置环境变量" class="headerlink" title="内置环境变量"></a>内置环境变量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//weapp / swan / alipay / h5 / rn / tt</span></span><br><span class="line">process.env.TARO_ENV</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在 JSX 中使用，决定不同端要加载的组件</span></span><br><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &#123;process.env.TARO_ENV === <span class="string">'weapp'</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">ScrollViewWeapp</span> /&gt;</span></span>&#125;</span><br><span class="line">      &#123;process.env.TARO_ENV === <span class="string">'h5'</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">ScrollViewH5</span> /&gt;</span></span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>统一接口的多端文件</strong></p>
<p>内置环境变量虽然可以解决大部分跨端的问题，但是会让代码中充斥着逻辑判断的代码，影响代码的可维护性，而且也让代码变得愈发丑陋，为了解决这种问题, 开发者可以通过将文件修改成原 <code>文件名 + 端类型</code> 的命名形式 </p>
<p><strong>多端组件 👍</strong></p>
<p>假如有一个 Test 组件存在微信小程序、百度小程序和 H5 三个不同版本，那么就可以像如下组织代码<br>test.js 文件，这是 Test 组件默认的形式，编译到微信小程序、百度小程序和 H5 三端之外的端使用的版本<br>test.h5.js 文件，这是 Test 组件的 H5 版本<br>test.weapp.js 文件，这是 Test 组件的 微信小程序 版本<br>test.swan.js 文件，这是 Test 组件的 百度小程序 版本<br>四个文件，对外暴露的是统一的接口，它们接受一致的参数，只是内部有针对各自平台的代码实现</p>
<p>而我们使用 Test 组件的时候，引用的方式依然和之前保持一致，import 的是不带端类型的文件名，在编译的时候会自动识别并添加端类型后缀</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Test <span class="keyword">from</span> <span class="string">'../../components/test'</span></span><br><span class="line"></span><br><span class="line">&lt;Test argA=&#123;<span class="number">1</span>&#125; argA=&#123;<span class="number">2</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="小程序原生作用域获取"><a href="#小程序原生作用域获取" class="headerlink" title="小程序原生作用域获取"></a>小程序原生作用域获取</h3><p><code>this.$scope</code></p>
<h3 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// 项目名称</span></span><br><span class="line">  projectName: <span class="string">'kj'</span>,</span><br><span class="line">  <span class="comment">// 项目创建日期</span></span><br><span class="line">  date: <span class="string">'2018-6-8'</span>,</span><br><span class="line">  <span class="comment">// 设计稿尺寸</span></span><br><span class="line">  designWidth: <span class="number">750</span>,</span><br><span class="line">  <span class="comment">// 项目源码目录</span></span><br><span class="line">  sourceRoot: <span class="string">'src'</span>,</span><br><span class="line">  <span class="comment">// 项目产出目录</span></span><br><span class="line">  outputRoot: <span class="string">'dist'</span>,</span><br><span class="line">  <span class="comment">// 通用插件配置</span></span><br><span class="line">  plugins: &#123;</span><br><span class="line">    babel: &#123;</span><br><span class="line">      sourceMap: <span class="literal">true</span>,</span><br><span class="line">      presets: [<span class="string">'env'</span>],</span><br><span class="line">      plugins: [<span class="string">'transform-class-properties'</span>, <span class="string">'transform-decorators-legacy'</span>, <span class="string">'transform-object-rest-spread'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 全局变量设置</span></span><br><span class="line">  defineConstants: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 文件 copy 配置</span></span><br><span class="line">  copy: &#123;</span><br><span class="line">    patterns: [</span><br><span class="line">    ],</span><br><span class="line">    options: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 小程序端专用配置</span></span><br><span class="line">  weapp: &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      postcss: &#123;</span><br><span class="line">        autoprefixer: &#123;</span><br><span class="line">          enable: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 小程序端样式引用本地资源内联配置</span></span><br><span class="line">        url: &#123;</span><br><span class="line">          enable: <span class="literal">true</span>,</span><br><span class="line">          config: &#123;</span><br><span class="line">            limit: <span class="number">10240</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 替换 JSX 中的属性名，参考：</span></span><br><span class="line">    <span class="comment">// https://github.com/NervJS/taro/issues/2077</span></span><br><span class="line">    jsxAttributeNameReplace: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// H5 端专用配置</span></span><br><span class="line">  h5: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    staticDirectory: <span class="string">'static'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'js/[name].[hash:8].js'</span>,</span><br><span class="line">        chunkFilename: <span class="string">'js/[name].[chunkhash:8].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    miniCssExtractPluginOption: &#123;</span><br><span class="line">        filename: <span class="string">'css/[name].[hash:8].css'</span>,</span><br><span class="line">        chunkFilename: <span class="string">'css/[name].[chunkhash:8].css'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    imageUrlLoaderOption: &#123;</span><br><span class="line">        limit: <span class="number">5000</span>,</span><br><span class="line">        name: <span class="string">'static/images/[name].[hash:8].[ext]'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      postcss: &#123;</span><br><span class="line">        autoprefixer: &#123;</span><br><span class="line">          enable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//修改url的路径</span></span><br><span class="line">    router: &#123;</span><br><span class="line">      mode: <span class="string">'browser'</span>,</span><br><span class="line">      customRoutes: &#123;</span><br><span class="line">        <span class="string">'/pages/login/index'</span>: <span class="string">'/login'</span>,</span><br><span class="line">        <span class="string">'/pages/functionArea/index'</span>: <span class="string">'/functionArea'</span>,</span><br><span class="line">        <span class="string">'/pages/personCenter/index'</span>: <span class="string">'/personCenter'</span>,</span><br><span class="line">        <span class="string">'/pages/message/index'</span>: <span class="string">'/message'</span>,</span><br><span class="line">        <span class="string">'/pages/ticketCode/index'</span>:<span class="string">'/ticketCode'</span>,</span><br><span class="line">        <span class="string">'/pages/ticketList/index'</span>:<span class="string">'/ticketList'</span>,</span><br><span class="line">        <span class="string">'/pages/activityCode/index'</span>:<span class="string">'/activityCode'</span>,</span><br><span class="line">        <span class="string">'/pages/activityList/index'</span>:<span class="string">'/activityList'</span>,</span><br><span class="line">        <span class="string">'/pages/activityVerify/index'</span>:<span class="string">'/activityVerify'</span>,</span><br><span class="line">        <span class="string">'/pages/analysis/index'</span>:Analysis,</span><br><span class="line">        <span class="string">'/pages/feedBack/index'</span>:<span class="string">'/feedBack'</span>,</span><br><span class="line">        <span class="string">'/pages/set/index'</span>:<span class="string">'/set'</span>,</span><br><span class="line">        <span class="string">'/pages/scenicList/index'</span>:<span class="string">'/scenicList'</span>,</span><br><span class="line">        <span class="string">'/pages/selectPosition/index'</span>:<span class="string">'/selectPosition'</span>,</span><br><span class="line">        <span class="string">'/pages/selectActivity/index'</span>:<span class="string">'/selectActivity'</span>,</span><br><span class="line">        <span class="string">'/pages/codeResult/index'</span>:<span class="string">'/codeResult'</span>,</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义 Webpack 配置</span></span><br><span class="line">    webpackChain: &#123;&#125;,</span><br><span class="line">     devServer: &#123;</span><br><span class="line">      <span class="string">"proxy"</span>: &#123;</span><br><span class="line">        <span class="string">"/api"</span>: &#123;</span><br><span class="line">          <span class="string">"target"</span>: <span class="string">"https://www.v2ex.com/api/"</span>,</span><br><span class="line">          <span class="string">"changeOrigin"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="string">"secure"</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="string">"pathRewrite"</span>: &#123; <span class="string">"^/api"</span>: <span class="string">""</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">merge</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> merge(&#123;&#125;, config, <span class="built_in">require</span>(<span class="string">'./dev'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> merge(&#123;&#125;, config, <span class="built_in">require</span>(<span class="string">'./prod'</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="编译配置详情"><a href="#编译配置详情" class="headerlink" title="编译配置详情"></a>编译配置详情</h3><blockquote>
<p>config目录下面的index</p>
</blockquote>
<p><strong>defineConstants</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用来配置一些全局变量供代码中进行使用，例如：</span><br><span class="line"></span><br><span class="line">defineConstants: &#123;</span><br><span class="line">  A: &#39;&quot;a&quot;&#39; &#x2F;&#x2F; JSON.stringify(&#39;a&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>alias</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'..'</span>, <span class="string">'src'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了让编辑器（VS Code）不报错，并继续使用自动路径补全的功能，需要在项目根目录下的 jsconfig.json 或者 tsconfig.json 中配置 paths 让编辑器认得我们的别名，形式如下：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="string">"paths"</span>: &#123;</span><br><span class="line">      <span class="string">"@/*"</span>: [<span class="string">"./src/*"</span>],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>但若要在 Sass 中使用别名，如 @styles 指向 src/styles：</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"@styles/theme.scss"</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/index.js</span></span><br><span class="line">plugins: &#123;</span><br><span class="line">  sass: &#123;</span><br><span class="line">    importer: <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> reg = <span class="regexp">/^@styles\/(.*)/</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        file: reg.test(url) ? path.resolve(__dirname, <span class="string">'..'</span>, <span class="string">'src/styles'</span>, url.match(reg)[<span class="number">1</span>]) : url</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//备注：目前资源引用时仍无法使用别名，如 background: url('@assets/logo.png')</span></span><br></pre></td></tr></table></figure>

<p>还需要额外的配置（Taro 对样式的处理是 node-sass -&gt; postcss，在 sass 这步就报错了，不能用 postcss-import 插件解决）：</p>
<h3 id="通过环境变量实现-config-的多元控制"><a href="#通过环境变量实现-config-的多元控制" class="headerlink" title="通过环境变量实现 config 的多元控制"></a>通过环境变量实现 config 的多元控制</h3><blockquote>
<p>package.json </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"dev:weapp:mock"</span>: <span class="string">"MOCK=1 npm run dev:weapp"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MOCK=1 可以在 config 中通过 process.env.MOCK 访问到</span></span><br></pre></td></tr></table></figure>

<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Taro, &#123; Component, PageConfig &#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span>;</span><br><span class="line"><span class="keyword">class</span> ReportList <span class="keyword">extends</span> Component &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定config的类型声明为: Taro.PageConfig</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 由于 typescript 对于 object 类型推导只能推出 Key 的基本类型</span></span><br><span class="line"><span class="comment">   * 对于像 navigationBarTextStyle: 'black' 这样的推导出的类型是 string</span></span><br><span class="line"><span class="comment">   * 提示和声明 navigationBarTextStyle: 'black' | 'white' 类型冲突, 需要显示声明类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  config: PageConfig = &#123;</span><br><span class="line">    navigationBarTitleText: <span class="string">'可疑数据汇总'</span>,</span><br><span class="line">    enablePullDownRefresh: <span class="literal">true</span>,   <span class="comment">// 这个是启用下拉刷新特性</span></span><br><span class="line">    backgroundTextStyle: <span class="string">"dark"</span>,   <span class="comment">// 把显示的文本颜色改成暗色调,亮色的话.你背景不改看不到,因为同色</span></span><br><span class="line">    backgroundColor:<span class="string">'#f7f7f7'</span> <span class="comment">// 页面的背景色</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用后,记得加对应的条件关闭,不然会一直显示</span></span><br><span class="line"> <span class="comment">// 下拉刷新</span></span><br><span class="line"> onPullDownRefresh = () :<span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这个loading是 导航栏,页面标题那块显示一个loading  , 微信内置的</span></span><br><span class="line">    Taro.showLoading(&#123;</span><br><span class="line">      title: <span class="string">'loading....'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为我的接口请求都是 async await的姿势,所以可以队列执行</span></span><br><span class="line">    <span class="keyword">this</span>.getList(); </span><br><span class="line">    <span class="keyword">this</span>.unselect();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接口请求完毕后隐藏两个loading , 标题和下拉区域</span></span><br><span class="line">    Taro.hideLoading();</span><br><span class="line">    Taro.stopPullDownRefresh();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新Taro"><a href="#更新Taro" class="headerlink" title="更新Taro"></a>更新Taro</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;更新 Taro CLI 工具</span><br><span class="line">taro</span><br><span class="line">$ taro update self</span><br><span class="line">npm</span><br><span class="line">$ npm i -g @tarojs&#x2F;cli@latest</span><br><span class="line">yarn</span><br><span class="line">$ yarn global add @tarojs&#x2F;cli@latest</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新项目中 Taro 相关的依赖</span><br><span class="line">$ taro update project</span><br><span class="line"></span><br><span class="line">$ taro info 打印的信息</span><br><span class="line">$ taro doctor 诊断项目的依赖、设置、结构，以及代码的规范是否存在问题，并尝试给出解决方案。</span><br></pre></td></tr></table></figure>





<h3 id="Taro的注意事项"><a href="#Taro的注意事项" class="headerlink" title="Taro的注意事项"></a>Taro的注意事项</h3><p> <strong>1. 在H5端 周期函数里面使用动态修改tabbar的内容，会循环执行钩子函数</strong></p>
<p> <strong>2. taro路由在h5端 ，不能使用引用的变量</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> method=<span class="string">'navigateTo'</span>;</span><br><span class="line">Taro[method](&#123;</span><br><span class="line">      url</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//这种的在h5端，报错</span></span><br><span class="line"><span class="comment">//设置变量在h5下不能跳转，必须是Taro['navigateTo'] or Taro.navigateTo</span></span><br></pre></td></tr></table></figure>
<p><strong>3. H5下ScrollView,只显示首屏，下面的都是空白,TaroUI里面overflow:hidden</strong></p>
<p><strong>4. cssModules 在字节头条里面，修改全局的样式必须声明在最外面</strong></p>
<p><strong>5. H5下:global{}后的样式，有污染的影响,前提是兼容tt</strong></p>
<p> <strong>6. TaroUI在路由组件里面可以修改全局的样式，但是拆分组件之后，就不能修改样式,h5下正常显示【cssModules】</strong></p>
<p><code>小程序的 addGlobalClass 只能使 page 页面上的样式可以影响</code></p>
<p><strong>7. 自定义若干个外部样式类 用 <code>static externalClasses = [&#39;class-name-style&#39;];</code>，然后传递给子组件</strong> </p>
<p>缺陷 <code>1.H5端不兼容;2.必须用小驼峰</code></p>
<p><strong>8. 小程序拆包在tt下需要手动放到pages里面,在H5下正常显示</strong></p>
<p><strong>9. 阻止冒泡</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jsx</span></span><br><span class="line"> &#123;</span><br><span class="line">   [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View key=&#123;item&#125; onClick=&#123;<span class="keyword">this</span>.parent(item)&#125;&gt;</span><br><span class="line">                &lt;Text&gt;</span><br><span class="line">                    我是父盒子&#123;item&#125;</span><br><span class="line">                &lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">                &lt;View onClick=&#123;this.son(item)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;Text&gt;</span></span><br><span class="line"><span class="regexp">                        我是子盒子 &#123;item&#125;</span></span><br><span class="line"><span class="regexp">                    &lt;/</span>Text&gt;</span><br><span class="line">                &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line">parent = <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'parent'</span>, val);</span><br><span class="line"> &#125;;</span><br><span class="line"> son = <span class="function">(<span class="params">val</span>) =&gt;</span>（e）=&gt; &#123;</span><br><span class="line">     e.stopPropagation();</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'son'</span>, val);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>函数式组件</strong></p>
<pre><code>H5
  柯理化函数阻止冒泡成功
  bind阻止冒泡成功

weapp
  柯理化函数阻止冒泡失效
  bind阻止冒泡失效</code></pre><p><strong>类组件</strong></p>
<pre><code>H5
柯理化函数阻止冒泡成功
bind阻止冒泡成功

weapp
柯理化函数阻止冒泡失效
bind阻止冒泡成功</code></pre><p><strong>通用</strong></p>
<pre><code>1.普通的箭头函数,所有兼容，有局限性;
2.行内阻止冒泡，写业务代码</code></pre><p> <strong>10. iconfont只能使用下载本地的方式,直接使用链接页面显示方框</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种使用方式</span></span><br><span class="line">&lt;Text className=&#123;classNames(<span class="string">'icon'</span>, <span class="string">'icon-home'</span>, styles.setIcon)&#125;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;Text className=&#123;'icon'&#125;&gt;&amp;#xe64e;&lt;/Text&gt;</span><br><span class="line"></span><br><span class="line">&lt;AtIcon prefixClass=<span class="string">'icon'</span> value=<span class="string">'home'</span> size=<span class="string">'20'</span> color=<span class="string">'#fff'</span>/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>11. TaroUI在H5模式下编译报错</strong></p>
<p>请在 config/index.js 文件中添加如下配置项：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">h5: &#123;</span><br><span class="line">  esnextModules: [<span class="string">'taro-ui'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Taro</category>
        <category>Taro基本用法</category>
      </categories>
  </entry>
  <entry>
    <title>项目目录</title>
    <url>/2019/07/01/workspace/Frame/taro/toc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>项目目录</strong></p>
<p>[[toc]]</p>
<p><strong>以Taro为栗子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├─config   -- 配置文件(插件等)  </span><br><span class="line">│      dev.js  --开发项目配置</span><br><span class="line">│      index.js  --适用于开发和生产</span><br><span class="line">│      prod.js   --生产项目配置</span><br><span class="line">│      template.js  --node写的文件模板，直接构建</span><br><span class="line">├─src  </span><br><span class="line">│  │--app.tsx  --项目入口文件 </span><br><span class="line">│  │--app.scss  -- 全局样式文件(会自动引入)  </span><br><span class="line">│  │--global.tsx  -- 项目全局引入(可在里面引入一些全局用到的包)  </span><br><span class="line">│  ├─assets  --资源文件  </span><br><span class="line">│  ├─components    --系统通用组件</span><br><span class="line">│  ├─layouts   -- 布局文件夹   </span><br><span class="line">│  ├─models  --全局model(非全局的不能放到这个下面)  </span><br><span class="line">│  ├─pages  --业务相关页面  </span><br><span class="line">│  |业务中用到的页面建议按模块划分，注意大小写保持一致  </span><br><span class="line">│  |如果用到model，注意增加models文件夹 model的namespace得全局唯一，建议按文件夹层级命名  </span><br><span class="line">│  |</span><br><span class="line">│  ├─service  -- 服务方法 </span><br><span class="line">│  │      api.ts --request的二次封装</span><br><span class="line">│  │      global.service.ts   --全局用到的接口</span><br><span class="line">│  │      config.default.ts  --状态码和生产开发域名的配置</span><br><span class="line">│  ├─dev  --开发专用的一些快捷方式</span><br><span class="line">│  ├─bases  -- 底层框架的封装</span><br><span class="line">│  ├─types  --系统中用到的一些类型定义    </span><br><span class="line">│  ├─utils  --辅助方法</span><br><span class="line">│  │      lodash.ts  --权限辅助方法  </span><br><span class="line">│  │      storage.ts  --本地存储的一些方法</span><br><span class="line">│  │      index.ts  --通用辅助方法(导入的时候 import &#123;xx&#125; from &#39;@&#x2F;utils&#39;即可)  </span><br><span class="line">│  │      docs.ts   --一些状态展示用的方法</span><br><span class="line">│  │      constants.ts  --定义的一些常量</span><br><span class="line">│  │      regexp.ts --正则相关辅助方法   </span><br><span class="line">│  │      router.ts --路由相关的方法</span><br><span class="line">│  └─</span><br><span class="line">└─project.config.json --微信小程序的配置</span><br><span class="line">└─project.swan.json --百度智能小程序</span><br><span class="line">└─project.tt.json --头条小程序的配置</span><br><span class="line">└─project.quickapp.json --快应用</span><br><span class="line">└─project.qq.json --QQ小程序</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Taro</category>
        <category>项目目录</category>
      </categories>
  </entry>
  <entry>
    <title>错误机制</title>
    <url>/2020/01/17/workspace/Frame/vue/error-handler/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>错误机制</strong></p>
<p>[[toc]]</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>文件路径<code>vue/src/core/util/error.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import config from &#39;..&#x2F;config&#39;</span><br><span class="line">import &#123;warn&#125; from &#39;.&#x2F;debug&#39;</span><br><span class="line">import &#123;inBrowser, inWeex&#125; from &#39;.&#x2F;env&#39;  &#x2F;&#x2F; 运行的平台</span><br><span class="line">import &#123;isPromise&#125; from &#39;shared&#x2F;util&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;*自己实现一个版本，前几天一个npm小项目的更新给整个npm生态系统制造了一场混乱，影响到了数百万 JS 项目。这个库就是 is-promise；</span><br><span class="line">* function isPromise(val)&#123;</span><br><span class="line">*    return (typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof val &#x3D;&#x3D;&#x3D; &#39;function&#39;) &amp;&amp; val !&#x3D;&#x3D;null &amp;&amp;  typeof val.then &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof val.catch &#x3D;&#x3D;&#x3D; &#39;function&#39;</span><br><span class="line">*  &#125;</span><br><span class="line">* *&#x2F;</span><br><span class="line">import &#123;pushTarget, popTarget&#125; from &#39;..&#x2F;observer&#x2F;dep&#39;</span><br><span class="line"></span><br><span class="line">export function handleError(err: Error, vm: any, info: string) &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理错误信息, 进行错误上报</span><br><span class="line">  &#x2F;&#x2F; err错误对象</span><br><span class="line">  &#x2F;&#x2F; vm Vue实例</span><br><span class="line">  &#x2F;&#x2F; info是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span><br><span class="line">  &#x2F;&#x2F; 只在 2.2.0+ 可用</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当错误函数处理错误时，停用deps跟踪以避免可能出现的infinite rendering</span><br><span class="line">  &#x2F;&#x2F; See: https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;vuex&#x2F;issues&#x2F;1505</span><br><span class="line">  pushTarget()</span><br><span class="line">  try &#123;</span><br><span class="line">    if (vm) &#123;</span><br><span class="line">      let cur &#x3D; vm  &#x2F;&#x2F; 获取当前的错误组件，然后递归查找当前组件的父组件，依次调用errorCaptured 方法。</span><br><span class="line">      while ((cur &#x3D; cur.$parent)) &#123;</span><br><span class="line">        const hooks &#x3D; cur.$options.errorCaptured</span><br><span class="line">        if (hooks) &#123;</span><br><span class="line">          for (let i &#x3D; 0; i &lt; hooks.length; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              &#x2F;&#x2F; 逐个执行</span><br><span class="line">              const capture &#x3D; hooks[i].call(cur, err, vm, info) &#x3D;&#x3D;&#x3D; false</span><br><span class="line">              if (capture) return   &#x2F;&#x2F; 返回false 默认不会向上递归</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">              globalHandleError(e, cur, &#39;errorCaptured hook&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 最后执行全局的errorHandler，返回返回false就中断了</span><br><span class="line">    globalHandleError(err, vm, info)</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    popTarget()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 处理异步错误</span><br><span class="line">export function invokeWithErrorHandling(</span><br><span class="line">  handler: Function,</span><br><span class="line">  context: any,</span><br><span class="line">  args: null | any[],</span><br><span class="line">  vm: any,</span><br><span class="line">  info: string</span><br><span class="line">) &#123;</span><br><span class="line">  let res</span><br><span class="line">  try &#123;</span><br><span class="line">    res &#x3D; args ? handler.apply(context, args) : handler.call(context)</span><br><span class="line">    if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123;</span><br><span class="line">      res.catch(e &#x3D;&gt; handleError(e, vm, info + &#96; (Promise&#x2F;async)&#96;))</span><br><span class="line">      res._handled &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    handleError(e, vm, info)</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function globalHandleError(err, vm, info) &#123;</span><br><span class="line">  if (config.errorHandler) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return config.errorHandler.call(null, err, vm, info)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果用户有意在处理程序中抛出原始错误，</span><br><span class="line">      &#x2F;&#x2F;不要记录两次，一次性输出</span><br><span class="line">      if (e !&#x3D;&#x3D; err) &#123;</span><br><span class="line">        logError(e, null, &#39;config.errorHandler&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  logError(err, vm, info)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function logError(err, vm, info) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">    warn(&#96;Error in $&#123;info&#125;: &quot;$&#123;err.toString()&#125;&quot;&#96;, vm)</span><br><span class="line">  &#125;</span><br><span class="line">  if ((inBrowser || inWeex) &amp;&amp; typeof console !&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* ErrorBoundary  错误边界</span><br><span class="line">*</span><br><span class="line">* react</span><br><span class="line">* class ErrorBoundary extends React.Component &#123;</span><br><span class="line">*    constructor(props) &#123;</span><br><span class="line">*        super(props);</span><br><span class="line">*        this.state &#x3D; &#123; hasError: false &#125;;</span><br><span class="line">*    &#125;</span><br><span class="line">*    componentDidCatch(error, info) &#123;</span><br><span class="line">*        this.setState(&#123; hasError: true &#125;);</span><br><span class="line">*        &#x2F;&#x2F; 将异常信息上报给服务器</span><br><span class="line">*        logErrorToMyService(error, info);</span><br><span class="line">*    &#125;</span><br><span class="line">*    render() &#123;</span><br><span class="line">*        if (this.state.hasError) &#123;</span><br><span class="line">*            return &#39;出错了&#39;;</span><br><span class="line">*        &#125;</span><br><span class="line">*        return this.props.children;</span><br><span class="line">*    &#125;</span><br><span class="line">* &#125;</span><br><span class="line">* vue</span><br><span class="line">* Vue.component(&#39;ErrorBoundary&#39;, &#123;</span><br><span class="line">*  data: () &#x3D;&gt; (&#123; error: null &#125;),</span><br><span class="line">*  errorCaptured (err, vm, info) &#123;</span><br><span class="line">*    this.error &#x3D; &#96;$&#123;err.stack&#125;\n\nfound in $&#123;info&#125; of component&#96;</span><br><span class="line">*    return false</span><br><span class="line">*  &#125;,</span><br><span class="line">*  render (h) &#123;</span><br><span class="line">*    if (this.error) &#123;</span><br><span class="line">*      return h(&#39;pre&#39;, &#123; style: &#123; color: &#39;red&#39; &#125;&#125;, this.error)</span><br><span class="line">*    &#125;</span><br><span class="line">*    &#x2F;&#x2F; ignoring edge cases for the sake of demonstration</span><br><span class="line">*    return this.$slots.default[0]</span><br><span class="line">*  &#125;</span><br><span class="line">*&#125;)</span><br><span class="line">**</span><br><span class="line">* &lt;ErrorBoundary&gt;</span><br><span class="line">*   &lt;this.props.children&gt;</span><br><span class="line">* &lt;&#x2F;ErrorBoundary&gt;</span><br><span class="line">*</span><br><span class="line">* 笔记</span><br><span class="line">*</span><br><span class="line">* 组件内部使用</span><br><span class="line">* errorCaptured(...opt) &#123;</span><br><span class="line">*   &#x2F;&#x2F;  当前组件报错，他会顺着父组件向上传递，直接到全局的errorHandler</span><br><span class="line">*    console.log(&#39;你大爷的&#39;, opt);</span><br><span class="line">*    return false   &#x2F;&#x2F; 错误会被阻止，不会换起上一级的 errorCaptured 和全局的errorHandler</span><br><span class="line">*  &#125;,</span><br><span class="line">*</span><br><span class="line">* 全局使用</span><br><span class="line">*Vue.config.errorHandler &#x3D; function (err, vm, info) &#123;</span><br><span class="line">*  &#x2F;&#x2F; throw Error(&#39;抛出一个错误&#39;)</span><br><span class="line">*  let &#123;</span><br><span class="line">*    message, &#x2F;&#x2F; 异常信息</span><br><span class="line">*    name, &#x2F;&#x2F; 异常名称</span><br><span class="line">*   stack  &#x2F;&#x2F; 异常堆栈信息</span><br><span class="line">* &#125; &#x3D; err;</span><br><span class="line">* console.log(&#39;----1111----&#39;, name);</span><br><span class="line">* console.log(&#39;----1111----&#39;, message);</span><br><span class="line">* console.log(&#39;----1111----&#39;, stack);</span><br><span class="line">*</span><br><span class="line">* console.log(&#39;----2222----&#39;, vm,);</span><br><span class="line">* console.log(&#39;----3333----&#39;, info);</span><br><span class="line">* &#x2F;&#x2F; 可以执行一步操作</span><br><span class="line">&#125;;</span><br><span class="line">* throw Error(&#39;抛出一个错误&#39;)</span><br><span class="line">*</span><br><span class="line">* *&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="react的error解析"><a href="#react的error解析" class="headerlink" title="react的error解析"></a>react的error解析</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// koa2</span></span><br><span class="line">router.post(<span class="string">'/errorMsg/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> error = ctx.request.body;; <span class="comment">// 获取前端传过来的报错对象</span></span><br><span class="line">    <span class="keyword">let</span> url = error.scriptURI; <span class="comment">// 压缩文件路径</span></span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="comment">// map文件路径  vue的官方不建议上传 .map 文件，说是容易看到很多源码，react何尝不是呢</span></span><br><span class="line">        <span class="comment">// 所以可以直接传递给服务器当前的 .map 文件</span></span><br><span class="line">        <span class="keyword">let</span> fileUrl = url.slice(url.indexOf(<span class="string">'client/'</span>)) + <span class="string">'.map'</span>; </span><br><span class="line">        <span class="comment">// 解析sourceMap</span></span><br><span class="line">        <span class="keyword">let</span> smc = <span class="keyword">new</span> sourceMap.SourceMapConsumer(fs.readFileSync(resolve(<span class="string">'../'</span> + fileUrl), <span class="string">'utf8'</span>)); <span class="comment">// 返回一个promise对象</span></span><br><span class="line">        smc.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 解析原始报错数据</span></span><br><span class="line">            <span class="keyword">let</span> ret = result.originalPositionFor(&#123;</span><br><span class="line">                line: error.lineNo, <span class="comment">// 压缩后的行号</span></span><br><span class="line">                column: error.columnNo <span class="comment">// 压缩后的列号</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">let</span> url = <span class="string">''</span>; <span class="comment">// 上报地址</span></span><br><span class="line">            <span class="comment">// 将异常上报至后台</span></span><br><span class="line">            fetch(url, &#123;</span><br><span class="line">                method: <span class="string">'POST'</span>,</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                    errorMessage: error.errorMessage, <span class="comment">// 报错信息</span></span><br><span class="line">                    source: ret.source, <span class="comment">// 报错文件路径</span></span><br><span class="line">                    line: ret.line, <span class="comment">// 报错文件行号</span></span><br><span class="line">                    column: ret.column, <span class="comment">// 报错文件列号</span></span><br><span class="line">                    stack: error.stack <span class="comment">// 报错堆栈</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> response.json();</span><br><span class="line">            &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">                res.json(json);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>错误机制</category>
      </categories>
  </entry>
  <entry>
    <title>Vue预渲染</title>
    <url>/2020/08/10/workspace/Frame/vue/prerender/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Vue预渲染</strong></p>
<p>之前一段时间调研了React的<a href="https://juejin.im/post/6854573205349367815" target="_blank" rel="noopener">SSR</a>,今天有时间研究下Vue的预渲染。老套路还是先说说预渲染有什么好处，跟SSR有什么区别？？？？  Let’s look down  👓⏬</p>
<p>如果你调研服务器端渲染 (SSR) 只是用来改善少数营销页面（例如 <code>/</code>, <code>/about</code>, <code>/contact</code> 等）的 SEO，那么你可能需要<strong>预渲染</strong>。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。</p>
<p>预渲染是为了页面有更好的加载速度，而且可以改善少数页面的SEO，为什么是少数的，因为大量的路由会使预渲染变得非常缓慢（构建时）。预渲染基本原理是 - 启动无头浏览器，加载应用程序的路由并将结果保存到静态HTML文件中。然后，您可以将其与以前使用的任何静态文件服务解决方案一起使用，用最少的代码做到你想要的效果几乎没有任何的侵入性。</p>
<p>看下他们的区别：</p>
<table>
<thead>
<tr>
<th align="left"><a href="https://juejin.im/post/6854573205349367815" target="_blank" rel="noopener">SSR</a></th>
<th align="left"><a href="https://www.npmjs.com/package/prerender-spa-plugin" target="_blank" rel="noopener">预渲染</a></th>
</tr>
</thead>
<tbody><tr>
<td align="left">运行时</td>
<td align="left">构建时</td>
</tr>
<tr>
<td align="left">代码侵入性大，开发调试代价高，报错不明显（钩子）</td>
<td align="left">几乎没有侵入性</td>
</tr>
<tr>
<td align="left">SEO更彻底</td>
<td align="left">有局限性（动态URL的异步请求）</td>
</tr>
<tr>
<td align="left">首屏加载更快</td>
<td align="left">首屏加载快</td>
</tr>
<tr>
<td align="left">需要Node环境，耗费CPU内存</td>
<td align="left">不需要Node环境</td>
</tr>
<tr>
<td align="left">难度较大（有现成的框架）</td>
<td align="left">难度小</td>
</tr>
<tr>
<td align="left">动态内容直出 HTMl</td>
<td align="left">直出有限，客户端会再次加载（跳屏）</td>
</tr>
</tbody></table>
<p><strong>上干货</strong></p>
<p>预渲染核心插件：<strong>prerender-spa-plugin</strong> 为了更好的SEO一般会动态需改meta的内容 <strong>vue-meta-info</strong></p>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add prerender-spa-plugin vue-meta-info -D</span><br></pre></td></tr></table></figure>

<p>prerender-spa-plugin 是基于puppeteer的，下载出错多试几次，百度很多文章可解决</p>
<p><strong>vue.config.js中进行配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PrerenderSPAPlugin = <span class="built_in">require</span>(<span class="string">'prerender-spa-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> Renderer = PrerenderSPAPlugin.PuppeteerRenderer</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">       <span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">          <span class="comment">// 生成文件的路径，这个目录只能有一级。若目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动</span></span><br><span class="line">          staticDir: path.join(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">          <span class="comment">// 可选-渲染的应用程序应输出到的路径。</span></span><br><span class="line">          <span class="comment">// (默认为staticDir。）</span></span><br><span class="line">          outputDir: path.join（__dirname ，<span class="string">'/dist/prerendered'</span>）， </span><br><span class="line">          <span class="comment">// 对应自己的路由文件</span></span><br><span class="line">          routes: [ <span class="string">'/'</span>, <span class="string">'/home'</span>,<span class="string">'/list'</span>],</span><br><span class="line">          <span class="comment">// 若没有这段则不会进行预编译</span></span><br><span class="line">          renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">            inject: &#123;</span><br><span class="line">              foo: <span class="string">'bar'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// headless: false,</span></span><br><span class="line">            <span class="comment">// 在 main.js 中 document.dispatchEvent(new Event('render-event'))，两者的事件名称要对应上。</span></span><br><span class="line">            renderAfterDocumentEvent: <span class="string">'render-event'</span>,</span><br><span class="line">            <span class="comment">// 可选-等待渲染，直到经过一定的时间。</span></span><br><span class="line">            <span class="comment">// 不推荐</span></span><br><span class="line">            renderAfterTime: <span class="number">5000</span>,</span><br><span class="line">            <span class="comment">// 可选-默认为0，无限制。</span></span><br><span class="line">            <span class="comment">// 路由是异步呈现的。</span></span><br><span class="line">            <span class="comment">// 使用它来限制并行渲染的路由数量</span></span><br><span class="line">            maxConcurrentRoutes: <span class="number">4</span> ， </span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>main.js中进行配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> MetaInfo <span class="keyword">from</span> <span class="string">'vue-meta-info'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.use(MetaInfo)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render:<span class="function"><span class="params">h</span>=&gt;</span>h(App),</span><br><span class="line">  mounted()&#123;</span><br><span class="line">     <span class="built_in">document</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">'render-event'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>



<p><code>注：预渲染方式下的route需采用history模式，否则每个打包生成的index.html的文件内容会一样</code></p>
<p><strong>组件内静态使用metaInfo</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">...</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  metaInfo: &#123;</span><br><span class="line">    title: &#39;My Example App&#39;, &#x2F;&#x2F; 可以是异步的</span><br><span class="line">    meta: [&#123;                 </span><br><span class="line">      name: &#39;keyWords&#39;,</span><br><span class="line">      content: &#39;预渲染&#39;</span><br><span class="line">    &#125;]</span><br><span class="line">    link: [&#123;                </span><br><span class="line">      rel: &#39;asstes&#39;,</span><br><span class="line">      href: &#39;file.jing999.cn&#39;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>Vue预渲染</category>
      </categories>
  </entry>
  <entry>
    <title>问题验证解析</title>
    <url>/2020/02/17/workspace/Frame/vue/problem/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>问题验证解析</strong></p>
<p>[[toc]]</p>
<h3 id="vue中组件的data为什么是一个函数"><a href="#vue中组件的data为什么是一个函数" class="headerlink" title="vue中组件的data为什么是一个函数"></a>vue中组件的data为什么是一个函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">data () &#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">      count:<span class="number">0</span>,</span><br><span class="line">      show:<span class="literal">true</span>,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">data: &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">    show:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组件是可复用的<code>vue</code>实例，一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，<br>组件中的<code>data</code>数据都应该是<code>相互隔离，互不影响</code>的，基于这一理念，组件每复用一次，<code>data</code>数据就应该被复制一次，之后，<br>当某一处复用的地方组件内<code>data</code>数据被改变时，其他复用地方组件的<code>data</code>数据不受影响</p>
<p><strong>方法一</strong> 例子中的<code>data</code>不是一个单纯的对象，而是一个函数返回值的形式，所以每个组件实例可以维护一份被返回对象的独立拷贝，如果我们将上述例子中的<code>data</code>修改为 <strong>方法二</strong>。<br/><br>那么就会造成无论在哪个组件里改变了<code>count</code>值，都会影响到其他组件里的<code>count</code>。这是因为当data如此定义后，这就表示所有的组件实例共用了一份<code>data</code>数据，因此，无论在哪个组件实例中修改了<code>data</code>,都会影响到所有的组件实例。</p>
<h3 id="v-show-与-v-if-有什么区别"><a href="#v-show-与-v-if-有什么区别" class="headerlink" title="v-show 与 v-if 有什么区别"></a>v-show 与 v-if 有什么区别</h3><p><strong>v-if</strong> 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；<br>也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<strong>v-if</strong> 有更高的切换开销</p>
<p><strong>v-show</strong> 就简单得多——不管初始条件是什么，元素总是会被渲染，所以有更高的初始渲染开销，并且只是简单地基于 <strong>CSS 的 ‘display’</strong> 属性进行切换。<br>适用于需要非常频繁切换条件的场景</p>
<h3 id="vue-的父组件和子组件生命周期钩子函数执行顺序"><a href="#vue-的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="vue 的父组件和子组件生命周期钩子函数执行顺序"></a>vue 的父组件和子组件生命周期钩子函数执行顺序</h3><ul>
<li>加载渲染过程<ul>
<li>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li>
</ul>
</li>
</ul>
<ul>
<li>子组件更新过程<ul>
<li>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li>
</ul>
</li>
</ul>
<ul>
<li>父组件更新过程 <ul>
<li>父 beforeUpdate -&gt; 父 updated</li>
</ul>
</li>
</ul>
<ul>
<li>销毁过程<ul>
<li>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li>
</ul>
</li>
</ul>
<h3 id="vue-项目进行哪些优化"><a href="#vue-项目进行哪些优化" class="headerlink" title="vue 项目进行哪些优化"></a>vue 项目进行哪些优化</h3><p><strong>代码层面的优化</strong></p>
<ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch  区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>长列表性能优化</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载(按需加载)</li>
<li>第三方插件的按需引入</li>
<li>优化无限列表性能</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<p><strong>Webpack 层面的优化</strong></p>
<ul>
<li>Webpack 对图片进行压缩</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
</ul>
<p><strong>基础的 Web 技术的优化</strong></p>
<ul>
<li>开启 gzip 压缩</li>
<li>http缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
<h3 id="Vue-采用数据劫持的手段可以精准拿到变化的数据-为什么还需要虚拟DOM进⾏diff检测差异"><a href="#Vue-采用数据劫持的手段可以精准拿到变化的数据-为什么还需要虚拟DOM进⾏diff检测差异" class="headerlink" title="Vue 采用数据劫持的手段可以精准拿到变化的数据,为什么还需要虚拟DOM进⾏diff检测差异?"></a>Vue 采用数据劫持的手段可以精准拿到变化的数据,为什么还需要虚拟DOM进⾏diff检测差异?</h3><p>现在前端框架有两种数据变动侦测方式，一种是pull，一种是push.<br>pull 的代表是React ，在进行 setState 操作后显示更新数据，React 会使用 diff 算法一层层找出差异，然后 patch 到 DOM 树上，React 一开始不知道那里变化了，只是知道变化了，然后暴力进行查找那变化了或者使用<code>PureComponent/shouldComponentUpdate</code>，另一个代表是 Angular 的脏检查。</p>
<p>Vue 的响应式系统就是 Push 的代表，Vue 初始化的时候就会对 data 的数据进行依赖收集，因此Vue能实时知道那里发生了变化，一般绑定的细粒度过高，会生成大量的Watcher 实例，则会造成过大的内存和依赖追踪的开销，而细粒度过低无法侦测到变化。因此，Vue采用的是中等细粒度的方案，只针对组件级别的进行响应式监听也就是push，这样可以知道那个组件发生了变化，再对组件进行diff算法找到具体变化的位置，这是pull操作，vue是pull + push 结合进行变化侦测的。</p>
<h3 id="vue-中怎么重置-data"><a href="#vue-中怎么重置-data" class="headerlink" title="vue 中怎么重置 data"></a>vue 中怎么重置 data</h3><p>使用Object.assign()，vm.$data可以获取当前状态下的data，vm.$options.data可以获取到组件初始化状态下的data</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="keyword">this</span>.$data, <span class="keyword">this</span>.$options.data())</span><br></pre></td></tr></table></figure>

<h3 id="组件中写-name-选项有什么作用"><a href="#组件中写-name-选项有什么作用" class="headerlink" title="组件中写 name 选项有什么作用"></a>组件中写 name 选项有什么作用</h3><ol>
<li>项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤</li>
<li>DOM 做递归组件时需要调用自身 name</li>
<li>vue-devtools 调试工具里显示的组见名称是由vue中组件name决定的</li>
</ol>
<h3 id="route-和-router-的区别是什么"><a href="#route-和-router-的区别是什么" class="headerlink" title="route 和 router 的区别是什么"></a>route 和 router 的区别是什么</h3><ol>
<li>$route是“路由信息对象”，包括path,params,hash,query,fullPath,matched,name等路由信息参数。</li>
<li>$router是“路由实例对象”，包括了路由的跳转方法(push、replace)，钩子函数等</li>
</ol>
<h3 id="vue组件里写的原生addEventListeners监听事件，要手动去销毁吗"><a href="#vue组件里写的原生addEventListeners监听事件，要手动去销毁吗" class="headerlink" title="vue组件里写的原生addEventListeners监听事件，要手动去销毁吗"></a>vue组件里写的原生addEventListeners监听事件，要手动去销毁吗</h3><p>要 </p>
<p>一方面是绑定多次，另一方面是函数没释放会内存溢出</p>
<h3 id="v-clock和v-pre指令"><a href="#v-clock和v-pre指令" class="headerlink" title="v-clock和v-pre指令"></a>v-clock和v-pre指令</h3><p>v-cloak指令只是在标签中加入一个v-cloak自定义属性，在HTML还编译完成之后该属性会被删除。<br>v-pre可以用来阻止预编译，有v-pre指令的标签内部的内容不会被编译，会原样输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-pre&gt;</span><br><span class="line">    &#123;&#123;showPage&#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/h1&gt;/</span><span class="regexp">/ 仍然是显示的 &#123;&#123;showPage&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="权限指令"><a href="#权限指令" class="headerlink" title="权限指令"></a>权限指令</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'hasPermission'</span>, &#123;</span><br><span class="line">  bind(el, binding, vnode) &#123;</span><br><span class="line">    el.parentNode ? el.parentNode.removeChild(el) : el.style.display = <span class="string">'none'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> permissions = vnode.context.$store.state.account.permissions; <span class="comment">// 存放在vuex</span></span><br><span class="line">    <span class="keyword">if</span> (binding.value === <span class="string">''</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> value = binding.value.split(<span class="string">','</span>)</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!permissions.includes(v)) &#123;</span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">v-hasPermission=<span class="string">"[1,2,3,4,5]"</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>项目踩坑</category>
      </categories>
  </entry>
  <entry>
    <title>使用keepAlive遇到的坑</title>
    <url>/2020/05/25/workspace/Frame/vue/keep-alive/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>使用keepAlive遇到的坑</strong></p>
<p>[[toc]]</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>keep-alive</code>是<code>vue</code>的一个内置组件。它会缓存不活动的<strong>组件实例</strong>，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。它提供了<code>include</code>与<code>exclude</code>属性，允许组件有条件地进行缓存，其中exclude的优先级比include高，max最多可以缓存多少组件实例。</p>
<p><a href="https://cn.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">keep-alive详解文档</a></p>
<p>使用 <code>keep-alive</code>的话会增加两个钩子函数， <code>activated</code> 和 <code>deactivated</code></p>
<p>下面的文章我是<code>keep-alive</code>配合<code>vue-router</code>一块使用的，当前<code>keep-alive</code>也可以缓存单个组件，在这里就不多赘述。</p>
<h2 id="include和exclude"><a href="#include和exclude" class="headerlink" title="include和exclude"></a>include和exclude</h2><p><code>include</code> 和 <code>exclude</code> prop 允许组件有条件地缓存。二者都可以用<code>逗号分隔字符串</code>、<code>正则表达式</code>或一个<code>数组</code>来表示详细健文档</p>
<p>我这里使用的<code>vuex</code>配合数组动态控制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive :include=<span class="string">"includes"</span> exclude=<span class="string">""</span> :max=<span class="string">"10"</span> &gt;</span><br><span class="line">   &lt;router-view/&gt;</span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp"> export default &#123;</span></span><br><span class="line"><span class="regexp">	computed: &#123;</span></span><br><span class="line"><span class="regexp">	  includes() &#123;</span></span><br><span class="line"><span class="regexp">	     return state =&gt; state.router.includes</span></span><br><span class="line"><span class="regexp">	   &#125;</span></span><br><span class="line"><span class="regexp">	&#125;,</span></span><br><span class="line"><span class="regexp">	methods: &#123;</span></span><br><span class="line"><span class="regexp">     changeStoreIncludes() &#123;</span></span><br><span class="line"><span class="regexp">       this.$store.commit('changeIncludes', 'tableLists');</span></span><br><span class="line"><span class="regexp">     &#125;</span></span><br><span class="line"><span class="regexp">   &#125;  </span></span><br><span class="line"><span class="regexp"> &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// vuex</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">	changeIncludes(state, payload) &#123;</span><br><span class="line">	  state.includes = payload</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="include和exclude无效问题"><a href="#include和exclude无效问题" class="headerlink" title="include和exclude无效问题"></a>include和exclude无效问题</h3><p>使用<code>include/exclude</code> 属性需要给所有<code>vue类的name</code>赋值（注意不是给route的name赋值），否则 <code>include/exclude</code>不生效</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"> name:<span class="string">'TableList'</span>, <span class="comment">// include 或 exclude所使用的name</span></span><br><span class="line"> data () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="直接使用v-if做区分"><a href="#直接使用v-if做区分" class="headerlink" title="直接使用v-if做区分"></a>直接使用v-if做区分</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">enter-active-class</span>=<span class="string">"animated zoomInLeft"</span> <span class="attr">leave-active-class</span>=<span class="string">"animated zoomOutRight"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"$route.meta.keepAlive"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">enter-active-class</span>=<span class="string">"animated zoomInLeft"</span> <span class="attr">leave-active-class</span>=<span class="string">"animated zoomOutRight"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"!$route.meta.keepAlive"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样做的话更加简单明了，而且配合动画更搭，不用再<code>vue</code>组件里面声明<code>name</code>，但是要在<code>route</code>的<code>meta</code>里面添加 <code>{keepAlive:true}</code>字段，如果路由是后台控制的话，前端调试就比较鸡肋。</p>
<p><strong>暴露的问题</strong></p>
<p><strong>问题1：</strong></p>
<p>位置公用的问题，当前列表页跳转到详情页面的时候，使用路由回到列表也时候，会出现位置公用的情况。（如果使用浏览器的回退方式，不会出现位置公用的情况。）</p>
<blockquote>
<p><strong>对于这个位置公用的情况，我是一头雾水，期待大佬解答</strong> 🤝，有几点要说的不知对错，待求证。</p>
<ul>
<li><strong>多页面</strong></li>
</ul>
<ol>
<li>如果有数据请求的话，浏览器将会把页面置顶？</li>
<li>如果是静态页面的话，浏览器会滚到你之前滚动的地方？</li>
<li>上面仅仅是使用的浏览器的跳转行为，如果使用href或者路由封装一些方法，则都会置顶？</li>
</ol>
<ul>
<li><strong>求证上面 🤝</strong></li>
</ul>
<ol start="4">
<li>基于SPA模式开发，所以页面仅有一个，实现页面切换是利用哈希与组件的映射关系，vue-router是通过哈希来模拟完整的url，但是对于页面来说仍是一个url，所以在任何一个组件滚动页面，切换到其他组件的时候，页面仍保持滚动之前的状态，这就是出现位置公用的情况.</li>
</ol>
</blockquote>
<p><strong>问题2：</strong></p>
<p>加入有<code>A B C</code>三个页面，我现在只想要<code>A-&gt;B</code>时<code>A</code>缓存，然后<code>B-&gt;A</code>时，展示缓存的页面，<code>C-&gt;A</code>、<code>A-&gt;B-&gt;C-&gt;A</code>等都不要缓存。</p>
<h2 id="scrollBehavior"><a href="#scrollBehavior" class="headerlink" title="scrollBehavior"></a>scrollBehavior</h2><p>对于 <strong><code>问题1</code></strong> 我的想法是，跳转前直接把滚动高度缓存起来，然后每次再回来的时候，在把高度在重新赋值给它，但是如果我页面特别多都需要使用缓存的时候，就有些麻烦，然后我发现路由提供的一个这样的方法。</p>
<p><a href="https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html" target="_blank" rel="noopener">scrollBehavior文档详解</a></p>
<p><strong>scrollBehavior</strong> 方法接收 to 和 from 路由对象。<strong>第三个参数 <code>savedPosition</code></strong> 当且仅当 popstate 导航 (<code>通过浏览器的 前进/后退 按钮触发</code>) 时才可用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'hash'</span>,</span><br><span class="line">  routes,</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="comment">// 此方法默认是检测 document.body 的，如果你是自定义的滚动盒子 是没办法控制你的滚动高度，都是 0</span></span><br><span class="line">    <span class="built_in">console</span>.log(savedPosition);</span><br><span class="line">    <span class="comment">// 如果返回一个 falsy(不是false) ，或者是一个空对象，那么不会发生滚动,说白了就是这个方法没用，并不会在页面顶部</span></span><br><span class="line">    <span class="comment">// falsy文档 https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy</span></span><br><span class="line">    <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">      <span class="keyword">return</span> savedPosition</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">from</span>.meta.keepAlive) &#123;</span><br><span class="line">        <span class="comment">// 这里并不准确，可能我页面滚动的盒子不是body,vue应该有设置的地方</span></span><br><span class="line">        <span class="keyword">from</span>.meta.scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: to.meta.scrollTop || <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版本支持异步滚动，返回一个Promise，这个特别有用，之前的方式如果页面里有异步请求的话，是不能够置顶的</span></span><br><span class="line">scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">  <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(savedPosition)</span><br><span class="line">      &#125;, <span class="number">20</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">from</span>.meta.keepAlive) &#123;</span><br><span class="line">      <span class="keyword">from</span>.meta.scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: to.meta.scrollTop || <span class="number">0</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现返回不刷新、其他菜单进入刷新"><a href="#实现返回不刷新、其他菜单进入刷新" class="headerlink" title="实现返回不刷新、其他菜单进入刷新"></a>实现返回不刷新、其他菜单进入刷新</h2><h3 id="实现方式一"><a href="#实现方式一" class="headerlink" title="实现方式一"></a>实现方式一</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.vue</span></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">   &lt;router-view v-<span class="keyword">if</span>=<span class="string">"$route.meta.keepAlive"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;router-view v-if="!$route.meta.keepAlive" /</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line">&#123;</span><br><span class="line">   path: <span class="string">'/table-list'</span>,</span><br><span class="line">   name: <span class="string">'table-list'</span>,</span><br><span class="line">   component: TableList,</span><br><span class="line">   meta: &#123;<span class="attr">keepAlive</span>: <span class="literal">true</span>&#125; <span class="comment">// 添加这个</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   path: <span class="string">'/table-detail'</span>,</span><br><span class="line">   name: <span class="string">'table-detail'</span>,</span><br><span class="line">   component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/table-detail.vue'</span>),</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>方式一和方式二都是基于上面这两个代码段。</p>
<p>在要缓存的列表页添加下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">activated() &#123;</span><br><span class="line">  <span class="comment">// 如果是第一次进来的时候，就不用执行下面的函数。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.hasFirst) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">this</span>.queryList()</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name === <span class="string">'table-detail'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">from</span>.meta.keepAlive) &#123;</span><br><span class="line">      <span class="keyword">from</span>.meta.keepAlive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">from</span>.meta.keepAlive = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.$destroy(); <span class="comment">//销毁类页表页的实例，有坑</span></span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成上面的代码后，<code>A-&gt;B-&gt;A</code>正常，然后当<code>A-&gt;C-&gt;A-&gt;B-&gt;A</code>发现列表页A不会再缓存了，每次都是新的页面。谷歌后的方法是若不是第一次进入就强制刷新一次缓存页面。<br><strong><code>this.$destroy()</code></strong>  调用<code>distory</code>之后不能再缓存该组件 而且会不断进入这个页面后重复生成多个虚拟dom.</p>
<p>继续完善，在<code>main.js</code>中使用router.afterEach((to,from)=&gt;{})</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原理是如果不是从详情页进来的页面，都需要刷新，否则不能缓存</span></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果当前页面刷新或者从详情也进来，就要执行下面代码，防止执行销毁方法导致不能缓存</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">from</span>.name &amp;&amp; <span class="keyword">from</span>.name !== <span class="string">'table-detail'</span> &amp;&amp; to.name === <span class="string">'table-list'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> isRefresh = sessionStorage.getItem(<span class="string">'isRefresh'</span>)</span><br><span class="line">    <span class="keyword">if</span> (isRefresh === <span class="string">'0'</span>) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">// 这里必须是异步的，不然不能跳转</span></span><br><span class="line">        <span class="built_in">window</span>.location.reload()</span><br><span class="line">      &#125;)</span><br><span class="line">      sessionStorage.setItem(<span class="string">'isRefresh'</span>, <span class="literal">null</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sessionStorage.setItem(<span class="string">'isRefresh'</span>, <span class="string">'0'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">from</span>.name === <span class="string">'table-list'</span> &amp;&amp; to.name === <span class="string">'table-detail'</span>) &#123;</span><br><span class="line">    sessionStorage.setItem(<span class="string">'isRefresh'</span>, <span class="literal">null</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sessionStorage.setItem(<span class="string">'isRefresh'</span>, <span class="string">'0'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我不知道谷歌出来的解决方案为什么都在详情页刷新，这样的问题就是用户第一次跳转到详情页，再回到列表页是没有缓存的功能，第二次就会正常，但是客户很可能就会执行这一次操作；</p>
<p>这种解决方式太过原始，用户体验太差，而且需要缓存多个页面就不太好控制，不建议用这个方法</p>
<h3 id="实现方式二"><a href="#实现方式二" class="headerlink" title="实现方式二"></a>实现方式二</h3><p>灵感来自<code>方式一</code>，我可以其他方式模拟页面刷新。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!--这里一定要使用v-<span class="keyword">if</span>，好处是你可以使用$nextTick体验更好，另一方面是在使用v-show之后，他就相当于隐藏了该页面，但是如果里面有一些不会diff的dom,就会展示出来，模拟刷新的体验就不太好。例如使用 input-&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">if</span>=<span class="string">"isRouterAlive"</span>&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123;ddd&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input v-model="ddd" type="text" /</span>&gt;</span><br><span class="line">        &lt;table-list ref=<span class="string">"table"</span> :multiple=<span class="string">"true"</span> :otherTableParams=<span class="string">"otherTableParams"</span> :tableColumn=<span class="string">"column"</span>/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 其他代码 ........</span></span><br><span class="line">    activated() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.$route.meta.isRefresh) &#123; <span class="comment">// 如果不是跳转到详情页</span></span><br><span class="line">        <span class="keyword">const</span> resetData = <span class="keyword">this</span>.$options.data() <span class="comment">// 获取原来data的数据</span></span><br><span class="line">        <span class="keyword">delete</span> resetData.column  <span class="comment">// 我在这里操作的原因是因为，我通过上面获取的数据里面，用到函数返回的形式，展示为undefined  &#123;cb: this.jumpEdit&#125; 展示为 &#123;cb: this.undefined&#125;,具体原因未知</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">this</span>.$data, resetData) <span class="comment">// 重置data</span></span><br><span class="line">        <span class="keyword">this</span>.isRouterAlive = <span class="literal">false</span> <span class="comment">// 通过v-if不展示当前页面 </span></span><br><span class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">          <span class="built_in">window</span>.scroll(<span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 页面置顶，不要再下面的定时器里面使用，有顿挫感</span></span><br><span class="line">          <span class="keyword">this</span>.isRouterAlive = <span class="literal">true</span> <span class="comment">// 通过v-if展示当前页面 </span></span><br><span class="line">        &#125;)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.queryList() <span class="comment">// 异步获取数据，跟我的项目组件有关，你们可以直接在上面获取就OK</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">      <span class="comment">// 判断如果不是进详情页，展示为true 是页面重新加载的意思</span></span><br><span class="line">      <span class="keyword">from</span>.meta.isRefresh = to.name !== <span class="string">'table-detail'</span>;</span><br><span class="line">      next() <span class="comment">// 不添加路由不会跳转</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>优化</strong><br>现在的代码有两个问题<br><code>一</code>是从详情页到列表页，数据不会更新，如果我在详情页修改了某个数据，然后再到列表页就会滞后;<br><code>二</code>是从详情页跳转到别的列表页然后在跳转到缓存的列表页，然后他还是会缓存之前的数据，不会更新当前页面;</p>
<p>优化如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">activated() &#123;</span><br><span class="line"> <span class="comment">// 如果是第一次进来不执行下面的方法，否则会请求两次数据</span></span><br><span class="line"> <span class="comment">// this.hasFirst 不用生成响应式的，直接一个变量就好</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.hasFirst) <span class="keyword">return</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.$route.meta.isRefresh) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">this</span>.$options.data()</span><br><span class="line">    <span class="keyword">delete</span> data.column</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>.$data, data)</span><br><span class="line">    <span class="keyword">this</span>.isRouterAlive = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.scroll(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">this</span>.isRouterAlive = <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.queryList()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.$route.meta.isRefresh === <span class="literal">false</span>) &#123; </span><br><span class="line">    <span class="comment">// this.$route.meta.isRefresh在路由里面我并没有设置，默认是undefined，当他为false的时候，说明他从别的页面进来了，这个时候让他请求下数据</span></span><br><span class="line">    <span class="keyword">this</span>.queryList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beforeRouteEnter(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line"> <span class="comment">// 这个路由守卫函数式最先执行的</span></span><br><span class="line"> to.meta.isRefresh = <span class="keyword">from</span>.name &amp;&amp; <span class="keyword">from</span>.name !== <span class="string">'table-detail'</span>;</span><br><span class="line">  next()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 下面代码注释即可</span></span><br><span class="line"><span class="comment">// beforeRouteLeave(to, from, next) &#123;</span></span><br><span class="line"><span class="comment">//   from.meta.isRefresh = to.name !== 'table-detail';</span></span><br><span class="line"><span class="comment">//   next()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>最后可以把这些代码抽离成一个<code>mixins</code>,然后编写一个刷新的组件，哪里用在哪里调取下,<a href="/2020/06/15/workspace/Frame/vue/reload/">也可以看这篇文章</a>。</p>
<h3 id="实现方式三"><a href="#实现方式三" class="headerlink" title="实现方式三"></a>实现方式三</h3><p>这种用 <code>keep-alive</code> 提供的 <code>include</code> 和 <code>exclude</code>,然后配合vuex实现动态控制。</p>
<p><strong>路由入口页面</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.vue</span></span><br><span class="line">&lt;keep-alive :include=<span class="string">'includes'</span> :exclude=<span class="string">''</span>:max=<span class="string">"3"</span>&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;<span class="regexp">/router-view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p>其中<code>include</code>代表着要缓存的，<code>exclude</code>代表着非缓存的,<code>max</code>代表最多缓存的个数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取vuex的数据</span></span><br><span class="line"><span class="keyword">import</span> &#123;mapGetters&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;<span class="comment">// 在computed中动态监控</span></span><br><span class="line">     ...mapGetters([<span class="string">'includes'</span>]),</span><br><span class="line">   &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">     changeStore() &#123;</span><br><span class="line">       <span class="comment">// 改变vue的数据，在这用不到</span></span><br><span class="line">       <span class="keyword">this</span>.$store.commit(<span class="string">'change'</span>, <span class="string">'tableLists'</span>)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Vuex</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> keepalive = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    includes: [<span class="string">'tableLists'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    change(state, payload) &#123;</span><br><span class="line">      state.includes = payload</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    includes(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.includes</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> keepalive</span><br></pre></td></tr></table></figure>

<p><strong>列表页的部分代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">activated() &#123;</span><br><span class="line">  <span class="comment">// 同上，如果第一次进来，不执行下面的方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.hasFirst) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">this</span>.queryList()</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteEnter(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// 这个时候还有没this,所以这里用this的话是不能操作vuex,我是在main.js里面赋值给了window</span></span><br><span class="line">  <span class="built_in">window</span>._store.commit(<span class="string">'change'</span>, [<span class="string">'tableLists'</span>]);</span><br><span class="line">  next()</span><br><span class="line">  <span class="comment">// 也可以这么用</span></span><br><span class="line">  <span class="comment">// next((el) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//  el.$store.commit('change', ['tableLists']);</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// 这里可以统一在 scrollBehavior 处理就好了（建议在这里添加 = 参考下面）</span></span><br><span class="line">  <span class="keyword">from</span>.meta.scrollTop = <span class="built_in">document</span>.documentElement.scrollTop; </span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">'table-detail'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果不是跳转到详情页面，就穿个空数组，这里不能用 '' 默认是所有的都缓存</span></span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'change'</span>, []);</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>详情页的部分代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">'table-list'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'change'</span>, []);</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>路由页面</strong></p>
<p>因为includes没有在路由里面定义 keepalive,所以上面的<code>scrollBehavior</code>这个方法当使用合成事件跳转的时候，需要做额外的处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">  <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(savedPosition)</span><br><span class="line">      &#125;, <span class="number">20</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ary = [<span class="string">'Invest'</span>, <span class="string">'Store'</span>];  <span class="comment">// 这里需要缓存的页面的route的name   不是vue类的name</span></span><br><span class="line">    <span class="comment">// 这里列表页跳转到别的页面，也会保留页面的滚动高度但是并没有缓存当前的页面，所以当页面再次返回的时候会重新加载当前页面</span></span><br><span class="line">    <span class="keyword">if</span> (ary.includes(<span class="keyword">from</span>.name)) &#123;</span><br><span class="line">      <span class="comment">/* 最近一次回顾的时候 发现了一个问题</span></span><br><span class="line"><span class="comment">       * 如果是列表页跳转到详情页，这个时候时候其实已经到了详情页面，</span></span><br><span class="line"><span class="comment">       * 如果当当前详情页的页面的高度没有列表页面跳转进来时滚动的高度高的时候，这个时候就会获取不真正的页面高度，然后合成事件回退的时候就会滚动不到跳转前的位置</span></span><br><span class="line"><span class="comment">       * 解决的办法就是在每个页面离开前，获取到页面的高度，存到的meta上，这样既能解决这个问题，也能结局把不是body滚动的情况获取不到滚动高度的问题。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">from</span>.meta.scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: to.meta.scrollTop || <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码比较琐碎，需要添加到每一个页面，所以在实际项目中大家可添加一个keepalive的mixins,方便大家管理。</p>
<p><strong>使用include和exclude的注意点：</strong></p>
<ol>
<li>每个组件内部添加 {name:xx}</li>
<li>若将include设置空 ‘ ‘ 每个页面都将会缓存</li>
<li>exclude的优先级高于include 使用exclude后</li>
</ol>
<hr>
<blockquote>
<p>人生中第一次发布文章，希望大佬们多多指教，</p>
</blockquote>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js" target="_blank" rel="noopener">keep-alive</a></p>
<p><a href="https://github.com/vuejs/vue-router/issues/811" target="_blank" rel="noopener">vueRouterIssues</a></p>
<p><a href="https://github.com/vuejs/vue-router/blob/dev/src/util/scroll.js#L10:1" target="_blank" rel="noopener">scrollBehavior</a></p>
<p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">导航守卫</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>项目踩坑</category>
        <category>keepAlive遇到的坑</category>
      </categories>
  </entry>
  <entry>
    <title>vue之JSX封装table</title>
    <url>/2020/01/17/workspace/Frame/vue/table-jsx/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>vue之JSX封装table</strong></p>
<p>[[toc]]</p>
<p><a href="https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">封装之前先看下</a></p>
<p><a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx" target="_blank" rel="noopener">babel-plugin-transform-vue-jsx</a></p>
<p>基于ElementUI的table二次封装</p>
<p>最近搞中台开发，用的ElementUI的Table组件比较多，几乎每个页面都用，相比react的antd,饿了么的table就相对臃肿了，可能是因为框架的原因吧。</p>
<p>本次封装用的jsx语法，vue模板拓展性不是特别显优势，没有jsx灵活。<a href="/workspace/Frame/vue/jsx.html">想看jsx在vue中怎么使用的请转看下之前的文章</a></p>
<h3 id="组件封装源码"><a href="#组件封装源码" class="headerlink" title="组件封装源码"></a>组件封装源码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EnhanceTable.jsx</span></span><br><span class="line"><span class="keyword">import</span> table <span class="keyword">from</span> <span class="string">"../mixins/table"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mixins: [table],</span><br><span class="line">  props: &#123;</span><br><span class="line">    otherTableParams: &#123; <span class="comment">// 设置table其他参数</span></span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">       <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;; <span class="comment">// Object/Array的属性必须使用函数返回默认值  箭头函数不行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    otherPaginationParams: &#123; <span class="comment">// 设置分页其他参数</span></span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">       <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    tableColumn: &#123; <span class="comment">// table的column</span></span><br><span class="line">      type: <span class="built_in">Array</span>,</span><br><span class="line">       <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    multiple: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleButtons(item, record) &#123;</span><br><span class="line">      <span class="comment">// 处理操作部分按钮 -&gt; 可以在外面自定义，必须是jsx</span></span><br><span class="line">      <span class="keyword">if</span> (item.handleButtons) <span class="keyword">return</span> item.handleButtons(record);</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        !!item.list.length &amp;&amp; item.list.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;el-button</span><br><span class="line">              disabled=&#123;item.disabled&#125;</span><br><span class="line">              key=&#123;item.title&#125;</span><br><span class="line">              type=<span class="string">"text"</span></span><br><span class="line">              size=<span class="string">"small"</span></span><br><span class="line">              style=&#123;item.styles&#125;</span><br><span class="line">              onClick=&#123;() =&gt; item.cb(record)&#125;</span><br><span class="line">            &gt;</span><br><span class="line">              &#123;item.title&#125;</span><br><span class="line">            &lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">          )</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ handleCurrentChange(val) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/   this.$emit('currentChange', val);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ &#125;,</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    const &#123;tableOptions, paginationOptions, paginationOptionsMethod, tableOptionsMethod, otherTableParams, tableColumn, multiple&#125; = this;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;el-table</span></span><br><span class="line"><span class="regexp">          &#123;...&#123;</span></span><br><span class="line"><span class="regexp">            props: &#123;</span></span><br><span class="line"><span class="regexp">              ...tableOptions,</span></span><br><span class="line"><span class="regexp">              ...otherTableParams.props,</span></span><br><span class="line"><span class="regexp">            &#125;,</span></span><br><span class="line"><span class="regexp">            on: &#123;</span></span><br><span class="line"><span class="regexp">              ...tableOptionsMethod,</span></span><br><span class="line"><span class="regexp">              ...otherTableParams.on</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          &#123;/</span>* table多选 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">          &#123;</span></span><br><span class="line"><span class="regexp">            multiple &amp;&amp; (</span></span><br><span class="line"><span class="regexp">              &lt;el-table-column</span></span><br><span class="line"><span class="regexp">                type="selection"</span></span><br><span class="line"><span class="regexp">                width="55"</span></span><br><span class="line"><span class="regexp">                fixed=&#123;'left'&#125;</span></span><br><span class="line"><span class="regexp">              /</span>&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">          &#123;<span class="comment">/* table列表 */</span>&#125;</span><br><span class="line">          &#123;</span><br><span class="line">            tableColumn.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (item.type === <span class="string">'button'</span>) &#123;</span><br><span class="line">                <span class="comment">// 操作部分</span></span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                  &lt;el-table-column</span><br><span class="line">                    label=&#123;item.label || <span class="string">'操作'</span>&#125;</span><br><span class="line">                    width=&#123;item.width || <span class="string">'88'</span>&#125;</span><br><span class="line">                    fixed=&#123;item.fixed || <span class="string">'right'</span>&#125;</span><br><span class="line">                    &#123;...&#123;</span><br><span class="line">                      scopedSlots: &#123;</span><br><span class="line">                        <span class="keyword">default</span>: <span class="function">(<span class="params">&#123;row&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">                          <span class="keyword">return</span> <span class="keyword">this</span>.handleButtons(item, row)</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                  /&gt;</span><br><span class="line">                )</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> (</span><br><span class="line">                &lt;el-table-column</span><br><span class="line">                  props=&#123;item&#125;</span><br><span class="line">                  key=&#123;item.prop&#125;</span><br><span class="line">                  &#123;...&#123;</span><br><span class="line">                    <span class="comment">// 自定义的渲染方式，拓展性</span></span><br><span class="line">                    scopedSlots: &#123;</span><br><span class="line">                      <span class="keyword">default</span>: <span class="function">(<span class="params">&#123;row&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> item.render ? item.render(row[item.prop], row) : row[item.prop]</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">              )</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &lt;<span class="regexp">/el-table&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*分页*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;el-pagination</span></span><br><span class="line"><span class="regexp">          &#123;...&#123;</span></span><br><span class="line"><span class="regexp">            class: paginationOptions.class,  /</span><span class="regexp">/ 支持拓展</span></span><br><span class="line"><span class="regexp">            props: &#123;</span></span><br><span class="line"><span class="regexp">              ...paginationOptions,</span></span><br><span class="line"><span class="regexp">            &#125;,</span></span><br><span class="line"><span class="regexp">            on: &#123;</span></span><br><span class="line"><span class="regexp">              ...paginationOptionsMethod</span></span><br><span class="line"><span class="regexp">            &#125;,</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>

<h3 id="EnhanceTable-文档"><a href="#EnhanceTable-文档" class="headerlink" title="EnhanceTable 文档"></a>EnhanceTable 文档</h3><h3 id="组件使用"><a href="#组件使用" class="headerlink" title="组件使用"></a>组件使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;enhance-table ref=<span class="string">"table"</span> :multiple=<span class="string">"true"</span> :otherTableParams=<span class="string">"otherTableParams"</span> :tableColumn=<span class="string">"column"</span></span><br><span class="line">    /&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  import EnhanceTable from "../</span>components/EnhanceTable<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    data() &#123;</span></span><br><span class="line"><span class="string">      return &#123;</span></span><br><span class="line"><span class="string">        otherTableParams: &#123;// table的参数</span></span><br><span class="line"><span class="string">          props: &#123;</span></span><br><span class="line"><span class="string">            border: true,</span></span><br><span class="line"><span class="string">            stripe: true,</span></span><br><span class="line"><span class="string">            size: 'small',</span></span><br><span class="line"><span class="string">            'default-sort': &#123;prop: 'createTime', order: 'ascending'&#125;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        otherPaginationParams:&#123;&#125;,// 分页的参数</span></span><br><span class="line"><span class="string">        column: [  // table的列</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">            prop: "</span>roleId<span class="string">",</span></span><br><span class="line"><span class="string">            label: "</span>序号<span class="string">",</span></span><br><span class="line"><span class="string">            width: 100,</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">            prop: 'roleName',</span></span><br><span class="line"><span class="string">            label: "</span>角色名称<span class="string">",</span></span><br><span class="line"><span class="string">            'width': "</span><span class="number">110</span><span class="string">"</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">            prop: "</span>createTime<span class="string">",</span></span><br><span class="line"><span class="string">            label: "</span>创建时间<span class="string">",</span></span><br><span class="line"><span class="string">            sortable: true</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">            prop: 'roleName',</span></span><br><span class="line"><span class="string">            label: "</span>角色名称<span class="string">",</span></span><br><span class="line"><span class="string">            //formatter  完全可以用render代替</span></span><br><span class="line"><span class="string">            render: (text, record) =&gt; &#123; // 当前行的值，当前行数据</span></span><br><span class="line"><span class="string">              // console.log(record);</span></span><br><span class="line"><span class="string">              return &lt;h4&gt;&#123;text&#125;&lt;/h4&gt;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">          &#123; // 最后的操作列，可根据list里面展示要操作的按钮，和回调</span></span><br><span class="line"><span class="string">            type: 'button',</span></span><br><span class="line"><span class="string">            width: '118',</span></span><br><span class="line"><span class="string">            label: "</span>设置<span class="string">",</span></span><br><span class="line"><span class="string">            list: [</span></span><br><span class="line"><span class="string">              &#123;title: '查看', disabled: false, styles: &#123;color: '#777'&#125;, cb: this.seeHandle&#125;,</span></span><br><span class="line"><span class="string">              &#123;title: '编辑', cb: this.editHandle&#125;</span></span><br><span class="line"><span class="string">            ],</span></span><br><span class="line"><span class="string">            // handleButtons: () =&gt; (&lt;div&gt;111&lt;/div&gt;)  // 自定义的内容</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    components: &#123;EnhanceTable&#125;,</span></span><br><span class="line"><span class="string">    methods: &#123;</span></span><br><span class="line"><span class="string">      queryList() &#123; // 子组件默认的请求名称</span></span><br><span class="line"><span class="string">        this.$nextTick(async () =&gt; &#123;  </span></span><br><span class="line"><span class="string">          // 因为当前算是父组件，当执行到父组件的created周期才会执行它的子组件，所以这个时候子组件的data的一些方法获取不到，或者可以在mounted周期里面执行异步请求</span></span><br><span class="line"><span class="string">          const &#123;paginationOptions: &#123;pageSize, currentPage&#125;, handlePageData&#125; = this.$refs.table;// 获取子组件mixins里面的参数</span></span><br><span class="line"><span class="string">          const &#123;data: &#123;items, page: &#123;totalRecord&#125;&#125;&#125; = </span></span><br><span class="line"><span class="string">          await this.$fetch(`http://xx..xx/role?pageSize=$&#123;pageSize&#125;&amp;pageNum=$&#123;currentPage&#125;`, &#123;</span></span><br><span class="line"><span class="string">            headers: &#123;</span></span><br><span class="line"><span class="string">              Authentication: 'xxxxx'</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">          &#125;);</span></span><br><span class="line"><span class="string">          handlePageData(items, totalRecord);  // mixin里面统一处理</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      editHandle(...options) &#123;</span></span><br><span class="line"><span class="string">        console.log(options, '编辑');</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      seeHandle(...options) &#123;</span></span><br><span class="line"><span class="string">        console.log(options, '查看');</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    created() &#123;</span></span><br><span class="line"><span class="string">      this.queryList();//必须是这个名称 </span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    mounted() &#123;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;style type="</span>text/scss<span class="string">" lang="</span>scss<span class="string">" scoped&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="最后在送一个当前使用的mixins"><a href="#最后在送一个当前使用的mixins" class="headerlink" title="最后在送一个当前使用的mixins"></a>最后在送一个当前使用的mixins</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// table.mixins.js</span></span><br><span class="line"><span class="keyword">const</span> table = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      tableOptions: &#123;</span><br><span class="line">        data: [], <span class="comment">// 列表数据</span></span><br><span class="line">        border: <span class="literal">true</span>, <span class="comment">// 带边框</span></span><br><span class="line">        style: <span class="string">"width: 100%"</span>,</span><br><span class="line">        size: <span class="string">"small"</span>,</span><br><span class="line">        multipleSelection: [], <span class="comment">// 列表多选</span></span><br><span class="line">      &#125;,</span><br><span class="line">      tableOptionsMethod: &#123;</span><br><span class="line">        <span class="string">"selection-change"</span>: <span class="keyword">this</span>.handleSelectionChange</span><br><span class="line">      &#125;,</span><br><span class="line">      paginationOptions: &#123;</span><br><span class="line">        class: "fyDiv",</span><br><span class="line">        background: <span class="literal">true</span>, <span class="comment">// 带有背景色</span></span><br><span class="line">        layout: <span class="string">"total, sizes, prev, pager, next"</span>,</span><br><span class="line">        pageSizes: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>],</span><br><span class="line">        total: <span class="number">0</span>, <span class="comment">// 应用列表总数量</span></span><br><span class="line">        pageSize: <span class="number">10</span>, <span class="comment">// 当前分页数量</span></span><br><span class="line">        currentPage: <span class="number">1</span>, <span class="comment">// 当前页数第一页</span></span><br><span class="line">        showPage: <span class="literal">false</span>, <span class="comment">// 是否显示分页组件,必须total总数也要小于当前要展示的页数</span></span><br><span class="line">      &#125;,</span><br><span class="line">      paginationOptionsMethod: &#123;</span><br><span class="line">        <span class="string">"size-change"</span>: <span class="keyword">this</span>.handleSizeChange,</span><br><span class="line">        <span class="string">"current-change"</span>: <span class="keyword">this</span>.handleCurrentChange</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 获取数据回调处理分页和data</span></span><br><span class="line">    handlePageData(data, total) &#123;</span><br><span class="line">      <span class="keyword">this</span>.tableOptions.data = data;</span><br><span class="line">      <span class="comment">// 如果还有下一页，则显示分页插件</span></span><br><span class="line">      <span class="keyword">if</span> (total &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.paginationOptions.showPage = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.paginationOptions.showPage = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.paginationOptions.currentPage = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.paginationOptions.pageSize = <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.paginationOptions.total = total;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 选项变化</span></span><br><span class="line">    handleSelectionChange(multipleSelection) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(multipleSelection, <span class="string">"选中"</span>);</span><br><span class="line">      <span class="keyword">this</span>.tableOptions.multipleSelection = multipleSelection;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 改变页数</span></span><br><span class="line">    handleCurrentChange(currentPage) &#123;</span><br><span class="line">      <span class="keyword">this</span>.paginationOptions.currentPage = currentPage;</span><br><span class="line">      <span class="keyword">this</span>.queryList ? <span class="keyword">this</span>.queryList() : <span class="keyword">this</span>.$parent.queryList();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 选择页数</span></span><br><span class="line">    handleSizeChange(currentSize) &#123;</span><br><span class="line">      <span class="keyword">this</span>.paginationOptions.pageSize = currentSize;</span><br><span class="line">      <span class="keyword">this</span>.paginationOptions.currentPage = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">this</span>.queryList ? <span class="keyword">this</span>.queryList() : <span class="keyword">this</span>.$parent.queryList();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 搜索专用</span></span><br><span class="line">    handleSearchChange(page = <span class="number">1</span>, size = <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.paginationOptions.pageSize = size;</span><br><span class="line">      <span class="keyword">this</span>.paginationOptions.currentPage = page;</span><br><span class="line">      <span class="keyword">this</span>.queryList ? <span class="keyword">this</span>.queryList() : <span class="keyword">this</span>.$parent.queryList();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> table;</span><br></pre></td></tr></table></figure>

<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>当前的table组件是针对自己项目的需求封装，兼容了饿了么table大部分的业务场景，随着后期的业务拓展，当前的组件的拓展性也会增强，封装路漫漫，一点点完善吧。</p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>组件封装</category>
        <category>Vue之JSX封装Table</category>
      </categories>
  </entry>
  <entry>
    <title>Element-UI ，Table组件实现拖拽效果</title>
    <url>/2020/08/20/workspace/Frame/vue/sortable/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Element-UI ，Table组件实现拖拽效果</strong></p>
<p>最近业务需求要添加table的拖拽，但是element并没有table的拖拽功能，只能自己添加了。</p>
<p>找了两个组价库<code>sortablejs</code>和<code>vuedraggable</code>,后者是基于前者实现的更加符合vue标准的库，依赖于前者，但是项目中用的element的table, <code>vuedraggable</code>在这个基础上就不能使用，看<a href="https://github.com/SortableJS/Vue.Draggable/blob/master/example/components/table-example.vue" target="_blank" rel="noopener">官方的示例</a> , 所以只能使用<code>sortablejs</code>了，我直接安装了<code>vuedraggable</code>，它依赖<code>sortablejs</code>可以直接使用里面的特性，万一后期再有其他拖拽的功能，这个库上手还比较方便。</p>
<h3 id="Sortable使用示例"><a href="#Sortable使用示例" class="headerlink" title="Sortable使用示例"></a>Sortable使用示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;el-card v-loading=<span class="string">"fullscreenLoading"</span>&gt;</span><br><span class="line">        &lt;el-table</span><br><span class="line">                :data=<span class="string">"tableOptions.data"</span></span><br><span class="line">                border</span><br><span class="line">                size=<span class="string">"small"</span></span><br><span class="line">                row-key=<span class="string">'roleId'</span></span><br><span class="line">                ref=<span class="string">"table"</span></span><br><span class="line">                @cell-mouse-enter.once=<span class="string">'rowDrop'</span></span><br><span class="line">        &gt;</span><br><span class="line">            &lt;el-table-column</span><br><span class="line">                    prop=<span class="string">"sort"</span></span><br><span class="line">                    label=<span class="string">"拖拽区域"</span></span><br><span class="line">            &gt;</span><br><span class="line">                &lt;template slot-scope=<span class="string">"scope"</span>&gt;</span><br><span class="line">                    &lt;el-button type=<span class="string">"text"</span> size=<span class="string">"small"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"handle"</span>&gt;按住拖拽&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>template&gt;</span><br><span class="line">            &lt;<span class="regexp">/el-table-column&gt;</span></span><br><span class="line"><span class="regexp">            &lt;el-table-column</span></span><br><span class="line"><span class="regexp">                    v-for="item of column"</span></span><br><span class="line"><span class="regexp">                    :key="item.prop"</span></span><br><span class="line"><span class="regexp">                    :prop="item.prop"</span></span><br><span class="line"><span class="regexp">                    :label="item.label"</span></span><br><span class="line"><span class="regexp">                    :width="item.width"</span></span><br><span class="line"><span class="regexp">                    :fixed="item.fixed"</span></span><br><span class="line"><span class="regexp">            /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/el-table&gt;</span></span><br><span class="line"><span class="regexp">        &lt;el-pagination</span></span><br><span class="line"><span class="regexp">                background</span></span><br><span class="line"><span class="regexp">                :hide-on-single-page="paginationOptions.showPage"</span></span><br><span class="line"><span class="regexp">                :layout="paginationOptions.layout"</span></span><br><span class="line"><span class="regexp">                :page-sizes="paginationOptions.pageSizes"</span></span><br><span class="line"><span class="regexp">                :total="paginationOptions.total"</span></span><br><span class="line"><span class="regexp">                :page-size="paginationOptions.pageSize"</span></span><br><span class="line"><span class="regexp">                :current-page="paginationOptions.currentPage"</span></span><br><span class="line"><span class="regexp">                @size-change="handleSizeChange"</span></span><br><span class="line"><span class="regexp">                @current-change="handleCurrentChange"</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/el-card&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> Sortable <span class="keyword">from</span> <span class="string">'sortablejs'</span>;</span><br><span class="line">  <span class="keyword">import</span> table <span class="keyword">from</span> <span class="string">"@/mixins/table"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'TableDraggable'</span>,</span><br><span class="line">    mixins: [table],</span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        column: [</span><br><span class="line">          &#123;</span><br><span class="line">            prop: <span class="string">"roleId"</span>,</span><br><span class="line">            label: <span class="string">"序号"</span>,</span><br><span class="line">            width: <span class="number">100</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            prop: <span class="string">'roleName'</span>,</span><br><span class="line">            label: <span class="string">"角色名称"</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            prop: <span class="string">"createTime"</span>,</span><br><span class="line">            label: <span class="string">"创建时间"</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            prop: <span class="string">"roleId"</span>,</span><br><span class="line">            label: <span class="string">"序号"</span>,</span><br><span class="line">            width: <span class="number">100</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            prop: <span class="string">'edit'</span>,</span><br><span class="line">            label: <span class="string">"编辑"</span>,</span><br><span class="line">            width: <span class="number">180</span>,</span><br><span class="line">            fixed: <span class="string">'right'</span></span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">        fullscreenLoading: <span class="literal">true</span>,</span><br><span class="line">        paginationOptions: &#123;</span><br><span class="line">          pageSizes: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      <span class="string">'tableOptions.data'</span>: &#123;</span><br><span class="line">        deep: <span class="literal">true</span>,</span><br><span class="line">        handler: <span class="function"><span class="keyword">function</span> (<span class="params">newData</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// console.log(newData);  // 可以发现每次拖拽后数据发生了改变</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="comment">//行拖拽</span></span><br><span class="line">      rowDrop() &#123;</span><br><span class="line">        <span class="keyword">const</span> tbody = <span class="keyword">this</span>.$refs.table.$el.querySelector(<span class="string">'.el-table__body-wrapper tbody'</span>);</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        Sortable.create(tbody, &#123;</span><br><span class="line">          handle: <span class="string">'.handle'</span>,</span><br><span class="line">          animation: <span class="number">150</span>,</span><br><span class="line">          onChoose() &#123;</span><br><span class="line">            <span class="comment">//选择元素</span></span><br><span class="line">            _this.column[_this.column.length - <span class="number">1</span>].fixed = <span class="literal">false</span></span><br><span class="line">          &#125;,</span><br><span class="line">          onUnchoose: <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 取消选择元素</span></span><br><span class="line">            _this.column[_this.column.length - <span class="number">1</span>].fixed = <span class="string">'right'</span></span><br><span class="line"></span><br><span class="line">          &#125;,</span><br><span class="line">          onEnd(&#123;newIndex, oldIndex&#125;) &#123;</span><br><span class="line">            <span class="comment">// 拖拽完成</span></span><br><span class="line">            <span class="keyword">const</span> currRow = _this.tableOptions.data.splice(oldIndex, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">            _this.tableOptions.data.splice(newIndex, <span class="number">0</span>, currRow)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style type="text/</span>scss<span class="string">" lang="</span>scss<span class="string">" scoped&gt;</span></span><br><span class="line"><span class="string">    .handle &#123;</span></span><br><span class="line"><span class="string">        cursor: move</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ::v-deep .hover-row &gt; td &#123;</span></span><br><span class="line"><span class="string">        background-color: #fff !important;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ::v-deep .sortable-chosen &gt; td &#123;</span></span><br><span class="line"><span class="string">        // 拖动的样式</span></span><br><span class="line"><span class="string">        background-color: #eff2f6 !important;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ::v-deep .el-table--enable-row-hover .el-table__body tr:hover &gt; td &#123;</span></span><br><span class="line"><span class="string">        // 修复拖拽的时候hover的不消失的问题</span></span><br><span class="line"><span class="string">        background-color: #fff;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>上面的代码有一些注意的地方我一一列举下来</strong></p>
<ol>
<li>element table务必指定<code>row-key</code>，row-key必须是唯一的，不然会出现排序不对的情况。</li>
<li>我在table里面使用了<strong>fixed</strong>，最后一列是固定在右侧，用过element的知道这是两个table的拼接成的，所以拖拽是没有反应的<ol>
<li>以因为上面我们有指定row-key，所以拖拽后不会出现错位的情况，但是在拖拽的时候，是有很明显的错位出现。</li>
<li>我解决的思路是在拖拽的时候先把这个固定取消<code>onChoose</code>,然后拖拽完成后在把固定加上<code>onUnchoose</code>,具体看两个方法的代码</li>
</ol>
</li>
<li>样式table会有鼠标滑过的效果，但是使用拖拽后，鼠标滑过后的效果不消失，甚至会出现很多个鼠标滑过的效果，解决的方式比较粗暴，我是把所有的滑过的效果全部取消了，谁有更好的方案欢迎评论区留言。<ol>
<li>不使用<code>fixed</code>,可以防止2、3问题</li>
</ol>
</li>
<li><code>mounted</code>生命周期调取的<code>rowDrop</code>方法，会出现的问题是，如果在<code>created</code>调取的接口量大在<code>mounted</code>周期可能不能更好的渲染完成，此时将获取不到<code>tbody</code>,所以这里我的解决办法就是使用,table组件自带的<code>@cell-mouse-enter.once=&#39;rowDrop&#39;</code>，hover滑过的时候完成初始化，加上once是他只需要执行一次，或者更粗暴的办法直接使用定时器。</li>
</ol>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://sortablejs.github.io/Vue.Draggable/#/table-example" target="_blank" rel="noopener">draggable</a></p>
<p><a href="https://github.com/SortableJS/Sortable" target="_blank" rel="noopener">sortable</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>组件封装</category>
        <category>Table组件实现拖拽效果</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Vue的组件局部刷新</title>
    <url>/2020/06/15/workspace/Frame/vue/reload/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>基于Vue的组件局部刷新</strong></p>
<p>之前做keepalive，组件destroy销毁后，就不会缓存该页面了，解决的办法就是刷新当前的页面，一种是原始的刷新方式，一种就是基于框架本身的局部刷新，今天完善下基于vue的局部刷新。</p>
<p>我上次省事在做keepalive的时候，直接在页面内部做的局部刷新，具体看<a href="https://juejin.im/post/6844904178926485511#heading-7" target="_blank" rel="noopener">这大概是最全乎的keep-alive踩坑指南</a> ,实现的思路就是重置所有的data,然后在配合v-if,就能做到局部的刷新，然后可以自己定义一个mixins代码也是很简洁的，但是还是要每次都引入mixins,现在用另一种方式重新优化，原理跟上面的那个方法类似。</p>
<p><strong>第一步 : 在 app.vue 中定义全局方法:如下</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;router-view v-<span class="keyword">if</span>=<span class="string">"isRouterAlive"</span>/&gt;    <span class="comment">//通过v-if来控制容器的出现与消失</span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'App'</span>,</span><br><span class="line">  provide()&#123;</span><br><span class="line">    <span class="comment">// 通过provide传递给子代，谁需要谁获取下就OK了</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      reload:<span class="keyword">this</span>.reload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      isRouterAlive: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">   reload () &#123;</span><br><span class="line">     <span class="keyword">this</span>.isRouterAlive = <span class="literal">false</span></span><br><span class="line">     <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> (<span class="keyword">this</span>.isRouterAlive = <span class="literal">true</span>))</span><br><span class="line">   &#125;   </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们定义了全局的方法 reload( ); 原理就是通过控制组件容器的出现与消失, 达到重新渲染的效果 , 从而实现我们的目的;</p>
<p><strong>第二步:在全局中定义了刷新的方法, 接下来就是要引入到需要刷新的组件中:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inject:[<span class="string">"reload"</span>],</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.reload();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>



<p>通过 <strong>inject 方法</strong>引入到需要的组件中, 直接<strong>this.reload()</strong> 调用这个方法即可.</p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>基于Vue的组件局部刷新</category>
      </categories>
  </entry>
  <entry>
    <title>封装树形菜单</title>
    <url>/2020/01/17/workspace/Frame/vue/tree-menu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>封装树形菜单</strong></p>
<p>之前面试有让用react做过一次 ，今天仿造elementUI用Vue在做一个</p>
<p><strong>老套路先看看怎么使用的</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体使用</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"test"</span>&gt;</span><br><span class="line">    &lt;trees :data=<span class="string">"treeData"</span> :treeProps=<span class="string">"treeProps"</span>&gt;&lt;<span class="regexp">/trees&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  import trees from "./</span>../test/index<span class="string">";</span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    data() &#123;</span></span><br><span class="line"><span class="string">      return &#123;</span></span><br><span class="line"><span class="string">        treeProps: &#123;</span></span><br><span class="line"><span class="string">          children: 'children',</span></span><br><span class="line"><span class="string">          label: 'name'</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        treeData: [&#123;</span></span><br><span class="line"><span class="string">            name: "</span>一级 <span class="number">1</span><span class="string">",</span></span><br><span class="line"><span class="string">            children: [&#123;</span></span><br><span class="line"><span class="string">              name: "</span>二级 <span class="number">1</span><span class="number">-1</span><span class="string">",</span></span><br><span class="line"><span class="string">              children: [&#123;</span></span><br><span class="line"><span class="string">                name: "</span>三级 <span class="number">1</span><span class="number">-1</span><span class="number">-1</span><span class="string">"</span></span><br><span class="line"><span class="string">              &#125;]</span></span><br><span class="line"><span class="string">            &#125;]</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">            name: "</span>一级 <span class="number">2</span><span class="string">",</span></span><br><span class="line"><span class="string">            children: [&#123;</span></span><br><span class="line"><span class="string">                name: "</span>二级 <span class="number">2</span><span class="number">-1</span><span class="string">",</span></span><br><span class="line"><span class="string">                children: [&#123;</span></span><br><span class="line"><span class="string">                  name: "</span>三级 <span class="number">2</span><span class="number">-1</span><span class="number">-1</span><span class="string">"</span></span><br><span class="line"><span class="string">                &#125;]</span></span><br><span class="line"><span class="string">              &#125;,</span></span><br><span class="line"><span class="string">              &#123;</span></span><br><span class="line"><span class="string">                name: "</span>二级 <span class="number">2</span><span class="number">-2</span><span class="string">",</span></span><br><span class="line"><span class="string">                children: [&#123;</span></span><br><span class="line"><span class="string">                  name: "</span>三级 <span class="number">2</span><span class="number">-2</span><span class="number">-1</span><span class="string">"</span></span><br><span class="line"><span class="string">                &#125;]</span></span><br><span class="line"><span class="string">              &#125;</span></span><br><span class="line"><span class="string">            ]</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">            name: "</span>一级 <span class="number">3</span><span class="string">",</span></span><br><span class="line"><span class="string">            children: [&#123;</span></span><br><span class="line"><span class="string">                name: "</span>二级 <span class="number">3</span><span class="number">-1</span><span class="string">",</span></span><br><span class="line"><span class="string">                children: [&#123;</span></span><br><span class="line"><span class="string">                  name: "</span>三级 <span class="number">3</span><span class="number">-1</span><span class="number">-1</span><span class="string">"</span></span><br><span class="line"><span class="string">                &#125;]</span></span><br><span class="line"><span class="string">              &#125;,</span></span><br><span class="line"><span class="string">              &#123;</span></span><br><span class="line"><span class="string">                name: "</span>二级 <span class="number">3</span><span class="number">-2</span><span class="string">",</span></span><br><span class="line"><span class="string">                children: [&#123;</span></span><br><span class="line"><span class="string">                  name: "</span>三级 <span class="number">3</span><span class="number">-2</span><span class="number">-1</span><span class="string">"</span></span><br><span class="line"><span class="string">                &#125;]</span></span><br><span class="line"><span class="string">              &#125;</span></span><br><span class="line"><span class="string">            ]</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    components: &#123;</span></span><br><span class="line"><span class="string">      trees</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>子组件的封装</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 菜单节点</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;span @click=<span class="string">"toggle"</span> &gt;</span><br><span class="line">            &lt;span v-<span class="keyword">if</span>=<span class="string">"hasChild"</span> &gt;&#123;&#123;isOpen ? <span class="string">'down'</span> : <span class="string">'up'</span>&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;!-- 末菜单 --&gt;</span></span><br><span class="line"><span class="regexp">            &lt;span v-if="!hasChild" &gt;'='&lt;/</span>span&gt; </span><br><span class="line">            &#123;&#123; data[treeProps.label] &#125;&#125;</span><br><span class="line">        &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 如果还有子集菜单，继续递归</span></span><br><span class="line"><span class="regexp">        &lt;ul v-show="isOpen" v-if="hasChild"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;tree-item v-for="(item, index) in data[treeProps.children]" :data="item" :key="index" :treeProps="treeProps" &gt;&lt;/</span>tree-item&gt;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    name: 'TreeItem', /</span><span class="regexp">/递归组件必须有name</span></span><br><span class="line"><span class="regexp">    props: &#123;</span></span><br><span class="line"><span class="regexp">        data: &#123;</span></span><br><span class="line"><span class="regexp">            type: [Object, Array], /</span><span class="regexp">/多个可能的类型</span></span><br><span class="line"><span class="regexp">            required: true</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ label、children 默认值</span></span><br><span class="line"><span class="regexp">      treeProps:&#123;</span></span><br><span class="line"><span class="regexp">          type:Object,</span></span><br><span class="line"><span class="regexp">          default:()=&gt;(&#123;</span></span><br><span class="line"><span class="regexp">            children:'children',</span></span><br><span class="line"><span class="regexp">            label:'label'</span></span><br><span class="line"><span class="regexp">          &#125;)</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    data() &#123;</span></span><br><span class="line"><span class="regexp">        return &#123;</span></span><br><span class="line"><span class="regexp">            isOpen: false,</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    computed: &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 判断当前级别是否还有children</span></span><br><span class="line"><span class="regexp">        hasChild() &#123;</span></span><br><span class="line"><span class="regexp">            return this.data[this.treeProps.children] &amp;&amp; this.data[this.treeProps.children].length</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 点击子菜单也要判断是否有children，有就展开</span></span><br><span class="line"><span class="regexp">        toggle() &#123;</span></span><br><span class="line"><span class="regexp">            if(this.hasChild) &#123;</span></span><br><span class="line"><span class="regexp">                this.isOpen = !this.isOpen</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">ul &#123;</span><br><span class="line">    list-style: none;</span><br><span class="line">    margin: <span class="number">10</span>px <span class="number">0</span>;</span><br><span class="line">    padding-left: <span class="number">20</span>px;</span><br><span class="line">&#125;</span><br><span class="line">li &#123;</span><br><span class="line">      color: #000;</span><br><span class="line">&#125;</span><br><span class="line">li &gt; span &#123;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    font-size: <span class="number">14</span>px;</span><br><span class="line">    line-height: <span class="number">20</span>px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 菜单标题</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul v-<span class="keyword">for</span>=<span class="string">"(item,index) in data"</span> :key=<span class="string">"index"</span>&gt;</span><br><span class="line">      &lt;tree-item :data=<span class="string">"item"</span> :treeProps=<span class="string">"treeProps"</span>&gt;&lt;<span class="regexp">/tree-item&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> treeItem <span class="keyword">from</span> <span class="string">'./item'</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        type: [<span class="built_in">Object</span>, <span class="built_in">Array</span>],</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      treeProps: &#123;</span><br><span class="line">        type: <span class="built_in">Object</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">          children: <span class="string">'children'</span>,</span><br><span class="line">          label: <span class="string">'label'</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      treeItem</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>跟react大同小异，依旧是用了递归的思想，不过vue的这个组件自身递归看的很新奇。</p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>组件封装</category>
        <category>封装树形菜单</category>
      </categories>
  </entry>
  <entry>
    <title>vue中使用JSX</title>
    <url>/2020/02/17/workspace/Frame/vue/jsx/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>vue中使用JSX</strong></p>
<p>[[toc]]</p>
<h3 id="vue中使用JSX"><a href="#vue中使用JSX" class="headerlink" title="vue中使用JSX"></a>vue中使用JSX</h3><p><strong>Template</strong></p>
<ul>
<li>学习成本低</li>
<li>大量内置指令简化开发</li>
<li>组件作用域css</li>
<li>但灵活性低</li>
</ul>
<p><strong>JSX</strong></p>
<ul>
<li>灵活</li>
<li>JSX更易读也是 JavaScript。</li>
<li>JSX使自定义Vue组件更容易导入和管理,导入直接使用，不用再通过components了</li>
</ul>
<p>可以例子可以看出jsx的写法，比较干净，可读性高</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;textarea v-<span class="keyword">if</span>=<span class="string">"multiline"</span> v-model=<span class="string">"content"</span> :name=<span class="string">"name"</span> :placeholder=<span class="string">"placeholder"</span> :aria-invalid=<span class="string">"false"</span>&gt;</span><br><span class="line">  &lt;input v-<span class="keyword">else</span> v-model=<span class="string">"content"</span> :name=<span class="string">"name"</span> :placeholder=<span class="string">"placeholder"</span> :aria-invalid=<span class="string">"false"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">render (createElement) &#123;</span></span><br><span class="line"><span class="regexp">    const inputAttributes = &#123;</span></span><br><span class="line"><span class="regexp">        class: 'input-field has-outline',</span></span><br><span class="line"><span class="regexp">        onClick: this.handleClick,</span></span><br><span class="line"><span class="regexp">        placeholder: 'placeholder',</span></span><br><span class="line"><span class="regexp">        value:this.value,</span></span><br><span class="line"><span class="regexp">        onchange:()=&gt;&#123;&#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    const inputMarkup = this.multiline</span></span><br><span class="line"><span class="regexp">        ? &lt;textarea &#123;...inputAttributes&#125;&gt;&lt;/</span>textarea&gt;</span><br><span class="line">        : <span class="xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...inputAttributes</span>&#125;/&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> inputMarkup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置vue以使用JSX"><a href="#配置vue以使用JSX" class="headerlink" title="配置vue以使用JSX"></a>配置vue以使用JSX</h3><p>如果使用的Vue-cli大于或等于 3.0 版本，那么就直接可以使用JSX的语法了。</p>
<p>如果您使用的是不支持 <code>JSX</code> 的<code>Vue-cli</code>较旧版本，则可以通过安装<code>babel-preset-vue-app</code>来添加它，并将其添加到您的<code>.babelrc</code>文件中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn add  babel-preset-vue-app -D</span><br></pre></td></tr></table></figure>

<p>在<code>.babelrc</code>文件中，添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">"presets"</span>: [<span class="string">"vue-app"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在可以在组件的render函数中使用JSX。</p>
<h3 id="使用JSX需要注意的"><a href="#使用JSX需要注意的" class="headerlink" title="使用JSX需要注意的"></a>使用JSX需要注意的</h3><h4 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h4><p>slot 是挂在 <code>this.$slots</code> 的这个属性上的，this.$slot[‘property’] 可以直接拿到slot的vNode,也可以通过数组索引拿到（不推荐）</p>
<p>所以，jsx 中，通过访问this.$slots来代替 slot 的定义:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件：parent.jsx</span></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;child&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        I am the slot</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &lt;div slot='namedSlot'&gt;I am the named slot&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/child&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件：child.jsx</span></span><br><span class="line"><span class="regexp">render() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div class='child'&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span&gt;I am a component&lt;/</span>span&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">this</span>.$slots.default</span><br><span class="line">      &#125;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">this</span>.$slots.default[<span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">this</span>.$slots.namedSlot</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="scoped-slots"><a href="#scoped-slots" class="headerlink" title="scoped slots"></a>scoped slots</h4><p><code>scopedSlot</code> 是挂在 <code>this.$scopedSlots</code> 的这个属性上的，<code>this.$scopedSlots[&#39;property&#39;]</code> 可以直接拿到一个函数，这个函数的参数就是 <code>scopeSlots</code> 外传的数据，返回值是VNode.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件：parent.jsx</span></span><br><span class="line">&lt;child</span><br><span class="line">    scopedSlots=&#123;&#123;</span><br><span class="line">        <span class="keyword">default</span>: <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;div style=<span class="string">"line-height: 30px;"</span>&gt;</span><br><span class="line">                    &#123;props.info.title&#125;</span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            );</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        other: props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            return (</span></span><br><span class="line"><span class="regexp">                &lt;div style="line-height: 30px;"&gt;</span></span><br><span class="line"><span class="regexp">                    &#123;props.info.title&#125;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>div&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line"><span class="comment">// 子组件：child.jsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            info: &#123;</span><br><span class="line">                title: <span class="string">"标题一"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            info2: &#123;</span><br><span class="line">                title: <span class="string">"标题二"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.$scopedSlots.default(&#123;</span><br><span class="line">                    info: <span class="keyword">this</span>.info</span><br><span class="line">                &#125;)&#125;</span><br><span class="line"></span><br><span class="line">                &#123;<span class="keyword">this</span>.$scopedSlots.other(&#123;</span><br><span class="line">                    info: <span class="keyword">this</span>.info2</span><br><span class="line">                &#125;)&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>

<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>要监听 <code>JSX</code> 中的事件，我们需要“on”前缀。 例如，将<code>onClick</code>用于单击事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render (createElement) &#123;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">     &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"> )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>要阻止默认事件，请使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render (createElement) &#123;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">     &lt;button onClick:prevent=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"> )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p>v-model 实际上就是一个语法糖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Component v-model=<span class="string">'test'</span>&gt;&lt;<span class="regexp">/Component&gt;</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;component :value=<span class="string">'test'</span> @input=<span class="string">'test = arguments[0]'</span>&gt;&lt;<span class="regexp">/component&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用jsx写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;component</span><br><span class="line">  value=&#123; <span class="keyword">this</span>.test &#125;</span><br><span class="line">  onInput=&#123; val =&gt; &#123; <span class="keyword">this</span>.test = val &#125; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&lt;<span class="regexp">/component&gt;</span></span><br></pre></td></tr></table></figure>

<p>vue-cli默认搭建的脚手架时配置好这个plugin的，可直接使用<code>v-model</code></p>
<p><a href="https://github.com/nickmessing/babel-plugin-jsx-v-model" target="_blank" rel="noopener">可以通过这个plugin,在vue jsx里写v-model的s语法</a></p>
<h4 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title="sync 修饰符"></a>sync 修饰符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;comp :foo.sync=<span class="string">"bar"</span>&gt;&lt;<span class="regexp">/comp&gt;</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;component  visible=&#123;dialogFormVisible&#125;</span><br><span class="line">            &#123;...&#123;<span class="attr">on</span>: &#123;<span class="string">'update:visible'</span>: <span class="keyword">this</span>.handelVisible&#125;&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure>
<p>其实会被拓展为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;comp :foo=<span class="string">"bar"</span> @update:foo=<span class="string">"val =&gt; bar = val"</span>&gt;&lt;<span class="regexp">/comp&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 更新的时候</span></span><br><span class="line"><span class="regexp">this.$emit('update:foo', newValue)</span></span><br></pre></td></tr></table></figure>

<p>使用jsx写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;component</span><br><span class="line">  foo=&#123; <span class="keyword">this</span>.bar &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    on: &#123;</span><br><span class="line">      <span class="string">'update:foo'</span>: <span class="function"><span class="params">val</span> =&gt;</span> <span class="keyword">this</span>.bar = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&gt;</span><br><span class="line">&lt;<span class="regexp">/component&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/nickmessing" target="_blank" rel="noopener">在jsx里面直接用.sync的方法</a></p>
<h4 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h4><p>将HTML字符串设置为元素的内容，使用domPropsInnerHTML而不是使用v-html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render (createElement) &#123;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">     &lt;button domPropsInnerHTML=&#123;htmlContent&#125;&gt;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"> )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="可以使用拓展运算符"><a href="#可以使用拓展运算符" class="headerlink" title="可以使用拓展运算符"></a>可以使用拓展运算符</h4><p>我们也可以展开一个大对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render (createElement) &#123;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">     &lt;button &#123;...this.largeProps&#125;&gt;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"> )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="用好jsx需要知道的"><a href="#用好jsx需要知道的" class="headerlink" title="用好jsx需要知道的**"></a>用好jsx需要知道的**</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render (h) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div</span><br><span class="line">      id&#x3D;&quot;foo&quot;</span><br><span class="line">      domPropsInnerHTML&#x3D;&quot;bar&quot;</span><br><span class="line">      onClick&#x3D;&#123;this.clickHandler&#125;</span><br><span class="line">      nativeOnClick&#x3D;&#123;this.nativeClickHandler&#125;</span><br><span class="line">      class&#x3D;&#123;&#123; foo: true, bar: false &#125;&#125;</span><br><span class="line">      style&#x3D;&#123;&#123; color: &#39;red&#39;, fontSize: &#39;14px&#39; &#125;&#125;</span><br><span class="line">      key&#x3D;&quot;key&quot;</span><br><span class="line">      ref&#x3D;&quot;ref&quot;</span><br><span class="line">      refInFor</span><br><span class="line">      slot&#x3D;&quot;slot&quot; &#x2F;&gt;</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render (h) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">'div'</span>, &#123;</span><br><span class="line">      props: &#123; <span class="comment">// 组件的参数</span></span><br><span class="line">        msg: <span class="string">'hi'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      attrs: &#123; </span><br><span class="line">        id: <span class="string">'foo'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      domProps: &#123; </span><br><span class="line">        innerHTML: <span class="string">'bar'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      on: &#123; <span class="comment">// 一些事件</span></span><br><span class="line">        click: <span class="keyword">this</span>.clickHandler</span><br><span class="line">      &#125;,</span><br><span class="line">      nativeOn: &#123;</span><br><span class="line">        click: <span class="keyword">this</span>.nativeClickHandler</span><br><span class="line">      &#125;,</span><br><span class="line">      class: &#123;</span><br><span class="line">        foo: <span class="literal">true</span>,</span><br><span class="line">        bar: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      style: &#123;</span><br><span class="line">        color: <span class="string">'red'</span>,</span><br><span class="line">        fontSize: <span class="string">'14px'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      key: <span class="string">'key'</span>,</span><br><span class="line">      ref: <span class="string">'ref'</span>,</span><br><span class="line">      refInFor: <span class="literal">true</span>,</span><br><span class="line">      slot: <span class="string">'slot'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以必要情况下要这么用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  &#123;...&#123;</span><br><span class="line">    attrs: &#123;</span><br><span class="line">      id: <span class="string">'foo'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    domProps: &#123;</span><br><span class="line">      innerHTML: <span class="string">'bar'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    class: &#123;</span><br><span class="line">      foo: <span class="literal">true</span>,</span><br><span class="line">      bar: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    style: &#123;</span><br><span class="line">      color: <span class="string">'red'</span>,</span><br><span class="line">      fontSize: <span class="string">'14px'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    on: &#123;</span><br><span class="line">      click: <span class="keyword">this</span>.clickHandler</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="JSX代码示例"><a href="#JSX代码示例" class="headerlink" title="JSX代码示例"></a>JSX代码示例</h3><p>以下是jsx写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; index.vue</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Props from &quot;.&#x2F;Props&quot;;</span><br><span class="line">import Event from &quot;.&#x2F;Event&quot;;</span><br><span class="line">import Slot from &quot;.&#x2F;Slot&quot;;</span><br><span class="line">import BigProps from &quot;.&#x2F;BigProps&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Props,</span><br><span class="line">    Event,</span><br><span class="line">    SlotDemo: Slot,</span><br><span class="line">    BigProps</span><br><span class="line">  &#125;,</span><br><span class="line">  data: () &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &quot;&quot;,</span><br><span class="line">      type: &quot;success&quot;,</span><br><span class="line">      bigPropsName: &quot;Hello world!&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handlePropChange(val) &#123;</span><br><span class="line">      this.type &#x3D; val;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleEventChange(val) &#123;</span><br><span class="line">      this.name &#x3D; val;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleBigPropChange(val) &#123;</span><br><span class="line">      this.bigPropsName &#x3D; val;</span><br><span class="line">    &#125;,</span><br><span class="line">    getDefault() &#123;</span><br><span class="line">      return [&lt;p&gt;default slot&lt;&#x2F;p&gt;];</span><br><span class="line">    &#125;,</span><br><span class="line">    getTitle() &#123;</span><br><span class="line">      return [&lt;p&gt;title slot1&lt;&#x2F;p&gt;, &lt;p&gt;title slot2&lt;&#x2F;p&gt;];</span><br><span class="line">    &#125;,</span><br><span class="line">    getItem(props) &#123;</span><br><span class="line">      return [&lt;p&gt;&#123;&#96;item slot-scope $&#123;JSON.stringify(props)&#125;&#96;&#125;&lt;&#x2F;p&gt;];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;</span><br><span class="line">      type,</span><br><span class="line">      handlePropChange,</span><br><span class="line">      name,</span><br><span class="line">      handleEventChange,</span><br><span class="line">      bigPropsName,</span><br><span class="line">      getDefault,</span><br><span class="line">      getTitle,</span><br><span class="line">      getItem,</span><br><span class="line">      handleBigPropChange</span><br><span class="line">    &#125; &#x3D; this;</span><br><span class="line">    const slotDemoProps &#x3D; &#123;</span><br><span class="line">      scopedSlots: &#123;</span><br><span class="line">        item(props) &#123;</span><br><span class="line">          return &#96;item slot-scope $&#123;JSON.stringify(props)&#125;&#96;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      props: &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const bigProps &#x3D; &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        onChange: handleBigPropChange</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;a-tabs&gt;</span><br><span class="line">          &lt;a-tab-pane key&#x3D;&quot;props&quot; tab&#x3D;&quot;属性&quot;&gt;</span><br><span class="line">            &lt;Props</span><br><span class="line">              name&#x3D;&quot;Hello Vue！&quot;</span><br><span class="line">              type&#x3D;&#123;type&#125;</span><br><span class="line">              isVisible&#x3D;&#123;false&#125;</span><br><span class="line">              &#123;...&#123; props: &#123; onChange: handlePropChange &#125; &#125;&#125;</span><br><span class="line">              title&#x3D;&quot;属性Demo&quot;</span><br><span class="line">              class&#x3D;&quot;test1&quot;</span><br><span class="line">              class&#x3D;&#123;[&quot;test1&quot;, &quot;test2&quot;]&#125;</span><br><span class="line">              style&#x3D;&#123;&#123; marginTop: &quot;10px&quot; &#125;&#125;</span><br><span class="line">            &#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;a-tab-pane&gt;</span><br><span class="line">          &lt;a-tab-pane key&#x3D;&quot;event&quot; tab&#x3D;&quot;事件&quot;&gt;</span><br><span class="line">            &lt;Event name&#x3D;&#123;name&#125; onChange&#x3D;&#123;handleEventChange&#125; &#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;a-tab-pane&gt;</span><br><span class="line">          &lt;a-tab-pane key&#x3D;&quot;slot&quot; tab&#x3D;&quot;插槽&quot;&gt;</span><br><span class="line">            &lt;SlotDemo &#123;...slotDemoProps&#125;&gt;</span><br><span class="line">              &lt;p&gt;default slot&lt;&#x2F;p&gt;</span><br><span class="line">              &lt;p slot&#x3D;&quot;title&quot;&gt;title slot1&lt;&#x2F;p&gt;</span><br><span class="line">              &lt;p slot&#x3D;&quot;title&quot;&gt;title slot2&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;&#x2F;SlotDemo&gt;</span><br><span class="line">          &lt;&#x2F;a-tab-pane&gt;</span><br><span class="line">          &lt;a-tab-pane key&#x3D;&quot;bigProps&quot; tab&#x3D;&quot;大属性&quot;&gt;</span><br><span class="line">            &lt;BigProps</span><br><span class="line">              name&#x3D;&#123;bigPropsName&#125;</span><br><span class="line">              &#123;...bigProps&#125;</span><br><span class="line">              slotDefault&#x3D;&#123;getDefault()&#125;</span><br><span class="line">              slotTitle&#x3D;&#123;getTitle()&#125;</span><br><span class="line">              slotScopeItem&#x3D;&#123;getItem&#125;</span><br><span class="line">            &#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;a-tab-pane&gt;</span><br><span class="line">        &lt;&#x2F;a-tabs&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bigProps</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;BigProps&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    VNodes: &#123;</span><br><span class="line">      functional: true,</span><br><span class="line">      render: (h, ctx) &#x3D;&gt; ctx.props.vnodes</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    onChange: &#123;</span><br><span class="line">      type: Function,</span><br><span class="line">      default: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    slotDefault: Array,</span><br><span class="line">    slotTitle: Array,</span><br><span class="line">    slotScopeItem: &#123;</span><br><span class="line">      type: Function,</span><br><span class="line">      default: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChange() &#123;</span><br><span class="line">      this.onChange(&quot;Hello vue!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; name, handleChange, slotDefault, slotTitle, slotScopeItem &#125; &#x3D; this;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;name&#125;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;handleChange&#125;&gt;change name&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &#123;slotDefault&#125;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &#123;slotTitle&#125;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &#123;slotScopeItem(&#123; value: &quot;vue&quot; &#125;)&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Events.vue</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;EventDemo&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: String</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChange(e) &#123;</span><br><span class="line">      this.$emit(&quot;change&quot;, e.target.value);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleDivClick() &#123;</span><br><span class="line">      this.$emit(&quot;change&quot;, &quot;&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick(e, stop) &#123;</span><br><span class="line">      console.log(&quot;stop&quot;, stop);</span><br><span class="line">      if (stop) &#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; name, handleChange, handleDivClick, handleClick &#125; &#x3D; this;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        name: &#123;name || &quot;--&quot;&#125;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;input value&#x3D;&#123;name&#125; onChange&#x3D;&#123;handleChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;div onClick&#x3D;&#123;handleDivClick&#125;&gt;</span><br><span class="line">          &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;重置成功&lt;&#x2F;button&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">          &lt;button onClick&#x3D;&#123;e &#x3D;&gt; handleClick(e, true)&#125;&gt;重置失败&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Props.vue</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;PropsDemo&quot;,</span><br><span class="line">  &#x2F;&#x2F; inheritAttrs: false,</span><br><span class="line">  &#x2F;&#x2F; props: [&#39;name&#39;, &#39;type&#39;, &#39;list&#39;, &#39;isVisible&#39;],</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    type: &#123;</span><br><span class="line">      validator: function(value) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个值必须匹配下列字符串中的一个</span><br><span class="line">        return [&quot;success&quot;, &quot;warning&quot;, &quot;danger&quot;].includes(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    list: &#123;</span><br><span class="line">      type: Array,</span><br><span class="line">      &#x2F;&#x2F; 对象或数组默认值必须从一个工厂函数获取</span><br><span class="line">      default: () &#x3D;&gt; []</span><br><span class="line">    &#125;,</span><br><span class="line">    isVisible: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;,</span><br><span class="line">    onChange: &#123;</span><br><span class="line">      type: Function,</span><br><span class="line">      default: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      &#x2F;&#x2F; 不要这么做、不要这么做、不要这么做</span><br><span class="line">      &#x2F;&#x2F;this.type &#x3D; &quot;warning&quot;;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 可以，还可以更好</span><br><span class="line">      this.onChange(this.type &#x3D;&#x3D;&#x3D; &quot;success&quot; ? &quot;warning&quot; : &quot;success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; name, type, list, isVisible, handleClick &#125; &#x3D; this;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        name: &#123;name&#125;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        type: &#123;type&#125;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        list: &#123;list&#125;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        isVisible: &#123;isVisible&#125;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;change type&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Slot</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;SlotDemo&quot;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; $scopedSlots &#125; &#x3D; this;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;$scopedSlots.default()&#125;</span><br><span class="line">        &#123;$scopedSlots.title()&#125;</span><br><span class="line">        &#123;$scopedSlots.item(&#123; value: &quot;vue&quot; &#125;)&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>感觉看起来还是没有react的顺眼</p>
<h3 id="基于类react的编码格式"><a href="#基于类react的编码格式" class="headerlink" title="基于类react的编码格式 **"></a>基于类react的编码格式 **</h3><p><a href="https://cn.vuejs.org/v2/guide/typescript.html#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84-Vue-%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">基于类的Vue组件</a></p>
<p>如果您在声明组件时更喜欢基于类的 API，则可以使用官方维护的 <code>vue-class-component</code> 装饰器</p>
<p><code>vue-property-decorator</code> 是一个非官方库，是 <code>vue-class-component</code> 的很好的补充。它可以让<code>vue</code>的某些属性和方法，通过修饰器的写法让它也写到<code>vue</code>组件实例的类里面。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">@Component (完全继承于vue-class-component)</span><br><span class="line">@Emit</span><br><span class="line">@Inject</span><br><span class="line">@Provice    </span><br><span class="line">@Prop</span><br><span class="line">@Watch</span><br><span class="line">@Model</span><br><span class="line">Mixins (继承vue-class-component中的mixins)</span><br></pre></td></tr></table></figure>

<h4 id="类写的JSX"><a href="#类写的JSX" class="headerlink" title="类写的JSX"></a>类写的JSX</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import Vue from 'vue'</span></span><br><span class="line"><span class="comment">// import Component from 'vue-class-component'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;Component, Vue&#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @Component 修饰符注明了此类为一个 Vue 组件</span></span><br><span class="line">@Component(&#123;</span><br><span class="line">  <span class="comment">// 所有的组件选项都可以放在这里,建议直接写在render里面</span></span><br><span class="line">  template: <span class="string">'&lt;button @click="onClick"&gt;Click!&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始数据可以直接声明为实例的属性 data()&#123;return&#123;&#125;&#125;</span></span><br><span class="line">  private message: string = <span class="string">'Hello!'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// computed</span></span><br><span class="line">  <span class="keyword">get</span> subMessage(): string &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`boy <span class="subst">$&#123;<span class="keyword">this</span>.message&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  mounted () &#123;</span><br><span class="line">      <span class="keyword">this</span>.greet()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 组件方法也可以直接声明为实例的方法</span></span><br><span class="line">  public onClick (): <span class="keyword">void</span> &#123;</span><br><span class="line">     <span class="built_in">window</span>.alert(<span class="keyword">this</span>.message)</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 这里可以代替装饰器里面的template,采用的jsx的编码方式</span></span><br><span class="line"> <span class="comment">//  public render() &#123;</span></span><br><span class="line"> <span class="comment">//    const &#123;onClick,message&#125; = this;</span></span><br><span class="line"> <span class="comment">//    return (&lt;button @click="onClick"&gt;Click!&lt;/button&gt;)</span></span><br><span class="line"> <span class="comment">//  &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加声明文件"><a href="#添加声明文件" class="headerlink" title="添加声明文件"></a>添加声明文件</h4><p>我们在开发的时候很可能会自定义一些全局的指令或者一些的方法等等，如果不添加声明的话，可能需要每一个都<code>// @ts-ignore</code>,甚至有的报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">&#x2F;&#x2F; 添加一个全局的方法</span><br><span class="line">Vue.prototype.$fetch &#x3D; function (url) &#123;</span><br><span class="line">  return fetch(url).then(e &#x3D;&gt; e.json()).then(val &#x3D;&gt; &#123;</span><br><span class="line">    return val</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; tsconfig.json</span><br><span class="line">&#123;</span><br><span class="line">   &quot;compilerOptions&quot;: &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">      &quot;typeRoots&quot;: [</span><br><span class="line">	   &quot;node_modules&#x2F;@types&quot;,</span><br><span class="line">	   &quot;src&#x2F;type&#x2F;global.d.ts&quot;</span><br><span class="line">      ]</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; global.d.ts</span><br><span class="line">import Vue from &#39;vue&#39;  &#x2F;&#x2F; 必须添加否则无效</span><br><span class="line"></span><br><span class="line">declare module &#39;vue&#x2F;types&#x2F;vue&#39; &#123;</span><br><span class="line">    &#x2F;&#x2F; 在实例上的属性</span><br><span class="line">    interface Vue &#123;</span><br><span class="line">        $fetch: string</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 使用 &#96;VueConstructor&#96; 接口</span><br><span class="line">    &#x2F;&#x2F; 声明全局属性</span><br><span class="line">    interface VueConstructor &#123;</span><br><span class="line">      $myGlobal: string</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare module &#39;vue&#x2F;types&#x2F;options&#39; &#123;</span><br><span class="line"></span><br><span class="line">  interface ComponentOptions&lt;V extends Vue&gt; &#123;</span><br><span class="line">    myOption?: string  &#x2F;&#x2F; 额外的组件选项</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">vm.$fetch()</span><br><span class="line">Vue.$myGlobal</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  myOption: &#39;Hello&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="使用-Mixins"><a href="#使用-Mixins" class="headerlink" title="使用 Mixins"></a>使用 Mixins</h4><p><a href="/workspace/Frame/vue/vue.html#mixins">template的声明方式</a></p>
<p>声明 mixin 的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// assets/mixins/mixin.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以想声明一个组件一样声明一个 mixin</span></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMixin</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个里面可以抽离一些公共逻辑</span></span><br><span class="line">  mixinValue = <span class="string">'Hello'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import Component, &#123; mixins &#125; from 'vue-class-component'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Component, Mixins&#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span>;</span><br><span class="line"><span class="keyword">import</span> MyMixin <span class="keyword">from</span> <span class="string">'@/assets/mixins/mixin'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `mixins` 帮助函数，而不是 `Vue`.</span></span><br><span class="line"><span class="comment">// `mixins` 可以获取任何数量的参数</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Mixins</span>(<span class="title">MyMixin</span>) </span>&#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.mixinValue) <span class="comment">// -&gt; Hello</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义修饰器"><a href="#自定义修饰器" class="headerlink" title="自定义修饰器"></a>自定义修饰器</h4><p><code>vue-class-component</code> 提供 <code>createDecorator</code> 帮助函数用来创建自定义修饰器。</p>
<p><code>createDecorator</code> 的第一个参数是一个回调函数，并且这个函数可以获取一下参数：</p>
<p><code>options</code>: vue 组件选项组成的对象，改变这些选项会影响所提供的组件<br/><br><code>key</code>: 修饰器所作为的属性或方法的 key<br/><br><code>parameterIndex</code>: 修饰器作用于参数时，这个参数的索引<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; decorators.js</span><br><span class="line">import &#123; createDecorator &#125; from &#39;vue-class-component&#39;</span><br><span class="line"></span><br><span class="line">export const NoCache &#x3D; createDecorator((options, key) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 组件的选项应该传给回调函数，同时会更新选项对象（options object）</span><br><span class="line">  &#x2F;&#x2F; 进而作用于组件</span><br><span class="line">  options.computed[key].cache &#x3D; false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; NoCache &#125; from &#39;.&#x2F;decorators&#39;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">class MyComp extends Vue &#123;</span><br><span class="line">  &#x2F;&#x2F; 这个计算属性不会被缓存</span><br><span class="line">  @NoCache</span><br><span class="line">  get random () &#123;</span><br><span class="line">    return Math.random()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加自定义钩子"><a href="#添加自定义钩子" class="headerlink" title="添加自定义钩子"></a>添加自定义钩子</h4><p>如果你使用了一些Vue 插件比如 Vue Router，你可能会希望 class 组件解析它们所提供的钩子， <code>Component.registerHooks</code> 就允许你注册这些钩子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class-component-hooks.js</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过这些钩子的名称来注册它们</span></span><br><span class="line">Component.registerHooks([</span><br><span class="line">  <span class="string">'beforeRouteEnter'</span>,</span><br><span class="line">  <span class="string">'beforeRouteLeave'</span>,</span><br><span class="line">  <span class="string">'beforeRouteUpdate'</span> <span class="comment">// for vue-router 2.2+</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyComp.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// class 组件现在可以处理 beforeRouteEnter 钩子和 </span></span><br><span class="line">  <span class="comment">// beforeRouteLeave 钩子作为 Vue Router 钩子</span></span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeRouteEnter'</span>)</span><br><span class="line">    next() <span class="comment">// 需要调用这个来确认导航</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeRouteLeave'</span>)</span><br><span class="line">    next() <span class="comment">// 需要调用这个来确认导航</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，你必须在组件定义之前注册钩子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保在引入任何组件之前注册</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./class-component-hooks'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> MyComp <span class="keyword">from</span> <span class="string">'./MyComp'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyComp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种乍一看跟react的编码格式很像，但是代码压缩后文件太大，<br>而且vue的版本迭代速度很快，vue3已经不推崇这种写法了，vue3推崇使用函数式开发，对react的用户很是友好</p>
<h3 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h3><p><code>vue-property-decorator</code> 是一个非官方库，是 <code>vue-class-component</code> 的很好的补充。它可以让<code>vue</code>的某些属性和方法，通过修饰器的写法让它也写到<code>vue</code>组件实例的类里面。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> (完全继承于vue-<span class="keyword">class</span>-component)</span><br><span class="line"><span class="meta">@Emit</span></span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="meta">@Provice</span></span><br><span class="line"><span class="meta">@Prop</span></span><br><span class="line"><span class="meta">@Watch</span></span><br><span class="line"><span class="meta">@Model</span></span><br><span class="line">Mixins (继承vue-<span class="keyword">class</span>-component中的mixins)</span><br></pre></td></tr></table></figure>

<h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><p>@Component 修饰符注明了此类为一个 Vue 组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  name: <span class="string">'A'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    B</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 所有的组件选项都可以放在这里,建议直接写在render里面</span></span><br><span class="line">  template: <span class="string">'&lt;button @click="onClick"&gt;Click!&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Props"><a href="#Props" class="headerlink" title="@Props"></a>@Props</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Prop</span>(&#123;<span class="keyword">default</span>: <span class="string">'默认的title'</span>, <span class="keyword">type</span>: [<span class="built_in">String</span>, <span class="built_in">Number</span>]&#125;) <span class="keyword">public</span> readonly title!: <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>这里 <code>!是必选的</code>  <code>?可选参数</code>, !告诉TypeScript我这里一定有值,实践感觉并没有ts的类型检验，仅仅编辑器有提示，代码正常运行</p>
<p>下面这种写法，能少用@Prop,我的代码运行的时候，在父组件中必须是<code>x-xx</code>,类型的，在子组件<code>xXx</code>，即可使用，不然没办法打包。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;Child</span><br><span class="line">     z-context=&#123;&#123;</span><br><span class="line">        title: message,</span><br><span class="line">        changeTitle: <span class="function">(<span class="params">val: <span class="built_in">string</span></span>) =&gt;</span> <span class="keyword">this</span>.state.message = val  <span class="comment">// 这里只能是this.state.message，不能直接 message = val，默认是只读属性</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">    changeTitle: <span class="function">(<span class="params">val: <span class="built_in">string</span></span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">    title: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Prop</span>(&#123;<span class="keyword">default</span>: &#123;&#125;, <span class="keyword">type</span>: <span class="built_in">Object</span>&#125;) zContext: IProps; <span class="comment">// 这样ts有类型检验,但是父级的类型检测不出来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;title,changeTitle&#125; = <span class="keyword">this</span>.zContext;</span><br><span class="line">changeTitle(<span class="string">'只能是字符串'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Watch"><a href="#Watch" class="headerlink" title="@Watch"></a>@Watch</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Watch</span>(<span class="string">'message'</span>, &#123;immediate: <span class="literal">true</span>, deep: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// 上面的装饰器，就是检测下面这个函数</span></span><br><span class="line"><span class="keyword">public</span> onMsgChane(val: <span class="built_in">string</span>, oldVal: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'onMsgChane'</span>, val, oldVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h4><p>在使用<code>Vue</code>进行开发时我们经常要用到混合,结合<code>TypeScript</code>之后我们有两种<code>mixins</code>的方法</p>
<p><strong>一种是vue-class-component提供的</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义要混合的类 mixins.ts</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span>  Component  <span class="keyword">from</span> <span class="string">'vue-class-component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">// 一定要用Component修饰</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> myMixins <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">    value: <span class="built_in">string</span> = <span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span>  Component  &#123;mixins&#125;  <span class="keyword">from</span> <span class="string">'vue-class-component'</span>;</span><br><span class="line"><span class="keyword">import</span> myMixins <span class="keyword">from</span> <span class="string">'mixins.ts'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> myComponent <span class="keyword">extends</span> mixins(myMixins) &#123;</span><br><span class="line">                          <span class="comment">// 直接extends myMinxins 也可以正常运行</span></span><br><span class="line">      created()&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.value) <span class="comment">// =&gt; Hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二种方式是在@Component中混入</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mixins.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Vue, Component &#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span>;</span><br><span class="line"><span class="comment">// 这里是ts的类型声明，建议直接写在 type/global.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'vue/types/vue' &#123;</span><br><span class="line">    <span class="keyword">interface</span> Vue &#123;</span><br><span class="line">        value: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> myMixins <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">    value: <span class="built_in">string</span> = <span class="string">'Hello'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Vue, Component, Prop &#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span>;</span><br><span class="line"><span class="keyword">import</span> myMixins <span class="keyword">from</span> <span class="string">'mixins.ts'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    mixins: [myMixins]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> myComponent <span class="keyword">extends</span> Vue&#123;</span><br><span class="line">    created()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.value) <span class="comment">// =&gt; Hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用JSX遇到的坑"><a href="#使用JSX遇到的坑" class="headerlink" title="使用JSX遇到的坑"></a>使用JSX遇到的坑</h3><ul>
<li>在使用ui框架的时候，@都用 on- 代替</li>
<li>el-popconfirm 在 table 里面不能直接使用<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 在table里面不能直接使用</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-popconfirm</span></span></span><br><span class="line"><span class="tag">  <span class="attr">title</span>=<span class="string">"这是一段内容确定删除吗？"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">slot</span>=<span class="string">"reference"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-popconfirm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">// 这种可以</span><br><span class="line"><span class="tag">&lt;<span class="name">el-popconfirm</span></span></span><br><span class="line"><span class="tag">   <span class="attr">icon</span>=<span class="string">"el-icon-info"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">iconColor</span>=<span class="string">"red"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">title</span>=<span class="string">"确定要删除吗？"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">onConfirm</span>=<span class="string">"handelCancel"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">onCancel</span>=<span class="string">"handelCancel"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">scopedSlots</span>=<span class="string">&#123;&#123;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">reference:</span> <span class="attr">props</span> =&gt;</span> &#123;</span><br><span class="line">            console.log(props);</span><br><span class="line">            return (</span><br><span class="line">                <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">solt</span>=<span class="string">&#123;</span>'<span class="attr">reference</span>'&#125; <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"medium"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// table获取行的数据</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&lt;el-table-column</span><br><span class="line">  fixed=<span class="string">"right"</span></span><br><span class="line">  label=<span class="string">"操作"</span></span><br><span class="line">  width=<span class="string">"100"</span>&gt;</span><br><span class="line">  &lt;template slot-scope=<span class="string">"scope"</span>&gt;</span><br><span class="line">    &lt;el-button @click=<span class="string">"handleClick(scope.row)"</span> type=<span class="string">"text"</span> size=<span class="string">"small"</span>&gt;查看&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>template&gt;</span><br><span class="line">&lt;<span class="regexp">/el-table-column&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/</span></span><br><span class="line"><span class="regexp">&lt;el-table-column</span></span><br><span class="line"><span class="regexp">   prop="edit"</span></span><br><span class="line"><span class="regexp">   label="操作"</span></span><br><span class="line"><span class="regexp">   fixed="right"</span></span><br><span class="line"><span class="regexp">   width="180"</span></span><br><span class="line"><span class="regexp">   scopedSlots=&#123;&#123;</span></span><br><span class="line"><span class="regexp">       default: (&#123;$index, row&#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">       return (/</span><span class="regexp">/...)</span></span><br><span class="line"><span class="regexp">       &#125;</span></span><br><span class="line"><span class="regexp">   &#125;&#125;</span></span><br><span class="line"><span class="regexp">/</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>用from</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;el-form :model=<span class="string">"form"</span>&gt;&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;el-form props=&#123;&#123;model: this.formPass&#125;&#125;    /</span><span class="regexp">/ 这里不能直接使用model   rules里面拿不到value,最后不能校验</span></span><br><span class="line"><span class="regexp">        label-position=&#123;'left'&#125;</span></span><br><span class="line"><span class="regexp">        ref=&#123;'formData'&#125;</span></span><br><span class="line"><span class="regexp">        label-width=&#123;'100px'&#125;</span></span><br><span class="line"><span class="regexp">        rules=&#123;this.rules&#125;&gt;</span></span><br><span class="line"><span class="regexp">  &lt;el-input  autocomplete="off"&gt;&lt;/</span>el-input&gt;</span><br><span class="line">&lt;<span class="regexp">/el-form&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>v-model不能使用解构出来的，解构默认是只读属性的</p>
</li>
<li><p>箭头函数慎用，当前的this是类的实例，temp中的this是Vue的实例, （可使用bind解决传值）</p>
</li>
<li><p>tsx写的组件，传递性需要是 x-xxx 如 zy-props={}</p>
<ul>
<li>tsx引入tsx，如果不使用@Component装饰器的话，（PascalCase）传递性需要是 x-xxx 如 zy-props={}，大驼峰，使用@Component正常（kebab-case）</li>
<li>tsx引入.vue的，如果不使用@Component装饰器的话，默认开发环境是没事的，打包报错，使用@Component正常 </li>
</ul>
</li>
<li><p>一些事件，在tsx中不能直接用v-model,需要用onChange方法获取值</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  v-model="formData.roleId"</span></span><br><span class="line">&lt;el-select value=&#123;<span class="keyword">this</span>.formData.roleId&#125; onChange=&#123;<span class="keyword">this</span>.setSelect&#125; size=<span class="string">"small"</span>&gt;</span><br><span class="line">    &#123;roles.map(<span class="function">(<span class="params">item: any</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;el-option</span><br><span class="line">                key=&#123;item.roleId&#125;</span><br><span class="line">                label=&#123;item.roleId + <span class="string">'-'</span> + item.roleName&#125;</span><br><span class="line">                value=&#123;item.roleId&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;)&#125;</span><br><span class="line">&lt;<span class="regexp">/el-select&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://juejin.im/post/5d7e662e6fb9a06b1f1460c2" target="_blank" rel="noopener">https://juejin.im/post/5d7e662e6fb9a06b1f1460c2</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>调研JSX</category>
      </categories>
  </entry>
  <entry>
    <title>项目使用总结</title>
    <url>/2020/03/11/workspace/Frame/vue/use-project/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>脚手架vue-cli</title>
    <url>/2020/02/11/workspace/Frame/vue/vue-cli/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>脚手架vue-cli</strong></p>
<p>[[toc]]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装 Vue CLI 3.x</span><br><span class="line">yarn global @vue&#x2F;cli</span><br><span class="line"></span><br><span class="line"># my-project 是你的项目名称</span><br><span class="line">vue create my-project</span><br></pre></td></tr></table></figure>

<p>vue-cli 中包含着 typescript 选项，只需要选择即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vue create repo</span><br><span class="line"># 手动配置的时候需要选择 TypeScript</span><br><span class="line">Check the features needed <span class="keyword">for</span> your project:</span><br><span class="line"> ◉ Babel</span><br><span class="line"> ◉ TypeScript</span><br><span class="line"> ◯ Progressive Web App (PWA) Support</span><br><span class="line"> ◯ Router</span><br><span class="line"> ◉ Vuex</span><br><span class="line"> ◉ CSS Pre-processors</span><br><span class="line"> ◉ Linter / Formatter</span><br><span class="line"> ◯ Unit Testing</span><br><span class="line"> ◯ E2E Testing</span><br></pre></td></tr></table></figure>

<h3 id="vue-config-js-的配置"><a href="#vue-config-js-的配置" class="headerlink" title="vue.config.js 的配置"></a>vue.config.js 的配置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个文件用于修改cli和webpack的配置</span></span><br><span class="line"><span class="comment">// 基于CommonJS 的风格导出一个对象</span></span><br><span class="line"><span class="comment">// 和webpack.config.js一样，修改后需要重启</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    outputDir: <span class="string">'./dist'</span>, <span class="comment">// 指定文件打包后的输出路径</span></span><br><span class="line">    lintOnSave: <span class="literal">true</span>, <span class="comment">// 启用eslint语法检查，默认启用</span></span><br><span class="line">    productionSourceMap: <span class="literal">false</span>, <span class="comment">// 生产环境是否需要source-map,如果设为false可以加速构建(打包)</span></span><br><span class="line">    devServer: &#123; <span class="comment">// vue-cli 支持所有webpack-dev-server的配置</span></span><br><span class="line">        port: <span class="number">8082</span>, <span class="comment">// 端口号</span></span><br><span class="line">        open: <span class="literal">true</span>, <span class="comment">// 自动打开浏览器</span></span><br><span class="line">        host: <span class="string">'0.0.0.0'</span>, <span class="comment">// 指定使用一个 host。默认是 localhost</span></span><br><span class="line">        https: <span class="literal">false</span>, <span class="comment">// 是否启用https</span></span><br><span class="line">        proxy: &#123; <span class="comment">// 这个必须会，用来解决开发环境跨域的问题</span></span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'http://localhost:8000'</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                secure: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="开启Gzip压缩"><a href="#开启Gzip压缩" class="headerlink" title="开启Gzip压缩"></a>开启Gzip压缩</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* vue.config.js */</span></span><br><span class="line"><span class="keyword">const</span> isPro = process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPro) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                    <span class="keyword">new</span> CompressionWebpackPlugin(&#123;</span><br><span class="line">                         <span class="comment">// 目标文件名称。[path] 被替换为原始文件的路径和 [query] 查询</span></span><br><span class="line">                        asset: <span class="string">'[path].gz[query]'</span>,</span><br><span class="line">                        <span class="comment">// 使用 gzip 压缩</span></span><br><span class="line">                        algorithm: <span class="string">'gzip'</span>, </span><br><span class="line">                        <span class="comment">// 处理与此正则相匹配的所有文件</span></span><br><span class="line">                        test: <span class="keyword">new</span> <span class="built_in">RegExp</span>(</span><br><span class="line">                            <span class="string">'\\.(js|css)$'</span></span><br><span class="line">                        ),</span><br><span class="line">                        <span class="comment">// 只处理大于此大小的文件</span></span><br><span class="line">                        threshold: <span class="number">10240</span>,</span><br><span class="line">                        <span class="comment">// 最小压缩比达到 0.8 时才会被压缩</span></span><br><span class="line">                        minRatio: <span class="number">0.8</span>，</span><br><span class="line">                    &#125;)</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析包文件"><a href="#分析包文件" class="headerlink" title="分析包文件"></a>分析包文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line">chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修复HMR</span></span><br><span class="line">    config.resolve.symlinks(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (isAnalyze) &#123;</span><br><span class="line">        config</span><br><span class="line">            .plugin(<span class="string">'webpack-bundle-analyzer'</span>)</span><br><span class="line">            .use(</span><br><span class="line">                <span class="keyword">new</span> BundleAnalyzerPlugin(&#123;</span><br><span class="line">                    analyzerPort: <span class="number">9999</span>,</span><br><span class="line">                    openAnalyzer: <span class="literal">true</span>,</span><br><span class="line">                &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">configureWebpack: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">            vendor:&#123;</span><br><span class="line">            chunks:<span class="string">"all"</span>,</span><br><span class="line">                test: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                name:<span class="string">"vendor"</span>,</span><br><span class="line">                minChunks: <span class="number">1</span>,</span><br><span class="line">                maxInitialRequests: <span class="number">5</span>,</span><br><span class="line">                minSize: <span class="number">0</span>,</span><br><span class="line">                priority:<span class="number">100</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            common: &#123;</span><br><span class="line">                chunks:<span class="string">"all"</span>,</span><br><span class="line">                test:<span class="regexp">/[\\/]src[\\/]js[\\/]/</span>,</span><br><span class="line">                name: <span class="string">"common"</span>,</span><br><span class="line">                minChunks: <span class="number">2</span>,</span><br><span class="line">                maxInitialRequests: <span class="number">5</span>,</span><br><span class="line">                minSize: <span class="number">0</span>,</span><br><span class="line">                priority:<span class="number">60</span></span><br><span class="line">            &#125;,</span><br><span class="line">            styles: &#123;</span><br><span class="line">                name: <span class="string">'styles'</span>,</span><br><span class="line">                test: <span class="regexp">/\.(sa|sc|c)ss$/</span>,</span><br><span class="line">                chunks: <span class="string">'all'</span>,</span><br><span class="line">                enforce: <span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                runtimeChunk: &#123;</span><br><span class="line">                name: <span class="string">'manifest'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="默认插件简介"><a href="#默认插件简介" class="headerlink" title="默认插件简介"></a>默认插件简介</h3><p>通过对 <code>vue.config.js</code> 的了解，我们知道了 <code>vue-cli 3.x</code>为我们默认封装了项目运行的常用 <code>webpack</code> 配置，那么它给我们提供了哪些默认插件，每一个<code>plugin</code> 又有着怎样的用途呢？除了使用 <strong>vue inspect plugins</strong> 我们还可以通过运行 <strong>vue ui</strong> 进入可视化页面查看，步骤如下</p>
<ul>
<li>打开可视化页面，点击对应项目进入管理页面（如果没有对应项目，需要导入或新建）</li>
<li>点击侧边栏 <code>Tasks</code> 选项，再点击二级栏 <code>inspect</code>选项</li>
<li>点击<code>Run task</code> 按钮执行审查命令</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hb1e97ba0e7ce4cb2b72ea6466cbb0ba6N.png" alt=""></p>
<blockquote>
<p>最后我们从输出的内容中找到 <code>plugins</code> 数组，其包含了如下插件（配置项已经省略，增加了定义插件的代码）：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue-loader是 webpack 的加载器，允许你以单文件组件的格式编写 Vue 组件</span></span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack 内置插件，用于创建在编译时可以配置的全局常量</span></span><br><span class="line"><span class="keyword">const</span> &#123; DefinePlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于强制所有模块的完整路径必需与磁盘上实际路径的确切大小写相匹配</span></span><br><span class="line"><span class="keyword">const</span> CaseSensitivePathsPlugin = <span class="built_in">require</span>(<span class="string">'case-sensitive-paths-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 识别某些类型的 webpack 错误并整理，以提供开发人员更好的体验。</span></span><br><span class="line"><span class="keyword">const</span> FriendlyErrorsPlugin = <span class="built_in">require</span>(<span class="string">'friendly-errors-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于在 webpack 构建期间优化、最小化 CSS文件</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCssnanoPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack 内置插件，用于根据模块的相对路径生成 hash 作为模块 id, 一般用于生产环境</span></span><br><span class="line"><span class="keyword">const</span> &#123; HashedModuleIdsPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于根据模板或使用加载器生成 HTML 文件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于在使用 html-webpack-plugin 生成的 html 中添加 &lt;link rel ='preload'&gt; 或 &lt;link rel ='prefetch'&gt;，有助于异步加载</span></span><br><span class="line"><span class="keyword">const</span> PreloadPlugin = <span class="built_in">require</span>(<span class="string">'preload-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于将单个文件或整个目录复制到构建目录</span></span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">/* config.plugin('vue-loader') */</span></span><br><span class="line">        <span class="keyword">new</span> VueLoaderPlugin(), </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* config.plugin('define') */</span></span><br><span class="line">        <span class="keyword">new</span> DefinePlugin(),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* config.plugin('case-sensitive-paths') */</span></span><br><span class="line">        <span class="keyword">new</span> CaseSensitivePathsPlugin(),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* config.plugin('friendly-errors') */</span></span><br><span class="line">        <span class="keyword">new</span> FriendlyErrorsWebpackPlugin(),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* config.plugin('extract-css') */</span></span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* config.plugin('optimize-css') */</span></span><br><span class="line">        <span class="keyword">new</span> OptimizeCssnanoPlugin(),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* config.plugin('hash-module-ids') */</span></span><br><span class="line">        <span class="keyword">new</span> HashedModuleIdsPlugin(),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* config.plugin('html') */</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* config.plugin('preload') */</span></span><br><span class="line">        <span class="keyword">new</span> PreloadPlugin(),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* config.plugin('copy') */</span></span><br><span class="line">        <span class="keyword">new</span> CopyWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-alias-简化路径"><a href="#使用-alias-简化路径" class="headerlink" title="使用 alias 简化路径"></a>使用 alias 简化路径</h3><p>而在 <code>CLI 3.x</code>中我们无法直接操作 <code>webpack</code> 的配置文件，我们需要通过 <code>chainWebpack</code> 来进行间接修改，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* vue.config.js */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        config.resolve.alias</span><br><span class="line">            .set(<span class="string">'@'</span>, resolve(<span class="string">'src'</span>))</span><br><span class="line">            .set(<span class="string">'_lib'</span>, resolve(<span class="string">'src/common'</span>))</span><br><span class="line">            .set(<span class="string">'_com'</span>, resolve(<span class="string">'src/components'</span>))</span><br><span class="line">            .set(<span class="string">'_img'</span>, resolve(<span class="string">'src/images'</span>))</span><br><span class="line">            .set(<span class="string">'_ser'</span>, resolve(<span class="string">'src/services'</span>))</span><br><span class="line">    &#125;, </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们修改 <code>webpack alias</code> 来简化路径的优化就实现了。<br>但是需要注意的是对于在样式及 <code>htm</code>l 模板中引用路径的简写时，前面需要加上 <code>～</code> 符，否则路径解析会失败，如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.img</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: (~_img/home.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建多页应用"><a href="#构建多页应用" class="headerlink" title="构建多页应用"></a>构建多页应用</h3><h4 id="多入口"><a href="#多入口" class="headerlink" title="多入口"></a>多入口</h4><p>在单页应用中，我们的入口文件只有一个，<code>CLI</code> 默认配置的是 <code>main.js</code>，但是到了多页应用，<br>我们的入口文件便包含了 <code>page1.js、page2.js、index.js</code>等，数量取决于 pages 文件夹下目录的个数，<br>这时候为了项目的可拓展性，我们需要自动计算入口文件的数量并解析路径配置到 <code>webpack</code> 中的 <code>entry</code> 属性上，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        page1: <span class="string">'/xxx/pages/page1/page1.js'</span>,</span><br><span class="line">        page2: <span class="string">'/xxx/pages/page2/page2.js'</span>,</span><br><span class="line">        index: <span class="string">'/xxx/pages/index/index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">   <span class="comment">//  ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们如何读取并解析这样的路径呢，这里就需要使用工具和函数来解决了。<br>我们可以在根目录新建 <code>build</code> 文件夹存放 <code>utils.js</code> 这样共用的 <code>webpack</code> 功能性文件，并加入多入口读取解析方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* utils.js *&#x2F;</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; glob 是 webpack 安装时依赖的一个第三方模块，该模块允许你使用 * 等符号,</span><br><span class="line">&#x2F;&#x2F; 例如 lib&#x2F;*.js 就是获取 lib 文件夹下的所有 js 后缀名的文件</span><br><span class="line">const glob &#x3D; require(&#39;glob&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取得相应的页面路径，因为之前的配置，所以是 src 文件夹下的 pages 文件夹</span><br><span class="line">const PAGE_PATH &#x3D; path.resolve(__dirname, &#39;..&#x2F;src&#x2F;pages&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line">* 多入口配置</span><br><span class="line">* 通过 glob 模块读取 pages 文件夹下的所有对应文件夹下的 js * 后缀文件，如果该文件存在</span><br><span class="line">* 那么就作为入口处理</span><br><span class="line">*&#x2F;</span><br><span class="line">exports.getEntries &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    let entryFiles &#x3D; glob.sync(PAGE_PATH + &#39;&#x2F;*&#x2F;*.js&#39;) &#x2F;&#x2F; 同步读取所有入口文件</span><br><span class="line">    let map &#x3D; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 遍历所有入口文件</span><br><span class="line">    entryFiles.forEach(filePath &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取文件名</span><br><span class="line">        let filename &#x3D; filePath.substring(filePath.lastIndexOf(&#39;\&#x2F;&#39;) + 1, filePath.lastIndexOf(&#39;.&#39;))</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 以键值对的形式存储</span><br><span class="line">        map[filename] &#x3D; filePath </span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    return map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* vue.config.js *&#x2F;</span><br><span class="line"></span><br><span class="line">const utils &#x3D; require(&#39;.&#x2F;build&#x2F;utils&#39;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    configureWebpack: config &#x3D;&gt; &#123;</span><br><span class="line">        config.entry &#x3D; utils.getEntries()</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多模板"><a href="#多模板" class="headerlink" title="多模板"></a>多模板</h4><p>相对于多入口来说，多模板的配置也是大同小异，这里所说的模板便是每个<code>page</code> 下的<code>html</code> 模板文件，<br>而模板文件的作用主要用于 <code>webpack</code>中 <code>html-webpack-plugin</code> 插件的配置，<br>其会根据模板文件生产一个编译后的 <code>html</code> 文件并自动加入携带 <code>hash</code>的脚本和样式，基本配置如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* webpack 配置文件 */</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>) <span class="comment">// 安装并引用插件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            title: <span class="string">'My Page'</span>, <span class="comment">// 生成 html 中的 title</span></span><br><span class="line">            filename: <span class="string">'demo.html'</span>, <span class="comment">// 生成 html 的文件名</span></span><br><span class="line">            template: <span class="string">'xxx/xxx/demo.html'</span>, <span class="comment">// 模板路径</span></span><br><span class="line">            chunks: [<span class="string">'manifest'</span>, <span class="string">'vendor'</span>, <span class="string">'demo'</span>], <span class="comment">// 所要包含的模块</span></span><br><span class="line">            inject: <span class="literal">true</span>, <span class="comment">// 是否注入资源</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* utils.js */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多页面输出配置</span></span><br><span class="line"><span class="comment">// 与上面的多页面入口配置相同，读取 page 文件夹下的对应的 html 后缀文件，然后放入数组中</span></span><br><span class="line">exports.htmlPlugin = <span class="function"><span class="params">configs</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> entryHtml = glob.sync(PAGE_PATH + <span class="string">'/*/*.html'</span>)</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    </span><br><span class="line">    entryHtml.forEach(<span class="function"><span class="params">filePath</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filename = filePath.substring(filePath.lastIndexOf(<span class="string">'\/'</span>) + <span class="number">1</span>, filePath.lastIndexOf(<span class="string">'.'</span>))</span><br><span class="line">        <span class="keyword">let</span> conf = &#123;</span><br><span class="line">            template: filePath, <span class="comment">// 模板路径</span></span><br><span class="line">            filename: filename + <span class="string">'.html'</span>, <span class="comment">// 生成 html 的文件名</span></span><br><span class="line">            chunks: [<span class="string">'manifest'</span>, <span class="string">'vendor'</span>,  filename],</span><br><span class="line">            inject: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有自定义配置可以进行 merge</span></span><br><span class="line">        <span class="keyword">if</span> (configs) &#123;</span><br><span class="line">            conf = merge(conf, configs)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 针对生产环境配置</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">            conf = merge(conf, &#123;</span><br><span class="line">                minify: &#123;</span><br><span class="line">                    removeComments: <span class="literal">true</span>, <span class="comment">// 删除 html 中的注释代码</span></span><br><span class="line">                    collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 删除 html 中的空白符</span></span><br><span class="line">                    <span class="comment">// removeAttributeQuotes: true // 删除 html 元素中属性的引号</span></span><br><span class="line">                &#125;,</span><br><span class="line">                chunksSortMode: <span class="string">'manual'</span> <span class="comment">// 按 manual 的顺序引入</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arr.push(<span class="keyword">new</span> HtmlWebpackPlugin(conf))</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* vue.config.js *&#x2F;</span><br><span class="line"></span><br><span class="line">const utils &#x3D; require(&#39;.&#x2F;build&#x2F;utils&#39;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    configureWebpack: config &#x3D;&gt; &#123;</span><br><span class="line">        config.entry &#x3D; utils.getEntries() &#x2F;&#x2F; 直接覆盖 entry 配置</span><br><span class="line">        &#x2F;&#x2F; 使用 return 一个对象会通过 webpack-merge 进行合并，plugins 不会置空</span><br><span class="line">        return &#123;</span><br><span class="line">            plugins: [...utils.htmlPlugin()]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此我们多页应用的多入口和多模板的配置就完成了，<br>这时候我们运行命令 <code>yarn build</code> 后你会发现 <code>dist</code> 目录下生成了 3 个 html 文件，分别是 <code>index.html、page1.html 和 page2.html</code></p>
<h4 id="使用-pages-配置"><a href="#使用-pages-配置" class="headerlink" title="使用 pages 配置"></a>使用 pages 配置</h4><p>其实，在 <code>vue.config.js</code> 中，我们还有一个配置没有使用，便是 <code>pages</code>。<code>pages</code> 对象允许我们为应用配置多个入口及模板，<br>这就为我们的多页应用提供了开放的配置入口。官方示例代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* vue.config.js */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    pages: &#123;</span><br><span class="line">        index: &#123;</span><br><span class="line">            <span class="comment">// page 的入口</span></span><br><span class="line">            entry: <span class="string">'src/index/main.js'</span>,</span><br><span class="line">            <span class="comment">// 模板来源</span></span><br><span class="line">            template: <span class="string">'public/index.html'</span>,</span><br><span class="line">            <span class="comment">// 在 dist/index.html 的输出</span></span><br><span class="line">            filename: <span class="string">'index.html'</span>,</span><br><span class="line">            <span class="comment">// 当使用 title 选项时，</span></span><br><span class="line">            <span class="comment">// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">            title: <span class="string">'Index Page'</span>,</span><br><span class="line">            <span class="comment">// 在这个页面中包含的块，默认情况下会包含</span></span><br><span class="line">            <span class="comment">// 提取出来的通用 chunk 和 vendor chunk。</span></span><br><span class="line">            chunks: [<span class="string">'chunk-vendors'</span>, <span class="string">'chunk-common'</span>, <span class="string">'index'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 当使用只有入口的字符串格式时，</span></span><br><span class="line">        <span class="comment">// 模板会被推导为 `public/subpage.html`</span></span><br><span class="line">        <span class="comment">// 并且如果找不到的话，就回退到 `public/index.html`。</span></span><br><span class="line">        <span class="comment">// 输出文件名会被推导为 `subpage.html`。</span></span><br><span class="line">        subpage: <span class="string">'src/subpage/main.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不难发现，<code>pages</code> 对象中的 <code>key</code> 就是入口的别名，而其 <code>value</code> 对象其实是入口 <code>entry</code> 和模板属性的合并，<br>这样我们上述介绍的获取多入口和多模板的方法就可以合并成一个函数来进行多页的处理，合并后的 <code>setPages</code> 方法如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ pages 多入口配置</span><br><span class="line">exports.setPages = <span class="function"><span class="params">configs</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> entryFiles = glob.sync(PAGE_PATH + <span class="string">'/*/*.js'</span>)</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    entryFiles.forEach(<span class="function"><span class="params">filePath</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filename = filePath.substring(filePath.lastIndexOf(<span class="string">'\/'</span>) + <span class="number">1</span>, filePath.lastIndexOf(<span class="string">'.'</span>))</span><br><span class="line">        <span class="keyword">let</span> tmp = filePath.substring(<span class="number">0</span>, filePath.lastIndexOf(<span class="string">'\/'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> conf = &#123;</span><br><span class="line">            <span class="comment">// page 的入口</span></span><br><span class="line">            entry: filePath, </span><br><span class="line">            <span class="comment">// 模板来源</span></span><br><span class="line">            template: tmp + <span class="string">'.html'</span>, </span><br><span class="line">            <span class="comment">// 在 dist/index.html 的输出</span></span><br><span class="line">            filename: filename + <span class="string">'.html'</span>, </span><br><span class="line">            <span class="comment">// 页面模板需要加对应的js脚本，如果不加这行则每个页面都会引入所有的js脚本</span></span><br><span class="line">            chunks: [<span class="string">'manifest'</span>, <span class="string">'vendor'</span>, filename], </span><br><span class="line">            inject: <span class="literal">true</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (configs) &#123;</span><br><span class="line">            conf = merge(conf, configs)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">            conf = merge(conf, &#123;</span><br><span class="line">                minify: &#123;</span><br><span class="line">                    removeComments: <span class="literal">true</span>, <span class="comment">// 删除 html 中的注释代码</span></span><br><span class="line">                    collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 删除 html 中的空白符</span></span><br><span class="line">                    <span class="comment">// removeAttributeQuotes: true // 删除 html 元素中属性的引号</span></span><br><span class="line">                &#125;,</span><br><span class="line">                chunksSortMode: <span class="string">'manual'</span><span class="comment">// 按 manual 的顺序引入</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[filename] = conf</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* vue.config.js */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./build/utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pages: utils.setPages(),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们多页应用基于 <code>pages</code> 配置的改进就大功告成了，当你运行打包命令来查看输出结果的时候，你会发现和之前的方式相比并没有什么变化，<br>这就说明这两种方式都适用于多页的构建，但是这里还是<code>推荐</code>大家使用更便捷的 <code>pages</code> 配置</p>
<h4 id="多页面应用分页面打包"><a href="#多页面应用分页面打包" class="headerlink" title="多页面应用分页面打包"></a>多页面应用分页面打包</h4><p><strong>如果支持分项目编译打包到相应文件夹中,请看我的github <a href="https://github.com/hzfvictory/vue-mpa/blob/master/vue.config.js#L17" target="_blank" rel="noopener">编译打包到相应文件夹</a></strong></p>
<h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4><p>首先我们要明确一点就是，多页应用中的每个单页都是相互隔离的，即如果你想从 <code>page1</code> 下的路由跳到 <code>page2</code> 下的路由，<br>你无法使用 <code>vue-router</code> 中的方法进行跳转，需要使用原生方法：<code>location.href</code> 或 <code>location.replace</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;nav&quot;&gt;</span><br><span class="line">      &lt;a @click&#x3D;&quot;goFn(&#39;&#39;)&quot;&gt;Index&lt;&#x2F;a&gt; |</span><br><span class="line">      &lt;a @click&#x3D;&quot;goFn(&#39;page1&#39;)&quot;&gt;Page1&lt;&#x2F;a&gt; |</span><br><span class="line">      &lt;a @click&#x3D;&quot;goFn(&#39;page2&#39;)&quot;&gt;Page2&lt;&#x2F;a&gt; |</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        goFn(name) &#123;</span><br><span class="line">            location.href &#x3D; &#96;$&#123;process.env.BASE_URL&#125;&#96; + name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>但是为了保持和<code>Vue</code> 路由跳转同样的风格，我可以对单页之间的跳转做一下封装，<br>实现一个<code>Navigator</code> 类，类的代码可以查看本文最后的示例，封装完成后我们可以将跳转方法修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$openRouter(&#123;</span><br><span class="line">    name: name, &#x2F;&#x2F; 跳转地址</span><br><span class="line">    query: &#123;</span><br><span class="line">        text: &#39;hello&#39; &#x2F;&#x2F; 可以进行参数传递</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>将其绑定到 Vue 的原型链上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Navigator &#125; from &#39;..&#x2F;..&#x2F;common&#39; &#x2F;&#x2F; 引入 Navigator</span><br><span class="line"></span><br><span class="line">Vue.prototype.$openRouter &#x3D; Navigator.openRouter; &#x2F;&#x2F; 添加至 Vue 原型链</span><br></pre></td></tr></table></figure>

<p>至此我们已经能够成功模仿 <code>vue-router</code>进行单页间的跳转，但是需要注意的是因为其本质使用的是 <code>location</code> 跳转，所以必然会产生浏览器的刷新与重载</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>当我们完成上述路由跳转的功能后，可以在本地服务器上来进行一下测试，你会发现<code>Index</code> 首页可以正常打开，<br>但是跳转 <code>Page1、Page2</code>却仍然处于 <code>Index</code> 父组件下，这是因为浏览器认为你所要跳转的页面还是在 <code>Index</code> 根路由下，<br>同时又没有匹配到<code>Index</code> 单页中对应的路由。这时候我们服务器需要做一次重定向，将下方路由指向对应的 <code>html</code>文件即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;vue&#x2F;page1 -&gt; &#x2F;vue&#x2F;page1.html</span><br><span class="line">&#x2F;vue&#x2F;page2 -&gt; &#x2F;vue&#x2F;page2.html</span><br></pre></td></tr></table></figure>

<p>在 <code>vue.config.js</code> 中，我们需要对 <code>devServer</code> 进行配置，添加 <code>historyApiFallback</code>配置项，<br>该配置项主要用于解决 <code>HTML5 History API</code> 产生的问题，比如其 <code>rewrites</code> 选项用于重写路由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* vue.config.js */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baseUrl = <span class="string">'/vue/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: &#123;</span><br><span class="line">            rewrites: [</span><br><span class="line">                &#123; <span class="attr">from</span>: <span class="keyword">new</span> <span class="built_in">RegExp</span>(baseUrl + <span class="string">'page1'</span>), <span class="attr">to</span>: baseUrl + <span class="string">'page1.html'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">from</span>: <span class="keyword">new</span> <span class="built_in">RegExp</span>(baseUrl + <span class="string">'page2'</span>), <span class="attr">to</span>: baseUrl + <span class="string">'page2.html'</span> &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>脚手架vue-cli</category>
      </categories>
  </entry>
  <entry>
    <title>Vue之JSX封装搜索头部</title>
    <url>/2020/07/17/workspace/Frame/vue/with-search/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Vue之JSX封装搜索头部</strong></p>
<p>[[toc]]</p>
<h3 id="组件封装源码"><a href="#组件封装源码" class="headerlink" title="组件封装源码"></a>组件封装源码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;searchProps&#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      searchData: searchProps.search || &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    searchProps: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    typeInput(item) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;el-form-item prop=&#123;item.key&#125;&gt;</span><br><span class="line">          &#123;item.label !== <span class="literal">false</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"prepend small"</span>&gt;</span>&#123;item.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">          &lt;el-input</span><br><span class="line">            clearable=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">            style=&#123;&#123;<span class="attr">width</span>: <span class="string">'160px'</span>, ...item.styles&#125;&#125;</span><br><span class="line">            v-model=&#123;<span class="keyword">this</span>.searchData[item.key]&#125;</span><br><span class="line">            placeholder=&#123;<span class="string">`请输入<span class="subst">$&#123;item.name&#125;</span>`</span>&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/el-form-item&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    typeSelect(item) &#123;</span></span><br><span class="line"><span class="regexp">      return (</span></span><br><span class="line"><span class="regexp">        &lt;el-form-item prop=&#123;item.key&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &#123;item.label !== false &amp;&amp; &lt;div class="prepend small"&gt;&#123;item.name&#125;&lt;/</span>div&gt;&#125;</span><br><span class="line">          &lt;zy-select v-model=&#123;<span class="keyword">this</span>.searchData[item.key]&#125; type=&#123;item.enumType&#125; data=&#123;item.enums&#125;</span><br><span class="line">                     style=&#123;&#123;...item.styles&#125;&#125;</span><br><span class="line">                     placeholder=<span class="string">"全部"</span>/&gt;</span><br><span class="line">        &lt;<span class="regexp">/el-form-item&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    typeDatePicker(item) &#123;</span></span><br><span class="line"><span class="regexp">      return (</span></span><br><span class="line"><span class="regexp">        &lt;el-form-item prop=&#123;item.key&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &#123;item.label !== false &amp;&amp; &lt;div class="prepend small"&gt;&#123;item.name&#125;&lt;/</span>div&gt;&#125;</span><br><span class="line">          &lt;el-date-picker</span><br><span class="line">            style=&#123;&#123;<span class="attr">width</span>: <span class="string">'220px'</span>, ...item.styles&#125;&#125;</span><br><span class="line">            v-model=&#123;<span class="keyword">this</span>.searchData[item.key]&#125;</span><br><span class="line">            type=<span class="string">"daterange"</span></span><br><span class="line">            range-separator=<span class="string">"至"</span></span><br><span class="line">            start-placeholder=<span class="string">"开始日期"</span></span><br><span class="line">            end-placeholder=<span class="string">"结束日期"</span></span><br><span class="line">            value-format=<span class="string">"yyyy-MM-dd"</span></span><br><span class="line">            picker-options=&#123;&#123;...this.picker_options, ...item.pickerOptions&#125;&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/el-form-item&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    handleDom(item) &#123;</span></span><br><span class="line"><span class="regexp">      return &#123;</span></span><br><span class="line"><span class="regexp">        select: this.typeSelect(item),</span></span><br><span class="line"><span class="regexp">        datePicker: this.typeDatePicker(item),</span></span><br><span class="line"><span class="regexp">        default: this.typeInput(item),</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    typeSearchBtn() &#123;</span></span><br><span class="line"><span class="regexp">      const &#123;searchProps: &#123;onReset, onSearch&#125;&#125; = this;</span></span><br><span class="line"><span class="regexp">      const searchDom = &lt;el-button type="primary" icon="el-icon-search" onClick=&#123;this.handleSearch&#125;&gt;查询&lt;/</span>el-button&gt;</span><br><span class="line">      <span class="keyword">const</span> resetDom = <span class="xml"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">icon</span>=<span class="string">"el-icon-refresh"</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleReset&#125;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;onSearch &amp;&amp; searchDom&#125;</span><br><span class="line">          &#123;onReset &amp;&amp; resetDom&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    handleSearch() &#123;</span></span><br><span class="line"><span class="regexp">      const &#123;searchProps: &#123;onSearch&#125;&#125; = this;</span></span><br><span class="line"><span class="regexp">      onSearch &amp;&amp; onSearch(this.searchData)</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ this.$emit('search', this.searchData)  /</span><span class="regexp">/ 可以自定义父级的事件，这里没用</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    handleReset() &#123;</span></span><br><span class="line"><span class="regexp">      const &#123;searchProps: &#123;onReset&#125;&#125; = this;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ console.log(this.$refs['formData'].resetFields());</span></span><br><span class="line"><span class="regexp">      this.searchData = &#123;&#125;</span></span><br><span class="line"><span class="regexp">      onReset &amp;&amp; onReset()</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ handlerSearchData(newVal) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/   this.searchProps.formData = newVal</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  computed: &#123;</span></span><br><span class="line"><span class="regexp">    handlerSearchData() &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 这里可以直接操作父级的数据，前提是别深克隆</span></span><br><span class="line"><span class="regexp">      this.searchProps.formData = this.searchData</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ watch: &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/   /</span><span class="regexp">/ 跟上面的computed效果一样</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/   searchData: &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/     /</span><span class="regexp">/ 页面能实时获取到数据</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/     handler: 'handlerSearchData',</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/     deep: true,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/     immediate: true</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/   &#125;,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ &#125;,</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    const &#123;searchProps: &#123;fields, formData&#125;&#125; = this;</span></span><br><span class="line"><span class="regexp">    formData &amp;&amp; this.handlerSearchData</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div class="searchBox"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;el-form</span></span><br><span class="line"><span class="regexp">          props=&#123;&#123;model: this.searchData&#125;&#125;</span></span><br><span class="line"><span class="regexp">          label-width="85px"</span></span><br><span class="line"><span class="regexp">          ref="formData"</span></span><br><span class="line"><span class="regexp">          inline</span></span><br><span class="line"><span class="regexp">          class="demo-form-inline"</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          &#123;/</span>*form表单*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">          &#123;</span></span><br><span class="line"><span class="regexp">            fields.map((item) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">              return (</span></span><br><span class="line"><span class="regexp">                this.handleDom(item)[item.type || 'default']</span></span><br><span class="line"><span class="regexp">              )</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">          &#123;/</span>* 操作按钮 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">          &lt;div class="searchBtn" style="float: right"&gt;</span></span><br><span class="line"><span class="regexp">            &#123;this.typeSearchBtn()&#125;</span></span><br><span class="line"><span class="regexp">            &#123;/</span>*额外的操作按钮*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">            &#123;this.$slots.default&#125;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/el-form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="WithSearch文档"><a href="#WithSearch文档" class="headerlink" title="WithSearch文档"></a>WithSearch文档</h3><table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">作用</th>
<th align="left">类型</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">search</td>
<td align="left">搜索初始值</td>
<td align="left">object</td>
<td align="left">{}</td>
</tr>
<tr>
<td align="left">fields</td>
<td align="left">必填，搜索表单项</td>
<td align="left">array</td>
<td align="left">[]</td>
</tr>
<tr>
<td align="left">onSearch</td>
<td align="left">查询操作,只有设置了此项，查询按钮才会显示</td>
<td align="left">fun</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">onReset</td>
<td align="left">查询重置操作, 只有设置了此项，重置按钮才会显示</td>
<td align="left">fun</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">formData</td>
<td align="left">获取form表单的值，只有设置了此项，才能获取最新值，默认不获取</td>
<td align="left">object</td>
<td align="left">无</td>
</tr>
</tbody></table>
<p><strong>fields</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> searchFields = [</span><br><span class="line">  &#123;</span><br><span class="line">    key: <span class="string">'name'</span>,</span><br><span class="line">    name: <span class="string">'应用名称/ID'</span>,</span><br><span class="line">    label: <span class="literal">false</span>, <span class="comment">// 隐藏label</span></span><br><span class="line">    styles: &#123;<span class="attr">width</span>: <span class="string">'100px'</span>&#125; <span class="comment">// 宽度</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    key: <span class="string">'mediaId'</span>, <span class="comment">// 数据提交的字段</span></span><br><span class="line">    name: <span class="string">'应用分类'</span>, <span class="comment">// label的名字</span></span><br><span class="line">    type: <span class="string">'select'</span>, <span class="comment">// form的类型  默认是 input</span></span><br><span class="line">    enums: [&#123;<span class="attr">label</span>: <span class="string">'是'</span>, <span class="attr">value</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">label</span>: <span class="string">'否'</span>, <span class="attr">value</span>: <span class="number">0</span>&#125;],  <span class="comment">// 选框的数据</span></span><br><span class="line">    enumType: &#123;<span class="attr">id</span>: <span class="string">'value'</span>, <span class="attr">name</span>: <span class="string">'label'</span>&#125; <span class="comment">// 选框的数据格式化</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    key: <span class="string">'system'</span>,</span><br><span class="line">    name: <span class="string">'系统'</span>,</span><br><span class="line">    type: <span class="string">'datePicker'</span>,</span><br><span class="line">    pickerOptions: &#123; <span class="comment">// picker的一些参数</span></span><br><span class="line">      disabledDate(time) &#123;</span><br><span class="line">        <span class="keyword">return</span> time.getTime() &lt;= <span class="built_in">Date</span>.now();</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>



<h3 id="组件使用"><a href="#组件使用" class="headerlink" title="组件使用"></a>组件使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;with-search :searchProps&#x3D;&quot;searchProps&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">   data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        searchProps: &#123;</span><br><span class="line">          search: &#123;name: 112&#125;,</span><br><span class="line">          fields: searchFields,</span><br><span class="line">          onSearch: this.handleSearch,</span><br><span class="line">          onReset: this.handleReset,</span><br><span class="line">          formData: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p><code>仅仅是提供一个思路，有待完善  有待完善  ...</code></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>组件封装</category>
        <category>Vue之JSX封装搜索头部</category>
      </categories>
  </entry>
  <entry>
    <title>vue基本用法</title>
    <url>/2020/03/11/workspace/Frame/vue/vue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>vue基本用法</strong></p>
<p>[[toc]]</p>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><table>
<thead>
<tr>
<th align="left"><span style='display: block;text-align: left;'> 常用指令    </span></th>
<th align="left"><span style='display: block;text-align: left;'> 描述</span></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>v-model</strong></td>
<td align="left">双向数据绑定 把表单元素的value和data中的属性绑定到一起，表单的value发生变化，data的属性也会跟着变化</td>
</tr>
<tr>
<td align="left"><strong>v-text</strong></td>
<td align="left">把data（不只是data）中的属性值绑定到DOM元素中，会覆盖元素中原有的内容；并且不能识别字符串中的html标签</td>
</tr>
<tr>
<td align="left"><strong>v-html</strong></td>
<td align="left">把data（不只是data）中的属性值绑定到DOM元素中；并且可以识别字符串中的html标签</td>
</tr>
<tr>
<td align="left"><strong>v-if / v-else</strong></td>
<td align="left">如果v-if绑定的值为true，就显示对应的元素；如果为false，显示v-else对应的元素；注意：v-else不是必选项，但必须结合v-if使用，而v-if可以单独使用</td>
</tr>
<tr>
<td align="left"><strong>v-show</strong></td>
<td align="left">如果值为true，对应的元素就会展示，如果为false，则隐藏；</td>
</tr>
<tr>
<td align="left"><strong>v-bind</strong></td>
<td align="left">绑定动态属性，动态绑定后就可以使用data中的该属性的值；v-bind可以简写为 <strong>:</strong></td>
</tr>
<tr>
<td align="left"><strong>v-for</strong></td>
<td align="left">列表渲染</td>
</tr>
<tr>
<td align="left"><strong>v-on</strong></td>
<td align="left">事件绑定，可简写为@</td>
</tr>
<tr>
<td align="left"><strong>is</strong></td>
<td align="left">配合<code>&lt;component&gt;</code>可动态控制展示那个组件，也可以摆脱html模板的限制</td>
</tr>
</tbody></table>
<p><strong><code>v-for()</code></strong></p>
<p>与react的不同的是，react的map()只能循环对象，vue的v-for就厉害了可以遍历数组、对象、数组、字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"(item, key) of items"</span> :key=<span class="string">"key"</span>&gt;</span><br><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"(item, key) in items"</span> :key=<span class="string">"key"</span>&gt;</span><br><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"count in 10"</span> :key=<span class="string">"count"</span>&gt;&#123;&#123;count&#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 可使用in 和 of 作为分隔符,与react的map不同的是，Vue的v-for都可以用作对象,数组，数字，</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 字符串等等的遍历，默认再js中，对象不能用for of 遍历，但是vue的合成方法中是允许的【Object.keys()】。</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><span style='display: block;text-align: left;'> 事件修饰符    </span></th>
<th align="left"><span style='display: block;text-align: left;'> 描述</span></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>.prevent</strong></td>
<td align="left">阻止元素的默认行为</td>
</tr>
<tr>
<td align="left"><strong>.stop</strong></td>
<td align="left">阻止事件冒泡</td>
</tr>
<tr>
<td align="left"><strong>.capture</strong></td>
<td align="left">事件在捕获阶段触发</td>
</tr>
<tr>
<td align="left"><strong>.once</strong></td>
<td align="left">事件只会执行一次，执行完后会被移除</td>
</tr>
<tr>
<td align="left"><strong>.self</strong></td>
<td align="left">自身的事件触发时才执行事件函数</td>
</tr>
<tr>
<td align="left"><strong>.passive</strong></td>
<td align="left">事件完成才会触发  例如：@scroll.passive=”onScroll”</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=<span class="string">"doThat"</span>&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><span style='display: block;text-align: left;'> 键盘事件    </span></th>
<th align="left"><span style='display: block;text-align: left;'> 描述</span></th>
</tr>
</thead>
<tbody><tr>
<td align="left">@keydown/@keyup</td>
<td align="left">修饰符：指定按下哪个按键时/松开时才触发事件函数</td>
</tr>
<tr>
<td align="left"><strong>.enter</strong></td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left"><strong>.esc</strong></td>
<td align="left">esc键</td>
</tr>
<tr>
<td align="left"><strong>.delete</strong></td>
<td align="left">删除/退格</td>
</tr>
<tr>
<td align="left"><strong>.space</strong></td>
<td align="left">空格</td>
</tr>
<tr>
<td align="left"><strong>.tab</strong></td>
<td align="left">tab键</td>
</tr>
<tr>
<td align="left"><strong>.up</strong></td>
<td align="left">上</td>
</tr>
<tr>
<td align="left"><strong>.right</strong></td>
<td align="left">右</td>
</tr>
<tr>
<td align="left"><strong>.down</strong></td>
<td align="left">下</td>
</tr>
<tr>
<td align="left"><strong>.left</strong></td>
<td align="left">左</td>
</tr>
</tbody></table>
<h3 id="class与style如何动态绑定"><a href="#class与style如何动态绑定" class="headerlink" title="class与style如何动态绑定"></a>class与style如何动态绑定</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;p :class&#x3D;&quot;&#123; active: isActive, &#39;text-danger&#39;: hasError &#125;&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p v-bind:class&#x3D;&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;!--直接添加样式--&gt;</span><br><span class="line">    &lt;p style&#x3D;&quot;background-color: blue;&quot;&gt;sssss&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;!--绑定样式--&gt;</span><br><span class="line">    &lt;p v-bind:style&#x3D;&quot;&#39;background-color: red;&#39;&quot;&gt;sssss&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;!--将vue中的属性作为样式设置--&gt;</span><br><span class="line">    &lt;p :style&#x3D;&quot;obj&quot;&gt;sssss&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;!--将多个属性作为样式设置--&gt;</span><br><span class="line">    &lt;p :style&#x3D;&quot;[obj,obj1]&quot;&gt;sssss&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;!--style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值 --&gt;</span><br><span class="line">    &lt;div :style&#x3D;&quot;&#123; display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#box&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            isActive: true,</span><br><span class="line">            hasError: false,</span><br><span class="line">            errorClass: &#39;text-danger&#39;,</span><br><span class="line">            obj:&#123;</span><br><span class="line">                backgroundColor:&quot;gold&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            obj1:&#123;</span><br><span class="line">                fontSize: &quot;30px&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="vue中一些小技巧"><a href="#vue中一些小技巧" class="headerlink" title="vue中一些小技巧"></a>vue中一些小技巧</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问父级组件实例,可以直接通过这个方法，访问到父组件定义的属性，也可直接修改，（不建议修改）</span></span><br><span class="line"><span class="keyword">this</span>.$parent</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来获取定义在data外的数据和方法的。</span></span><br><span class="line"><span class="keyword">this</span>.$options</span><br></pre></td></tr></table></figure>

<h3 id="props类型"><a href="#props类型" class="headerlink" title="props类型"></a>props类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> props: &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">        type: [String, Number],</span><br><span class="line">        default: &#39;标题&#39;,</span><br><span class="line">        required: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 自定义验证函数</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !&#x3D;&#x3D; -1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">props: &#123;</span><br><span class="line">  title: String,</span><br><span class="line">  likes: Number,</span><br><span class="line">  isPublished: Boolean,</span><br><span class="line">  commentIds: Array,</span><br><span class="line">  author: Object,</span><br><span class="line">  callback: Function,</span><br><span class="line">  contactsPromise: Promise,</span><br><span class="line">  time:Date</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组件components"><a href="#组件components" class="headerlink" title="组件components"></a>组件components</h3><h4 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h4><p>在直接import导入在components里面注册下就能用了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> compB <span class="keyword">from</span> <span class="string">'./components/CompB'</span></span><br><span class="line">    <span class="keyword">import</span> compA <span class="keyword">from</span> <span class="string">'./components/CompA'</span></span><br><span class="line">    <span class="keyword">import</span> CompC <span class="keyword">from</span> <span class="string">'./components/CompC'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">            compA,</span><br><span class="line">            compB,</span><br><span class="line">            CompC,</span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h4><p>在main.js里面注册下，就可以全局直接用了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> CompA <span class="keyword">from</span> <span class="string">"./components/CompA"</span></span><br><span class="line">Vue.component(<span class="string">"com-a"</span>, CompA);</span><br></pre></td></tr></table></figure>

<h3 id="过滤器filter"><a href="#过滤器filter" class="headerlink" title="过滤器filter"></a>过滤器filter</h3><h4 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="局部过滤器"></a>局部过滤器</h4><p>写在Vue实例中的<code>filters</code>内的过滤器是局部过滤器；只能在当前组件可以使用</p>
<ul>
<li>过滤器可以连续使用，后面的过滤器的参数，是上一个过滤器的处理结果，数据会展示成最后一个过滤器的结果</li>
<li>过滤器可以传参，参数是传给第二个形参的，第一个参数是管道符前面的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123;item.price | toRMB | toFixed(<span class="number">3</span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">    products: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'MAC'</span>,</span><br><span class="line">            price: <span class="number">2000</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'iphoneX'</span>,</span><br><span class="line">            price: <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">filters: &#123; <span class="comment">// 写在filters里面的过滤器是局部过滤器</span></span><br><span class="line">    toRMB (val) &#123;</span><br><span class="line">        <span class="keyword">return</span> val * <span class="number">6.832423</span></span><br><span class="line">    &#125;,</span><br><span class="line">    toFixed (val, num = <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'¥'</span> + val.toFixed(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h4><p><code>Vue.filter(过滤器名, callback)</code> 这种过滤器在任何地方都能使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.filter(<span class="string">'toRMB'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">return</span> val * <span class="number">6.832423</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 组件内部使用</span></span><br><span class="line">&#123;&#123;item.price | toRMB&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义全局方法"><a href="#自定义全局方法" class="headerlink" title="自定义全局方法"></a>自定义全局方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mian.js</span></span><br><span class="line"><span class="comment">//  全局的方法</span></span><br><span class="line">Vue.prototype.$fetch = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(url).then(<span class="function"><span class="params">e</span> =&gt;</span> e.json()).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义全局指令</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> directives = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动下滑到底部指令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    autoscroll: &#123;</span><br><span class="line">        <span class="comment">// componentUpdated:VNode 及其子 VNode 全部更新后调用</span></span><br><span class="line">        componentUpdated: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> scrollHeight = el.scrollHeight</span><br><span class="line">            <span class="keyword">let</span> clientHeight = el.clientHeight</span><br><span class="line"></span><br><span class="line">            scrollHeight &gt; clientHeight &amp;&amp; (el.scrollTop = scrollHeight)</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">    focus: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(directives).map(<span class="function"><span class="params">t</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.directive(t, directives[t])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部自定义的指令</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input ref=<span class="string">"input"</span> v-focus v-model=<span class="string">"val"</span> type=<span class="string">"text"</span>&gt;</span><br><span class="line">    &lt;strong v-demo=<span class="string">"&#123; color: 'red' &#125;"</span>&gt;<span class="number">111</span>默认的slot&lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        directives: &#123;</span><br><span class="line">            <span class="comment">// 局部自定义指令</span></span><br><span class="line">            focus: &#123;</span><br><span class="line">                inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">                    el.focus()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            demo: &#123;</span><br><span class="line">                inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">                  <span class="comment">// el当前的dom</span></span><br><span class="line">                  <span class="comment">//  binding 指令的一些信息 name: "demo"</span></span><br><span class="line">                  <span class="comment">//                       rawName: "v-demo"</span></span><br><span class="line">                  <span class="comment">//                       value: &#123;color: "red"&#125;</span></span><br><span class="line">                    <span class="built_in">console</span>.log(el.style.color = binding.value.color)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 全局组件</span></span><br><span class="line"><span class="regexp">Vue.component("counter", About);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 全局mixin</span></span><br><span class="line"><span class="regexp">Vue.mixin(mixin);</span></span><br></pre></td></tr></table></figure>

<h4 id="VUE自定义指令"><a href="#VUE自定义指令" class="headerlink" title="VUE自定义指令"></a>VUE自定义指令</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>,&#123;</span><br><span class="line">    bind() &#123;</span><br><span class="line">      <span class="comment">// 当指令绑定到 HTML 元素上时触发.**只调用一次**</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'bind triggerd'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    inserted: <span class="function">(<span class="params">el, binding, vnode</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 当绑定了指令的这个HTML元素插入到父元素上时触发(在这里父元素是 `div#app`)**.但不保证,父元素已经插入了 DOM 文档.**</span></span><br><span class="line">      <span class="built_in">console</span>.log(el, <span class="string">'当前的dom'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(binding, <span class="string">'指令信息集'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(vnode, <span class="string">'dom信息'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'inserted triggerd'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    updated() &#123;</span><br><span class="line">      <span class="comment">// 所在组件的`VNode`更新时调用.</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'updated triggerd'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    componentUpdated() &#123;</span><br><span class="line">      <span class="comment">// 指令所在组件的 VNode 及其子 VNode 全部更新后调用。</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'componentUpdated triggerd'</span>)</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    unbind() &#123;</span><br><span class="line">      <span class="comment">// 只调用一次，指令与元素解绑时调用.</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'unbind triggerd'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>钩子函数参数</strong></p>
<p>指令钩子函数会被传入以下参数：</p>
<ul>
<li><p><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM 。</p>
</li>
<li><p><code>binding</code> ：一个对象，包含以下属性：</p>
<ul>
<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li>
<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>
<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>
<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>
<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>
<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li>
</ul>
</li>
<li><p><code>vnode</code>：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。</p>
</li>
<li><p><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</p>
</li>
</ul>
<h3 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h3><p>在开发中有这么一种情况，当你有两个非常相似的组件，它们的功能极其相似，但它们局部稍有不同，现在你的做法是将它们分成两个不同的组件？还是只保留一个组件，局部差异的部分采用<code>props</code>控制呢？</p>
<p>如果将它们拆分为两个不同的组件，这时功能发生变化，那么必须在两个地方修改它们，如果用props来区分它们，那么后期维护起来将会很复杂，可能减慢你开发的速度</p>
<p><code>Vue</code>中的<code>Mixins</code>基本上是一块定义的逻辑，由Vue以特定的规定方式存储，可以反复使用，为<code>Vue</code>实例和组件添加功能。因此，<code>Vue mixins</code>可以在多个Vue组件之间共享，而无需重复代码块。使用过SASS的CSS预处理器的人对mixin应该有很好的了解。</p>
<p>组件内部有跟mixins里面一样的方法时，组件内部的优先级高与mixins</p>
<h4 id="局部mixins"><a href="#局部mixins" class="headerlink" title="局部mixins"></a>局部mixins</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//assets/mixins/mixin.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toggle = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="string">"show"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeState() &#123;</span><br><span class="line">      <span class="keyword">this</span>.show = !<span class="keyword">this</span>.show;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">      <span class="comment">// 默认每次都会执行</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'created'</span>, <span class="string">'mixins'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'mounted'</span>, <span class="string">'mixins'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">     &lt;h1 @click=<span class="string">"changeState"</span>&gt;mixins&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">     &lt;h2 v-if="show"&gt;toast&lt;/</span>h2&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;toggle&#125; <span class="keyword">from</span> <span class="string">'./mixins/toggle'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mixins: [toggle]</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="comment">//这里面可以正常写，优先级高于mixin的方法。</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="全局mixins"><a href="#全局mixins" class="headerlink" title="全局mixins"></a>全局mixins</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> mixin = &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        formatDate(dateTime) &#123;</span><br><span class="line">            <span class="keyword">return</span> dateTime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Vue.mixin(mixin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件里面使用</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.formatDate(<span class="keyword">new</span> <span class="built_in">Date</span>()),<span class="string">'mixins'</span>);</span><br></pre></td></tr></table></figure>

<p>注意：请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项</p>
<h3 id="vue-组件间通信有哪几种方式"><a href="#vue-组件间通信有哪几种方式" class="headerlink" title="vue 组件间通信有哪几种方式"></a>vue 组件间通信有哪几种方式</h3><h4 id="props-emit"><a href="#props-emit" class="headerlink" title="props/$emit"></a>props/$emit</h4><p>适用 父子组件通信</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;div @click&#x3D;&quot;onMore(&#39;值&#39;)&quot;&gt;</span><br><span class="line">            父组件</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;compB</span><br><span class="line">                :title.sync&#x3D;&quot;value&quot;</span><br><span class="line">                @more&#x3D;&quot;onMore&quot;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import compB from &#39;.&#x2F;components&#x2F;CompB&#39;</span><br><span class="line"></span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &#39;App&#39;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            compB</span><br><span class="line">        &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                value: &#39;&#39;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            onMore(val) &#123;</span><br><span class="line">                console.log(val);</span><br><span class="line">                &#x2F;&#x2F; this.value &#x3D; val</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;title&quot;&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div @click&#x3D;&quot;handleMore&quot;&gt;子组件修改父组件的值&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;!--&lt;div @click&#x3D;&quot;$emit(&#39;update:title&#39;, &#39;false&#39;)&quot;&gt;子组件修改父组件的值&lt;&#x2F;div&gt;--&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &#39;Comb&#39;,</span><br><span class="line">        components: &#123;&#125;,</span><br><span class="line">        props: &#123;</span><br><span class="line">            title: &#123;</span><br><span class="line">                type: [String, Number],</span><br><span class="line">                default: &#39;标题&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            moreBtn: &#123;</span><br><span class="line">                type: Boolean,</span><br><span class="line">                default: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handleMore() &#123;</span><br><span class="line">                this.$emit(&#39;update:title&#39;, &#39;sync方式修改&#39;);</span><br><span class="line">                this.$emit(&#39;more&#39;, 111);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="emit-on"><a href="#emit-on" class="headerlink" title="$emit/$on"></a>$emit/$on</h4><p>适用于 父子、隔代、兄弟组件通信</p>
<h3 id="defineProperty-的不足"><a href="#defineProperty-的不足" class="headerlink" title="defineProperty 的不足"></a>defineProperty 的不足</h3><ul>
<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ul>
<h4 id="解决的办法"><a href="#解决的办法" class="headerlink" title="解决的办法"></a>解决的办法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// vm.$set，Vue.set的一个别名,当前组件的实例</span></span><br><span class="line">vm.$<span class="keyword">set</span>(vm.items, indexOfItem, newValue)</span><br><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>

<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick()"></a>nextTick()</h3><p>Vue 的特点之一就是响应式，但数据更新时，DOM 并不会立即更新。当我们有一个业务场景，需要在 DOM 更新之后再执行一段代码时，可以借助nextTick实现。</p>
<p>Vue的DOM更新不是同步的，而是异步的，如果我们希望获取更新数据后渲染出来的DOM，<br>我们需要使用 <strong>$nextTick；this.$nextTick(callback),</strong> callback会在DOM更新以后执行（如果想要在DOM更新后操作DOM，或者在DOM更新后有其他的事情，要用$nextTick）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;li v-for&#x3D;&quot;(item, index) in ary&quot;</span><br><span class="line">    :key&#x3D;&quot;item.id&quot;</span><br><span class="line">    ref&#x3D;&quot;listItem&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        ary: [1, 3, 5]</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        console.log(this.$refs.listItem.length)</span><br><span class="line">        this.ary.push(7, 9)</span><br><span class="line">        &#x2F;&#x2F; console.log(this.$refs.listItem.length) &#x2F;&#x2F; 为什么还是3，而不是5呢？</span><br><span class="line">        &#x2F;&#x2F; 因为Vue更新DOM的机制是异步的；push 7，9后并没有直接就去更新DOM，而是先等同步任务执行完，才去执行异步的更新DOM</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果一定要获取更新数据以后的DOM，要用$nextTick</span><br><span class="line">        this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; $nextTick 会把回调函数放到DOM更新以后执行</span><br><span class="line">            console.log(this.$refs.listItem.length)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="computed-amp-watch"><a href="#computed-amp-watch" class="headerlink" title="computed &amp; watch **"></a>computed &amp; watch **</h3><p><strong>computed 计算属性</strong></p>
<ol>
<li>页面加载时就求值；支持缓存，如果依赖的数据发生改变，才会重新计算</li>
<li>不支持异步</li>
<li>如果一个属性是由其他属性计算而来，这个属性依赖其他属性，依赖发生变化时自动求取最新的计算结果</li>
</ol>
<p><strong>watch 观察属性</strong></p>
<ol>
<li>页面加载时不求值，依赖值发生改变时才求值</li>
<li>watch 支持异步</li>
<li>watch只能监听一个属性的变化，如果有属性依赖这个结果，那么需要手动去重新计算这个结果；</li>
</ol>
<blockquote>
<p><strong><code>栗子</code></strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot; &#x2F;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot; &#x2F;&gt;</span><br><span class="line">  &#123;&#123;fullName&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      firstName: &#39;&#39;,</span><br><span class="line">      lastName: &#39;&#39;,</span><br><span class="line">      fullName: &#39;&#39;,</span><br><span class="line">      obj:&#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      fullName () &#123;</span><br><span class="line">        return this.lastName + this.firstName;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      firstName(newVal, oldVal) &#123;</span><br><span class="line">        this.fullName &#x3D; this.lastName + newVal;</span><br><span class="line">      &#125;,</span><br><span class="line">      lastName(nawVal, oldVal) &#123;</span><br><span class="line">        this.fullName &#x3D; newVal + this.firstName;</span><br><span class="line">      &#125;,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        handler: &#39;sayName&#39; , &#x2F;&#x2F; 这里是字符串</span><br><span class="line">        immediate: true, &#x2F;&#x2F; 立即执行</span><br><span class="line">        &#x2F;&#x2F; deep: true   &#x2F;&#x2F; 深度监控</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">       sayName() &#123;</span><br><span class="line">           console.log(this.name)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter  默认只有getter方法</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter  我们可以手动添加setter方法，做一些中间处理</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用ref"><a href="#使用ref" class="headerlink" title="使用ref"></a>使用ref</h3><ul>
<li>首先在要获取的元素添加ref=”标识符”的行内属性</li>
<li>获取的时候this.$refs.标识符获取元素</li>
<li>如果相同的一个ref有一个，获取到的就是带这个ref的原生元素对象</li>
<li>如果相同ref的有多个，获取到的是所有带有这个ref的元素组成的数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p ref&#x3D;&quot;box&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">this.$refs.box.style.color &#x3D; &#39;red&#39;</span><br></pre></td></tr></table></figure>

<h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide/inject"></a>provide/inject</h3><p>provide 和 inject 主要为高阶插件/组件库提供用例。与 React 的上下文特性很相似。</p>
<p>inject/provide 本质还是通过$parent向上查找祖先节点数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'u-form'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        title: <span class="built_in">String</span>,</span><br><span class="line">        labelWidth: <span class="built_in">String</span>,</span><br><span class="line">        contentWidth: <span class="built_in">String</span>,</span><br><span class="line">        okButton: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">default</span>: <span class="string">'确定'</span> &#125;,</span><br><span class="line">        cancelButton: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">default</span>: <span class="string">'取消'</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    provide() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            uForm: <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'u-form-item'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        label: <span class="built_in">String</span>,</span><br><span class="line">        error: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="built_in">Boolean</span>,</span><br><span class="line">        tip: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            leftSty: &#123;&#125;,</span><br><span class="line">            rightSty: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    inject: [<span class="string">'uForm'</span>],</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="keyword">this</span>.uForm.labelWidth &amp;&amp; (<span class="keyword">this</span>.leftSty.width = <span class="keyword">this</span>.uForm.labelWidth)</span><br><span class="line">        <span class="keyword">this</span>.uForm.contentWidth &amp;&amp; (<span class="keyword">this</span>.rightSty.width = <span class="keyword">this</span>.uForm.contentWidth)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this-once-amp-amp-钩子事件hookEvent"><a href="#this-once-amp-amp-钩子事件hookEvent" class="headerlink" title="this.$once() &amp;&amp; 钩子事件hookEvent"></a>this.$once() &amp;&amp; 钩子事件hookEvent</h3><p>this.$once(‘hook:beforeDestroy’,callback)</p>
<p><strong>只针对钩子函数</strong></p>
<p>清除定时器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以用这个方式离开页面之前可以清除定时器</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">   <span class="comment">// console.log(this.$options.data())</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">   <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now())</span><br><span class="line">   &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.$once(<span class="string">'hook:beforeDestroy'</span>, () =&gt; &#123;</span><br><span class="line">     clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>监控子组件的生命周期</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以侦查组件的钩子函数</span></span><br><span class="line">&lt;List @hook:mounted=<span class="string">"listenMounted"</span> /&gt;</span><br></pre></td></tr></table></figure>


<h3 id="vue样式穿透"><a href="#vue样式穿透" class="headerlink" title="vue样式穿透"></a>vue样式穿透</h3><p>在开发中修改第三方组件样式是很常见，但由于 scoped 属性的样式隔离，可能需要去除 scoped 或是另起一个 style 。这些做法都会带来副作用（组件样式污染、不够优雅），样式穿透在css预处理器中使用才生效。</p>
<p>深度作用选择器有<code>&gt;&gt;&gt;</code>和别名<code>/deep/</code></p>
<p><code>&gt;&gt;&gt;</code>基本在纯css中使用，类似Sass，less的Css预编译器一般都用<code>/deep/</code>，但是eslint 可能不被通过，所以可以使用<code>::v-deep</code>代替</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">::v-deep .el-table thead tr,::v-deep .el-table thead tr th &#123;</span><br><span class="line">  background: rgba(<span class="number">235</span>, <span class="number">238</span>, <span class="number">245</span>, <span class="number">0.27</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>函数式组件是无状态，它无法实例化，没有任何的生命周期和方法。创建函数式组件也很简单，只需要在模板添加 functional 声明即可。一般适合只依赖于外部数据的变化而变化的组件，因其轻量，渲染性能也会有所提高。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"list"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span> v-<span class="keyword">for</span>=<span class="string">"item in props.list"</span> :key=<span class="string">"item.id"</span> @click=<span class="string">"props.itemClick(item)"</span>&gt;</span><br><span class="line">            &lt;p&gt;&#123;&#123;item.title&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;&#123;&#123;item.content&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期**"></a>生命周期**</h3><table>
<thead>
<tr>
<th align="left"><span style='display: block;text-align: left;'> 生命周期    </span></th>
<th align="left"><span style='display: block;text-align: left;'> 描述</span></th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td align="left">组件实例被创建之初，组件的属性生效之前</td>
</tr>
<tr>
<td align="left">created</td>
<td align="left">组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td align="left">update</td>
<td align="left">组件数据更新之后</td>
</tr>
<tr>
<td align="left">activated</td>
<td align="left"><code>keep-alive 专属</code>，组件被激活时调用</td>
</tr>
<tr>
<td align="left">deactivated</td>
<td align="left"><code>keep-alive 专属</code>，组件被销毁时调用</td>
</tr>
<tr>
<td align="left">beforeDestory</td>
<td align="left">组件销毁前调用</td>
</tr>
<tr>
<td align="left">destoryed</td>
<td align="left">组件销毁后调用</td>
</tr>
</tbody></table>
<h3 id="路由使用"><a href="#路由使用" class="headerlink" title="路由使用"></a>路由使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">"/"</span>,</span><br><span class="line">    redirect: <span class="string">"/accountSum"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/accountDetails/id:?"</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/AccountDetails.vue'</span>),</span><br><span class="line">    meta: &#123;<span class="attr">keepAlive</span>: <span class="literal">true</span>,&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    path: <span class="string">"*"</span>,</span><br><span class="line">    redirect: <span class="string">"/accountSum"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">"history"</span>,<span class="comment">//默认是hash模式</span></span><br><span class="line">  routes,</span><br><span class="line">  <span class="comment">// linkActiveClass: "active"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="路由的方法"><a href="#路由的方法" class="headerlink" title="路由的方法"></a>路由的方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.back()  <span class="comment">// 回退</span></span><br><span class="line"><span class="keyword">this</span>.$router.go(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$router.replace()</span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">`/permission/role-detail/<span class="subst">$&#123;val&#125;</span>`</span>);  <span class="comment">// 跳转到当前role-detail页面</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> &#123;name, meta, path, params, fullPath, query, hash&#125; = <span class="keyword">this</span>.$route <span class="comment">// 获取值</span></span><br></pre></td></tr></table></figure>

<h4 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js 入口文件</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>; <span class="comment">// 引入路由</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123; </span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'afterEach 全局后置钩子'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: workspace,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="comment">// 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="AJAX数据调取"><a href="#AJAX数据调取" class="headerlink" title="AJAX数据调取"></a>AJAX数据调取</h3><p>可以在钩子函数 <code>created、beforeMount、mounted</code> 中进行调用，因为在这三个钩子函数中，data 已经创建，<br>可以将服务端端返回的数据进行赋值。推荐在 <code>created</code> 钩子函数中调用异步请求，因为在 <code>created</code> 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 loading 时间；</li>
<li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   data () &#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">        commitList:[],</span><br><span class="line">        show:<span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">      <span class="keyword">async</span> queryCommit()&#123;</span><br><span class="line">       <span class="keyword">this</span>.show = <span class="literal">true</span></span><br><span class="line">       <span class="keyword">this</span>.commitList =  <span class="keyword">await</span> fetch(<span class="string">`https://api.xxxx.cn`</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                method: <span class="string">'GET'</span>,</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    <span class="string">'Authorization'</span>: <span class="string">'token xxxx'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         ).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">                <span class="keyword">this</span>.show = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span> response.json();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'接口调取失败！'</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   created()&#123;</span><br><span class="line">       <span class="keyword">this</span>.queryCommit();</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语法示例"><a href="#语法示例" class="headerlink" title="语法示例*"></a>语法示例*</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;!-- 小胡子语法 --&gt;</span><br><span class="line">    &#123;&#123; msg &#125;&#125;</span><br><span class="line"></span><br><span class="line">    &lt;!-- v-on事件绑定，可简写为 @ --&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button v-on="reverseMsg"&gt;点击翻转&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- v-bind数据动态绑定，可简写为 : --&gt;</span><br><span class="line">    &lt;span v-bind:message=<span class="string">"msgTime"</span>&gt;创建时间&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;!-- v-if/</span>v-<span class="keyword">else</span>/v-show控制元素出现（v-<span class="keyword">if</span>和v-<span class="keyword">else</span>直接操作的DOM；v-show控制的是style） --&gt;</span><br><span class="line">    &lt;p v-<span class="keyword">if</span>=<span class="string">"seen"</span>&gt;Now you see <span class="keyword">this</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p v-else&gt;Now you see that&lt;/</span>p&gt;</span><br><span class="line">    &lt;p v-show=<span class="string">"seen"</span>&gt;This is v-show<span class="string">'s content&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;!-- v-for列表渲染，可渲染对象、数组、字符串、数字，生成谁就v-for谁，v-for之后一定要写:key属性 --&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li v-for="(item, index) in toDoList" :key="item.id"&gt;</span></span><br><span class="line"><span class="string">            &#123;&#123; index &#125;&#125;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;!-- v-text/v-html将属性绑定到DOM元素中，text不识别标签，html识别 --&gt;</span></span><br><span class="line"><span class="string">    &lt;div v-text="title"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div v-html="title"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;!-- v-model双向数据绑定，注意只能绑定表单元素 --&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; phone &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="text" v-model="phone"/&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">new Vue(&#123;</span></span><br><span class="line"><span class="string">    // 绑定根DOM元素节点，在此元素节点下的操作都可以被vue识别</span></span><br><span class="line">    el : '#app',</span><br><span class="line">    <span class="comment">// 储存</span></span><br><span class="line">    data : &#123;</span><br><span class="line">        msg : <span class="string">'Hello World'</span>,</span><br><span class="line">        msgTime : <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString(),</span><br><span class="line">        seen : <span class="literal">true</span>,</span><br><span class="line">        toDoList : [</span><br><span class="line">            &#123;<span class="attr">item</span> : sleep&#125;,</span><br><span class="line">            &#123;<span class="attr">item</span> : eat&#125;</span><br><span class="line">        ],</span><br><span class="line">        title : <span class="string">'&lt;h2&gt;这是个title&lt;/h2&gt;'</span>,</span><br><span class="line">        phone : <span class="string">'231231231'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    methods : &#123;</span><br><span class="line">        reverseMsg () &#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = <span class="keyword">this</span>.msg.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 用于处理数据，但是不会改变原数据的数据处理方式，一般用来格式化数据（文本数据格式化）</span></span><br><span class="line">    filters: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 侦听器属性，是一个对象；键是需要观察的表达式，值是对应的回调函数；当被观察的表达式的值发生变化之后，会用对应的回调函数完成相应的监视操作</span></span><br><span class="line">    watch: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 计算属性，基于依赖进行缓存，只有当缓存发生改变时才会重新求值；不要放入过多的逻辑，不能与data中的属性重名，否则会报错</span></span><br><span class="line">    computed: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 挂载局部组件，只能当前使用</span></span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="comment">// 一个字符串模板作为 Vue 实例的标识使用</span></span><br><span class="line">        template: <span class="string">``</span>,</span><br><span class="line">        <span class="comment">// 创建props及其传递过来的属性</span></span><br><span class="line">        props: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生命周期的钩子函数 - 一个组件从开始到毁灭的过程</span></span><br><span class="line">    beforeCreate () &#123;&#125;, <span class="comment">// 初始化实例后，数据观测前</span></span><br><span class="line">    created () <span class="comment">// 在这儿可以调用methods中的方法、改变data数据；常用来发送请求，获取数据</span></span><br><span class="line">        axios.get/post/all() <span class="comment">// axios获取ajax的数据</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount () &#123;&#125;, <span class="comment">// 挂载开始之前</span></span><br><span class="line">    mounted () &#123;&#125;, <span class="comment">// 已挂载，可以获取、操作el的DOM元素</span></span><br><span class="line">    beforeUpdate () &#123;&#125;, <span class="comment">// 数据更新时，获取的数据是更新之后的，但页面中的DOM元素是更新之前的</span></span><br><span class="line">    updated () &#123;&#125;, <span class="comment">// DOM已更新，可以执行依赖DOM的操作</span></span><br><span class="line">    beforeDestroy () &#123;&#125;, <span class="comment">// 实例销毁之前，此时所有方法都可调用，常用来执行清理任务</span></span><br><span class="line">    destroyed () &#123;&#125;, <span class="comment">// 实例销毁之后，所有事件、子实例都会销毁</span></span><br><span class="line">&#125;);</span><br><span class="line">vm.$<span class="keyword">set</span>(vm.toDoList, item, play) // 向data中新增属性需要使用$<span class="keyword">set</span>方法</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>Vuex是一个专为Vue应用程序开发的状态管理模式。每一个Vuex应用的核心就是store,就是一个容器，它包含着你的应用中大部分的状态state。</p>
<p><strong>主要包括以下几个模块：</strong></p>
<ul>
<li><strong>State</strong>：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li>
<li><strong>Getter</strong>：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
<li><strong>Mutation</strong>：是唯一更改 store 中状态的方法，且必须是同步函数，<code>相当于rudex的reducer</code></li>
<li><strong>Action</strong>：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作，<code>相当于rudex的action</code></li>
<li><strong>Module</strong>：允许将单一的 Store 拆分为多个store且同时保存在单一的状态树中。</li>
</ul>
<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><pre><code>├── main.js
├── api
│   └── ... // API请求
├── components 
│   ├── App.vue
│   └── ...
└── store
    ├── index.js          # 我们组装模块并导出 store 的地方
    ├── actions.js        # 根级别的 action
    ├── mutations.js      # 根级别的 mutation
    └── modules
        └── test.js       # 测试demo</code></pre><h4 id="vuex配置"><a href="#vuex配置" class="headerlink" title="vuex配置"></a>vuex配置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules/test.js</span></span><br><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">       <span class="comment">// state就是数据，如果数据定义在state中组件中如果要使用这个数据：默认是this.$store.state.属性名 的方式获取</span></span><br><span class="line">        count: <span class="number">15</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">      <span class="comment">// state 中的数据不能被直接修改，如果要修改这些数据，需要使用mutation，注意mutation中不能使用异步更新state</span></span><br><span class="line">      <span class="comment">// 组件中使用this.$store.commit('add')更新</span></span><br><span class="line">        add(state, payload) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(payload);</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">      <span class="comment">// action可以使用异步，但是更新数据仍然需要 commit 对应的mutation</span></span><br><span class="line">      <span class="comment">// 组件中使用this.$store.dispatch('syncAdd')更新</span></span><br><span class="line">        syncAdd(context) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                context.commit(<span class="string">'add'</span>, <span class="number">11</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">       <span class="keyword">async</span> asyncAdd(context, val) &#123;</span><br><span class="line">           <span class="keyword">await</span> <span class="built_in">console</span>.log(val);</span><br><span class="line">            context.commit(<span class="string">'add'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123; <span class="comment">// 跟在外面单独声明是一样的</span></span><br><span class="line">        getCount(state) &#123; <span class="comment">// this.$store.getters.getCount</span></span><br><span class="line">            <span class="keyword">return</span> state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> test</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getters.js</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line"> <span class="comment">// this.$store.getters.count</span></span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.test.count,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getters</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">'./getters'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过node的 require.context，获取所有的的文件目录,不需要每次显式的调用import导入模块</span></span><br><span class="line"><span class="keyword">const</span> files = <span class="built_in">require</span>.context(<span class="string">'./modules'</span>, <span class="literal">false</span>, /\.js$/);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">files.keys().forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name = path.basename(key, <span class="string">'.js'</span>); <span class="comment">// 当前文件的名字，没有后缀</span></span><br><span class="line">    modules[name] = files(key).default || files(key)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules,</span><br><span class="line">    getters, <span class="comment">// 这里也可以写在modules里面</span></span><br><span class="line">    strict: debug,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 这个数组里面是函数</span></span><br><span class="line">        (...state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(state);</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import store from &quot;.&#x2F;store&quot;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store, &#x2F;&#x2F; 这里导入就可以this.$store使用了</span><br><span class="line">    render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="组件中使用"><a href="#组件中使用" class="headerlink" title="组件中使用"></a>组件中使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1 @click&#x3D;&quot;changeCount&quot;&gt;Vuex&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;mapMutations, mapState, mapActions, mapGetters&#125; from &#39;vuex&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;test&#39;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#x2F;&#x2F;  num: this.$store.state.test.count  &#x2F;&#x2F;这里获取只会加载一次，不能动态响应</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">      &#x2F;&#x2F; console.log(&#96;%c store&#96;, &#96;color:#42b983&#96;, this.$store.state.test.count);</span><br><span class="line">      &#x2F;&#x2F; console.log(&#96;%c store&#96;, &#96;color:#42b983&#96;, this.$store.getters.count);</span><br><span class="line">      console.log(&#96;%c store&#96;, &#96;color:#42b983&#96;, this.$store);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeCount() &#123;</span><br><span class="line">      &#x2F;&#x2F; this.$store.commit(&#39;add&#39;); &#x2F;&#x2F; 在不使用辅助函数，默认是这么用的  对应的是mutations</span><br><span class="line">      &#x2F;&#x2F; this.$store.dispatch(&#39;syncAdd&#39;); &#x2F;&#x2F; 对应的是actions</span><br><span class="line">      this.add();  &#x2F;&#x2F; 这里是使用辅助函数之后的用法</span><br><span class="line">      this.syncAdd()</span><br><span class="line">    &#125;,</span><br><span class="line">    ...mapMutations([&#39;add&#39;]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">        syncAdd: &#39;syncAdd&#39; &#x2F;&#x2F; 可重命名</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">      &#x2F;&#x2F; vuex 的数据建议在这里面声明，可保持页面的整洁</span><br><span class="line">      &#x2F;&#x2F; count() &#123;</span><br><span class="line">      &#x2F;&#x2F;     return this.$store.state.test.count</span><br><span class="line">      &#x2F;&#x2F; &#125;,</span><br><span class="line">      ...mapGetters([&#39;count&#39;]), &#x2F;&#x2F; 跟上面的一致</span><br><span class="line">      ...mapState(&#123;  &#x2F;&#x2F; 直接砸容器内部获取值</span><br><span class="line">          num: state &#x3D;&gt; state.test.count  &#x2F;&#x2F; 如果外面有num的字段，外面的优先级高</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="element-ui"><a href="#element-ui" class="headerlink" title="element ui"></a>element ui</h3><h4 id="form表单自定义验证规则"><a href="#form表单自定义验证规则" class="headerlink" title="form表单自定义验证规则"></a>form表单自定义验证规则</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rules &#x3D; &#123;</span><br><span class="line">    roleName: [</span><br><span class="line">        &#123;required: true, message: &#39;请输入名称&#39;, trigger: &#39;blur&#39;&#125;,</span><br><span class="line">        &#123;max: 10, message: &#39;长度超过 10 个字符&#39;, trigger: [&#39;blur&#39;, &#39;change&#39;]&#125;,</span><br><span class="line">        &#123;validator: this.repeatRoleName, trigger: &#39;blur&#39;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 查询当前名称是否已经被占用</span><br><span class="line">async repeatRoleName(rule: any, value: string, callback: (val?: string) &#x3D;&gt; void) &#123;</span><br><span class="line">    if (this.formData.tempRoleName &#x3D;&#x3D;&#x3D; value) return callback();</span><br><span class="line">    const usable &#x3D; await checkRoleName(value);</span><br><span class="line">    if (!usable) &#123;</span><br><span class="line">        callback(&#39;该角色名称已被占用&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    callback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 格式化</span><br><span class="line">&lt;el-table-column </span><br><span class="line">  min-width&#x3D;&quot;180&quot; </span><br><span class="line">  align&#x3D;&quot;right&quot;</span><br><span class="line">  prop&#x3D;&quot;cpm&quot; </span><br><span class="line">  label&#x3D;&quot;千次展现消费（元）&quot;</span><br><span class="line">  :formatter&#x3D;&quot;row &#x3D;&gt; formatterNumber(row.cpm)&quot;</span><br><span class="line">&#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F; 自定义内容</span><br><span class="line">&lt;el-table-column&gt;</span><br><span class="line">	&lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">	  &lt;span&gt;&#123;&#123;scope.row.amount&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">	&lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;el-table-column&gt;</span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vuejs</a><br><a href="https://vuex.vuejs.org/zh/guide/actions.html" target="_blank" rel="noopener">vuex</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>Vue基本用法</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphQL</title>
    <url>/2019/10/15/workspace/Server/api/GraphQL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>GraphQL</strong></p>
<p>[[toc]]</p>
<h3 id="BFF-——-Backend-For-Frontend"><a href="#BFF-——-Backend-For-Frontend" class="headerlink" title="BFF —— Backend For Frontend"></a>BFF —— Backend For Frontend</h3><p><code>BFF，即 Backend For Frontend（服务于前端的后端）,BFF 只是一种逻辑分层，而非一种技术</code></p>
<p><img style="
       width: 50%;
       transform: translateX(50%);
       "
       src='/assets/img/jiaohu.png'/></p>
<p>此时为了保障多端的不同需求，需要为不同的平台写不同的 API 接口，<br>而每当值发生一些变化时，需要多段同时做出修改,这样的代价显然相当大。</p>
<p>于是，我们就需要 BFF 作为中间件。在这个中间件上我们将做一些业务逻辑处理</p>
<p>而当我们有了 BFF 这一层时，我们就不需要考虑系统后端的迁移。后端发生的变化都可以在 BFF 层做一些响应的修改。</p>
<p><img style="
       width: 50%;
       transform: translateX(50%);
       "
       src='/assets/img/bff.png'/></p>
<h3 id="GraphQL-语言设计中的必然性"><a href="#GraphQL-语言设计中的必然性" class="headerlink" title="GraphQL 语言设计中的必然性"></a>GraphQL 语言设计中的必然性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询语法跟查询结果相近（自定义接口数据的字段）</span><br><span class="line"></span><br><span class="line">能精确查询想要的字段（请求你所要的数据不多不少）</span><br><span class="line"></span><br><span class="line">能合并多个请求到一个查询语句（获取多个资源只用一个请求）</span><br><span class="line"></span><br><span class="line">无接口版本管理问题（升级迭代几乎没影响）</span><br><span class="line"></span><br><span class="line">代码即文档。</span><br><span class="line"></span><br><span class="line">强大的开发者工具</span><br></pre></td></tr></table></figure>

<p><a href="https://graphql.cn/graphql-js/" target="_blank" rel="noopener">文档</a></p>
<p><a href="https://mp.weixin.qq.com/s/8FgP1LeO6eDd8xuIMGzIIA" target="_blank" rel="noopener">博客</a></p>
<h3 id="react需要的技术栈"><a href="#react需要的技术栈" class="headerlink" title="react需要的技术栈"></a>react需要的技术栈</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">apollo-boost 包含启动阿波罗客户端的所有依赖</span><br><span class="line">react-apollo  视图层面的集合</span><br><span class="line">graphql-tag  解析查询语句必须</span><br><span class="line">graphql 也是解析查询语句</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Server</category>
        <category>GraphQL</category>
      </categories>
      <tags>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title>本地安装Nginx踩到的坑</title>
    <url>/2019/10/15/workspace/Server/nginx/nginx_local/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>本地安装Nginx踩到的坑</strong></p>
<p>[[toc]]</p>
<h3 id="装机"><a href="#装机" class="headerlink" title="装机"></a>装机</h3><p>先进入 <code>cd /user/local/src</code> 没有<code>src</code>,<code>mkdir src</code>自行新建</p>
<p><a href="https://nginx.org/download/" target="_blank" rel="noopener">nginx下载地址</a></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line"><span class="attribute">wget</span> wget http://nginx.org/download/nginx-1.18.0.tar.gz</span><br><span class="line"></span><br><span class="line">#解压  </span><br><span class="line">tar -xzvf nginx-<span class="number">1</span>.<span class="number">18</span>.<span class="number">0</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入nginx目录</span></span><br><span class="line">cd nginx-<span class="number">1</span>.<span class="number">18</span>.<span class="number">0</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置</span></span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#make</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> /user/local/nginx</span><br><span class="line">./sbin/nginx -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常情况的信息输出：</span></span><br><span class="line"></span><br><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>

<h3 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> /usr/local/nginx/sbin</span><br><span class="line">./nginx //启动nginx</span><br></pre></td></tr></table></figure>

<p>打开<a href="http://localhost:80" target="_blank" rel="noopener">localhost</a> 默认是 80 端口，<strong>切记这里不要使用6666端口号</strong>谷歌和火狐禁用6666端口号。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H4ba122e3923a46dfa1ba5477c8d80eaax.jpg" alt=""></p>
<p>能看见这个页面说明已经成功了。</p>
<p>为了后期更好的时候nginx，可以配置下全局变量 我用的是软连接 <code>ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/</code></p>
<h3 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h3><p>既然是在本地配置的nginx就可以用编辑器打开文件了，打开访达然后 <code>shift+com+g</code> 输入 <code>/usr/local/nginx/conf</code>,然后用编辑器打开 <code>nginx.conf</code>配置文件</p>
<p>打开后是大致是这个样子的有删减</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">         <span class="attribute">location</span> / &#123;</span><br><span class="line">           <span class="attribute">root</span> html;</span><br><span class="line">           <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里的http块：</strong> 可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。</p>
<p><strong>这里还有一个权限的问题</strong> ，可能导致项目打开是403，在nginx目录上一级目录执行 <code>sudo chown -R $(whoami) ./nginx</code>，然后重新加载nginx,不行的话看看是不是的打包后的文件没有权限。</p>
<p><strong>然后我部署自己的服务</strong></p>
<p>可以保持这个页面的简洁，单独新建一个vhost文件夹 然后在里面配置新项目，最后用 <code>include vhost/*.conf;</code> 直接引入进来；</p>
<p>我这里展示直接就这样了</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8891</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">root</span>  /Users/hzf/Desktop/my-project/dist;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.php default.html default.htm default.php;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="comment">#定义首页索引文件的名称</span></span><br><span class="line">      <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span></span><br><span class="line"><span class="regexp"></span>    &#123;</span><br><span class="line">        <span class="attribute">expires</span>      <span class="number">30d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(js|css)?$</span></span><br><span class="line"><span class="regexp"></span>    &#123;</span><br><span class="line">        <span class="attribute">expires</span>      <span class="number">12h</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /.well-known</span> &#123;</span><br><span class="line">        <span class="attribute">allow</span> all;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /\.</span></span><br><span class="line"><span class="regexp"></span>    &#123;</span><br><span class="line">        <span class="attribute">deny</span> all;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个巨坑，在之前云服务器的时候 root 对应项目的时候，是可以正常运行的，但是在本地运行的时候，是没办法加载本地资源的😌，全部包404，看遍好多文章都不行，耽误了半天。实际的原因是 <code>nginx做代理后的虚拟路径和静态资源的请求路径不一致导的</code></p>
<p>然后其实就是单独给静态的资源设置对应的root目录，代码如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"> <span class="attribute">location</span> /js/ &#123;</span><br><span class="line">    <span class="attribute">root</span>   /Users/hzf/Desktop/my-project/dist/js;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /font/ &#123;</span><br><span class="line">    <span class="attribute">root</span>   /Users/hzf/Desktop/my-project/dist/font;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /css/ &#123;</span><br><span class="line">    <span class="attribute">root</span>   /Users/hzf/Desktop/my-project/dist/css;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 如果打包后还有别的文件，如:img，继续添加就好了...</span></span><br></pre></td></tr></table></figure>

<br/>

<p>到目前为止，本地的nginx就可以正常运行了，后面遇到什么问题，我在及时更新。</p>
]]></content>
      <categories>
        <category>Server</category>
        <category>Nginx</category>
        <category>本地安装Nginx踩到的坑</category>
      </categories>
  </entry>
  <entry>
    <title>NodeJs的原生方法</title>
    <url>/2019/03/15/workspace/Server/node/base/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>NodeJs的原生方法</strong></p>
<p>[[toc]]</p>
<h3 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h3><p>process 对象是一个全局变量，它提供当前 Node.js 进程的有关信息，以及控制当前 Node.js 进程。 因为是全局变量，所以无需使用 require()。</p>
<p>process.argv 属性返回一个数组，这个数组包含了启动Node.js进程时的命令行参数，</p>
<p>其中：</p>
<p>数组的第一个元素process.argv[0]——返回启动Node.js进程的可执行文件所在的绝对路径</p>
<p>第二个元素process.argv[1]——为当前执行的JavaScript文件路径</p>
<p>剩余的元素为其他命令行参数</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line">node config.js aaaa bbbb cccc</span><br><span class="line"></span><br><span class="line">process.argv</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">[</span><br><span class="line">  <span class="string">'/usr/local/bin/node'</span>,</span><br><span class="line">  <span class="string">'/Users/hzf/workspace/zy-vue/babel.config.js'</span>,</span><br><span class="line">  <span class="string">'aaaa'</span>,</span><br><span class="line">  <span class="string">'bbbb'</span>,</span><br><span class="line">  <span class="string">'cccc'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Server</category>
        <category>NodeJS</category>
        <category>NodeJs的原生方法</category>
      </categories>
  </entry>
  <entry>
    <title>Node启动工具</title>
    <url>/2019/09/15/workspace/Server/node/pm2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Node启动工具</strong></p>
<p>[[toc]]</p>
<h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><p><strong>开发环境用</strong></p>
<h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>yarn global add  nodemon</p>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>nodemon app.js</p>
<h3 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h3><h5 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h5><p>yarn global add  pm2</p>
<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ pm2 start app.js              # 启动app.js应用程序</span><br><span class="line">$ pm2 start app.js -i 4         # cluster mode 模式启动4个app.js的应用实例    </span><br><span class="line">$ pm2 start app.js --name="api" # 启动应用程序并命名为 "api"</span><br><span class="line">$ pm2 start app.js --watch      # 当文件变化时自动重启应用</span><br><span class="line">$ pm2 list  / pm2 ls            # 列表 PM2 启动的所有的应用程序</span><br><span class="line">$ pm2 logs                      # 显示所有应用程序的日志</span><br><span class="line">$ pm2 logs [app-name|id]        # 显示指定应用程序的日志</span><br><span class="line">$ pm2 stop all                  # 停止所有的应用程序</span><br><span class="line">$ pm2 stop 0                    # 停止 id为 0的指定应用程序</span><br><span class="line">$ pm2 restart all               # 重启所有应用</span><br><span class="line">$ pm2 delete all                # 关闭并删除所有应用</span><br><span class="line">$ pm2 delete 0                  # 删除指定应用 id 0</span><br></pre></td></tr></table></figure>

<h5 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> /root/.pm2/logs</span><br><span class="line"></span><br><span class="line">pm2 log id</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Server</category>
        <category>NodeJS</category>
        <category>Node启动工具</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx的使用指南</title>
    <url>/2019/10/15/workspace/Server/nginx/nginx_base/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Nginx的使用指南</strong></p>
<p>[[toc]]</p>
<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p><a href="http://www.nginx.cn/76.html" target="_blank" rel="noopener">nginx基本配置与参数说明</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#运行用户</span><br><span class="line">user nobody;</span><br><span class="line">#启动进程,通常设置成和cpu的数量相等</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#全局错误日志及PID文件</span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">#工作模式及连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    #epoll是多路复用IO(I&#x2F;O Multiplexing)中的一种方式,</span><br><span class="line">    #仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">    use   epoll; </span><br><span class="line"></span><br><span class="line">    #单个后台worker process进程的最大并发链接数    </span><br><span class="line">    worker_connections  1024;</span><br><span class="line"></span><br><span class="line">    # 并发总数是 worker_processes 和 worker_connections 的乘积</span><br><span class="line">    # 即 max_clients &#x3D; worker_processes * worker_connections</span><br><span class="line">    # 在设置了反向代理的情况下，max_clients &#x3D; worker_processes * worker_connections &#x2F; 4  为什么</span><br><span class="line">    # 为什么上面反向代理要除以4，应该说是一个经验值</span><br><span class="line">    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 &#x3D; 32000</span><br><span class="line">    # worker_connections 值的设置跟物理内存大小有关</span><br><span class="line">    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数</span><br><span class="line">    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右</span><br><span class="line">    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：</span><br><span class="line">    # $ cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</span><br><span class="line">    # 输出 34336</span><br><span class="line">    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内</span><br><span class="line">    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置</span><br><span class="line">    # 使得并发总数小于操作系统可以打开的最大文件数目</span><br><span class="line">    # 其实质也就是根据主机的物理CPU和内存进行配置</span><br><span class="line">    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。</span><br><span class="line">    # ulimit -SHn 65535</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    #设定mime类型,类型由mime.type文件定义</span><br><span class="line">    include    mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    #设定日志格式</span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，</span><br><span class="line">    #对于普通应用，必须设为 on,</span><br><span class="line">    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，</span><br><span class="line">    #以平衡磁盘与网络I&#x2F;O处理速度，降低系统的uptime.</span><br><span class="line">    sendfile     on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #连接超时时间</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"></span><br><span class="line">    #开启gzip压缩</span><br><span class="line">    gzip on; &#x2F;&#x2F; 开启gzip</span><br><span class="line">    gzip_min_length 1k; &#x2F;&#x2F; 最小1k的文件才使用gzip</span><br><span class="line">    gzip_buffers 4 8k; &#x2F;&#x2F; 代表以8k为单位，按照原始数据大小以8k为单位的4倍申请内存</span><br><span class="line">    gzip_comp_level 5; &#x2F;&#x2F; 1 压缩比最小处理速度最快，9 压缩比最大但处理最慢（传输快但比较消耗cpu）</span><br><span class="line">    gzip_types application&#x2F;javascript text&#x2F;plain application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png; &#x2F;&#x2F; 支持的文件类型</span><br><span class="line">    gzip_disable &quot;MSIE [1-6]\.&quot;; &#x2F;&#x2F; IE6一下 Gzip支持的不好，故不实用gzip</span><br><span class="line"></span><br><span class="line">    #设定请求缓冲</span><br><span class="line">    client_header_buffer_size    128k;</span><br><span class="line">    large_client_header_buffers  4 128k;</span><br><span class="line"></span><br><span class="line">    #设定虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        #侦听80端口</span><br><span class="line">        listen    80;</span><br><span class="line">        #定义使用 www.nginx.cn访问</span><br><span class="line">        server_name  www.nginx.cn;</span><br><span class="line"></span><br><span class="line">        #定义服务器的默认网站根目录位置</span><br><span class="line">        root html;</span><br><span class="line"></span><br><span class="line">        #设定本虚拟主机的访问日志</span><br><span class="line">        access_log  logs&#x2F;nginx.access.log  main;</span><br><span class="line"></span><br><span class="line">        #默认请求</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">          #定义首页索引文件的名称</span><br><span class="line">             try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 定义错误提示页面</span><br><span class="line">        error_page   500 502 503 504 &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #静态文件，nginx自己处理</span><br><span class="line">        location ~ ^&#x2F;(images|javascript|js|css|flash|media|static)&#x2F; &#123;</span><br><span class="line">            #过期30天，静态文件不怎么更新，过期可以设大一点，</span><br><span class="line">            #如果频繁更新，则可以设置得小一点。</span><br><span class="line">            expires 30d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span><br><span class="line">        location ~ .php$ &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #禁止访问 .htxxx 文件</span><br><span class="line">        location ~ &#x2F;.ht &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="负载均衡（反向代理）"><a href="#负载均衡（反向代理）" class="headerlink" title="负载均衡（反向代理）"></a>负载均衡（反向代理）</h2><p>1.用户输入<code>http://test-openai.com</code> 时，访问<code>80</code>端口<br/><br>2.nginx监听到80端口<code>被访问</code>，匹配到的<code>/</code>路径，被反向代理到<code>http://dramatic-offical-website</code><br/><br>3.<code>dramatic-offical-website</code>集群管理着一堆机器地址，从而实现负载均衡。<br/><br>4.如果匹配到<code>http://test-openai.com/images/</code> 路径，则直接映射<code>/data</code>下的文件<br/></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 虚拟主机配置</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> test-openai.com; <span class="comment"># 请求到达的服务器名</span></span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment"># 监听80端口</span></span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl; <span class="comment"># https默认端口是443</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对 / 所有做负载均衡+反向代理</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://dramatic-offical-website; <span class="comment"># 代理到目标地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态文件，nginx自己处理</span></span><br><span class="line">    <span class="attribute">location</span> /images/ &#123;</span><br><span class="line">        <span class="attribute">root</span> /data; <span class="comment"># 映射到/data/images</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定负载均衡后台服务器列表</span></span><br><span class="line"><span class="attribute">upstream</span> dramatic-offical-website &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">10.192.106.133</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">10.192.106.134</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/nginx/conf.d</span></span><br><span class="line"><span class="comment"># /usr/local/nginx/conf/vhost</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /api &#123;</span><br><span class="line">   <span class="attribute">rewrite</span> <span class="regexp"> ^/api/(.*)$</span> /<span class="variable">$1</span> <span class="literal">break</span>;</span><br><span class="line">   <span class="attribute">proxy_pass</span> <span class="string">'XXXXXXXXXXXXX'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTTP缓存控制"><a href="#HTTP缓存控制" class="headerlink" title="HTTP缓存控制"></a>HTTP缓存控制</h2><p>常用的缓存设置里面有两种方式，都是使用add_header来设置：分别为<code>Cache-Control</code>和<code>Pragma</code></p>
<p><code>Pragma</code>可以应用到http 1.0 和http 1.1，只能应用于http 1.1<br/><br><code>Pragma</code>是旧产物，已经逐步抛弃</p>
<h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a><code>Pragma</code></h3><p><code>Pragma</code>有两个字段<code>Pragma</code>和<code>Expires</code>。Pragma的值为no-cache时，表示禁用缓存，Expires的值是一个GMT时间，表示该缓存的有效时间。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(css|js|swf|php|htm|html</span> )$ &#123;</span><br><span class="line">	<span class="attribute">add_header</span> Cache-Control max-age=<span class="number">10</span>;</span><br><span class="line">	<span class="attribute">add_header</span> Pragma <span class="literal">no</span>-cache;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Pragma的优先级高于Cache-Control</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(js|css)$</span> &#123;</span><br><span class="line">   <span class="attribute">expires</span> <span class="number">10d</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 若报文中同时出现了 Expires 和 Cache-Control，则以 Cache-Control 为准。</span></span><br></pre></td></tr></table></figure>

<h3 id="Cache-Control-「强制缓存」"><a href="#Cache-Control-「强制缓存」" class="headerlink" title="Cache-Control 「强制缓存」"></a><code>Cache-Control 「强制缓存」</code></h3><p>对于强缓存来说，会直接去查看<code>缓存资源中的响应头</code>的字段值，以此来判断缓存的资源是否还能使用，在这个过程中，<code>不需要</code>向服务器发起请求。</p>
<p><code>public</code>指示响应可被任何缓存区缓存。【如果定义了<code>max-age</code>，可以不用再定义<code>public</code>，它们的意义是一样的。】<br/><br><code>private</code>指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。<br/><br><code>no-cache</code>可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用<br/><br><code>no-store</code>彻底得禁用缓冲，本地和代理服务器都不缓冲，每次都从服务器获取<br/><br><code>max-age</code>指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应 【max-age=1008611】<br/><br><code>only-if-cached</code>表示不进行网络请求，完全只使用缓存，若缓存不命中，则返回503错误<br/><br><code>must-revalidate</code>：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验<br/></p>
<h3 id="缓存校验「协商缓存」"><a href="#缓存校验「协商缓存」" class="headerlink" title="缓存校验「协商缓存」"></a><code>缓存校验「协商缓存」</code></h3><p>当超过max-ages设置的时间,这个就会起作用</p>
<p>而对于协商缓存来说，要判断缓存是否能使用，需要通过发起请求，带着与缓存相关的字段，到服务器去做过期判断后，才能通过相应的内容做出相应的操作。（是回去拿缓存的资源，还是拿这次服务器返回的资源）</p>
<h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a><code>Last-Modified/If-Modified-Since</code></h3><p><code>Last-Modified</code>：标示这个<code>响应</code>资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。<br/><br><code>If-Modified-Since</code>是标准的HTTP请求头标签，在发送HTTP<code>请求</code>时，<strong>把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较</strong>。<br/><br>如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。<br/><br>如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中</p>
<p><code>If-Modified-Since</code>和<code>If-Unmodified-Since</code>的区别是：<br/><br>If-Modified-Since：告诉服务器如果时间一致，返回状态码304<br/><br>If-Unmodified-Since：告诉服务器如果时间不一致，返回状态码412</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">last_modified = res.headers[<span class="string">'Last-Modified'</span>]</span><br><span class="line"># 修改headers</span><br><span class="line">headers[<span class="string">'If-Unmodified-Since'</span>] = last_modified</span><br></pre></td></tr></table></figure>
<h3 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a><code>ETag/If-None-Match</code></h3><p>::: tip 为什么要有etag？<br>1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新get<br/><br>2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，if-modified-since能检查到的粒度是秒级的，这种修改无法判断<br/><br>3、某些服务器不能精确的得到文件的最后修改时间。<br/><br>:::</p>
<p><code>etag</code>的方式是这样：服务器通过某个算法对资源进行计算，取得一串值,之后将该值通过etag返回给客户端，客户端下次请求时通过<code>If-None-Match或If-Match</code>带上该值，服务器对该值进行对比校验,如果一致则不要返回资源。</p>
<p><code>If-None-Match</code>和<code>If-Match</code>的区别是：</p>
<p><code>If-None-Match</code>：告诉服务器如果一致，返回状态码304，不一致则返回资源<br/><br><code>If-Match</code>：告诉服务器如果不一致，返回状态码412</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"> <span class="attribute">location</span> <span class="regexp">~* ^.+\.(css|js|txt|xml|swf|wav)$</span> &#123;</span><br><span class="line"><span class="comment">#            expires      24h;</span></span><br><span class="line"><span class="comment">#            add_header Cache-Control no-store;</span></span><br><span class="line"><span class="comment">#            add_header Cache-Control max-age=43200;</span></span><br><span class="line">            <span class="attribute">add_header</span> Cache-Control  max-age=<span class="number">86400</span>,s-maxage=<span class="number">3600</span>,must-revalidate;</span><br><span class="line"><span class="comment">#            add_header Cache-Control only-if-cached;</span></span><br><span class="line"><span class="comment">#            add_header Cache-Control no-cache;</span></span><br><span class="line"><span class="comment">#            add_header Cache-Control must-revalidate;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>有一种场景需要注意</strong></p>
<ul>
<li>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</li>
<li>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</li>
<li>京东页面的资源请求，返回的repsones header就只有Last-Modified，没有ETag：</li>
</ul>
<h3 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h3><p>F5刷新那个可以去火狐看看</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/He00c7b1f799e40f39f6b6ab2f9f60710J.jpg" alt=""></p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hcca8568c990e4f33b30636b57b2fd65cc.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在前后端不分离的项目中，我们一般会把强缓存设置的时间特别长，一方面是减少304缓存，<br>另一方面是webpack打包的项目会带有hash值，只要文件发生改变对应的js或者css的hash值就会发生变化，这时候服务端就会重新请求数据，这里不会触碰到任何的缓存。<br>所以为了更好地运用缓存，提升客户端的体验，减轻服务器的压力，我们一定要要把经常用的库，如antd,echarts等等，单独打包成一个js，这样不会每次上线都会重新请求数据了。<br>如果线上遇到小的问题特别急，源码又不在身边，需要登录服务器改代码，也尽可能的不直接修改js或者css里面的代码，<br>这样在强缓存时间内或者用户刷新页面并不会请求到真正的请求数据，会直接使用本地的缓存，浏览器强制刷新会解决此问题，但是在手机端就gg了，<br>好的办法就是直接把文件名称，加一些hash值，然后在对应的页面修改下，这样就能拿到真正的资源了。（上一家公司遇到的坑）</p>
<h2 id="系统常用目录"><a href="#系统常用目录" class="headerlink" title="系统常用目录"></a>系统常用目录</h2><p><code>/etc</code>下一般是系统<code>全局性</code>的公共文件目录 <br/><br><code>/usr/local</code>一般是<code>第三方软件</code>所存放的目录的分区，可以单独分区，且建议单独挂载分区。 <br/><br><code>/usr/local/src</code>一般是<code>下载的第三方软件</code>。 <br/><br><code>/usr/local/etc</code>下一般指代<code>用户级</code>的公共文件目录 <br/><br><code>/usr/local/bin</code>目录是给用户放置自己的可执行程序. <br/><br><code>/usr/bin</code>下面的都是系统预装的<code>可执行程序</code>，系统升级有可能会被覆盖. <br/></p>
]]></content>
      <categories>
        <category>Server</category>
        <category>Nginx</category>
        <category>Nginx的使用指南</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs 插件拓展</title>
    <url>/2019/09/15/workspace/Server/node/node-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>NodeJs 插件拓展</strong></p>
<p>[[toc]]</p>
<h2 id="node-scheduleNodejs定时任务"><a href="#node-scheduleNodejs定时任务" class="headerlink" title="node-scheduleNodejs定时任务"></a>node-scheduleNodejs定时任务</h2><p><a href="https://github.com/node-schedule/node-schedule" target="_blank" rel="noopener">node-schedule</a>  Nodejs定时任务</p>
<p><strong>安装</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn add node-schedule -D</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<h3 id="Cron风格定时器"><a href="#Cron风格定时器" class="headerlink" title="Cron风格定时器"></a>Cron风格定时器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scheduleCronstyle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  schedule.scheduleJob(<span class="string">'1-59 * * * * *'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// sendEmail();</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">scheduleCronstyle();</span><br></pre></td></tr></table></figure>

<p>6个占位符从左到右分别代表：<code>秒、分、时、日、月、周几</code></p>
<p><code>*</code>表示通配符，匹配任意，当秒是<code>*</code>时，表示任意秒数都触发，其它类推</p>
<p>下面可以看看以下传入参数分别代表的意思</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每分钟的第59秒触发： &#39;59 * * * * *&#39;</span><br><span class="line">每小时的1分59秒触发 ：&#39;59 1 * * * *&#39;</span><br><span class="line">每天的凌晨1点1分59秒触发 ：&#39;59 1 1 * * *&#39;</span><br><span class="line">每月的1日1点1分59秒触发 ：&#39;59 1 1 1 * *&#39;</span><br><span class="line">2020年的1月1日1点1分59秒触发 ：&#39;59 1 1 1 2020 *&#39;</span><br><span class="line">每周天的1点1分30秒触发 ：&#39;30 1 1 * * 0&#39;</span><br></pre></td></tr></table></figure>

<h3 id="基于日期的计划"><a href="#基于日期的计划" class="headerlink" title="基于日期的计划"></a>基于日期的计划</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scheduleCronstyle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">26</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">const</span> j = schedule.scheduleJob(date, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'scheduleObjectLiteralSyntax:'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="对象文本语法定时器"><a href="#对象文本语法定时器" class="headerlink" title="对象文本语法定时器"></a>对象文本语法定时器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">second (0-59)</span><br><span class="line">minute (0-59)</span><br><span class="line">hour (0-23)</span><br><span class="line">date (1-31)</span><br><span class="line">month (0-11)</span><br><span class="line">year</span><br><span class="line">dayOfWeek (0-6) Starting with Sunday</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scheduleCronstyle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 周末的10点11分</span></span><br><span class="line">  <span class="keyword">const</span> j = schedule.scheduleJob(&#123;<span class="attr">hour</span>: <span class="number">10</span>, <span class="attr">minute</span>: <span class="number">11</span>, <span class="attr">dayOfWeek</span>: <span class="number">0</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi 小哥明天该上班了啊:'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="设置开始时间和结束时间"><a href="#设置开始时间和结束时间" class="headerlink" title="设置开始时间和结束时间"></a>设置开始时间和结束时间</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5秒后运行，并在10秒后停止</span></span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">let</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>(startTime.getTime() + <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">var</span> j = schedule.scheduleJob(&#123; <span class="attr">start</span>: startTime, <span class="attr">end</span>: endTime, <span class="attr">rule</span>: <span class="string">'*/1 * * * * *'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Time for tea!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="取消定时器"><a href="#取消定时器" class="headerlink" title="取消定时器"></a>取消定时器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scheduleCronstyle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 周末的10点11分</span></span><br><span class="line">  <span class="keyword">const</span> j = schedule.scheduleJob(&#123;<span class="attr">hour</span>: <span class="number">10</span>, <span class="attr">minute</span>: <span class="number">11</span>, <span class="attr">dayOfWeek</span>: <span class="number">0</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi 小哥明天该上班了啊:'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'定时器取消'</span>);</span><br><span class="line">    <span class="comment">// 定时器取消</span></span><br><span class="line">    j.cancel();</span><br><span class="line">  &#125;, <span class="number">5000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>写在之后</strong></p>
<p>定时器功能大部分需求都可以借助<code>node-schedule</code>完成了，用它在项目中使用效果也不错，各种需求可以满足^_^!</p>
<h2 id="qrcode-terminal在终端输出二维码"><a href="#qrcode-terminal在终端输出二维码" class="headerlink" title="qrcode-terminal在终端输出二维码"></a>qrcode-terminal在终端输出二维码</h2><p><a href="https://github.com/gtanner/qrcode-terminal" target="_blank" rel="noopener">qrcode-terminal</a>在终端输出二维码</p>
<p><strong>安装</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn add qrcode-terminal -D</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> qrcode = <span class="built_in">require</span>(<span class="string">'qrcode-terminal'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'http://www.jing999.cn'</span>;</span><br><span class="line">qrcode.generate(url);</span><br><span class="line"><span class="comment">// 第二个参数 &#123;small:true&#125; 第三个参数是回调</span></span><br></pre></td></tr></table></figure>

<h2 id="node爬虫"><a href="#node爬虫" class="headerlink" title="node爬虫"></a>node爬虫</h2><h3 id="superagent-axios-node-fetch-请求数据"><a href="#superagent-axios-node-fetch-请求数据" class="headerlink" title="superagent / axios / node-fetch  请求数据"></a>superagent / axios / node-fetch  请求数据</h3><blockquote>
<p><strong>superagent</strong> 拓展性强，同时支持 Node.js 和浏览器，通过构建插件可以实现更多功能 ；缺点：其 API 不符合任何标准<br/><br><strong>axios</strong> 支持 Promise API，同时支持 Node.js 和浏览器<br/><br><strong>node-fetch</strong> 轻量级的模块,与window.fetchAPI 保持一致，在nodeJs中使用</p>
</blockquote>
<h3 id="cheerio"><a href="#cheerio" class="headerlink" title="cheerio"></a>cheerio</h3><p><a href="https://cheerio.js.org/" target="_blank" rel="noopener">cheerio</a> 可以理解为一个Node.js版本的jquery</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"><span class="keyword">let</span> $ = cheerio.load(<span class="string">"&lt;div id='helloworld'&gt;hello world&lt;/div&gt;"</span>, &#123;<span class="attr">ignoreWhitespace</span>: <span class="literal">true</span>...&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 属性操作</span><br><span class="line">.attr(name, value)</span><br><span class="line">.removeAtrr(name)</span><br><span class="line">.hasClass(className)</span><br><span class="line">.addClass(className)</span><br><span class="line">.remoteClass([className])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历</span><br><span class="line">.find(selector)</span><br><span class="line">.parent()</span><br><span class="line">.next()</span><br><span class="line">.prev()</span><br><span class="line">.siblings()</span><br><span class="line">.children( selector )</span><br><span class="line">.each( function(index, element) )</span><br><span class="line">.map( function(index, element) )</span><br><span class="line">.filter( selector )</span><br><span class="line">.filter( function(index) )</span><br><span class="line">.first()</span><br><span class="line">.last()</span><br><span class="line">.eq(i)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 操作DOM</span><br><span class="line">.append( content, [content, ...] )</span><br><span class="line">.prepend( content, [content, ...] )</span><br><span class="line">.after( content, [content, ...] )</span><br><span class="line">.before( content, [content, ...] )</span><br><span class="line">.remove( [selector] )</span><br><span class="line">.replaceWith( content )</span><br><span class="line">.empty()</span><br><span class="line">.html( [htmlString] )</span><br><span class="line">.text( [textString] )</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 其他</span><br><span class="line">$.html()</span><br><span class="line">$(&#39;ul&#39;).text()</span><br><span class="line">.toArray()</span><br><span class="line">.clone()</span><br><span class="line">$.root()</span><br><span class="line">$.contains( container, contained )</span><br></pre></td></tr></table></figure>

<h3 id="iconv-lite"><a href="#iconv-lite" class="headerlink" title="iconv-lite"></a>iconv-lite</h3><p>有些时候,获取到的数据是一些乱码,尤其是中文的情况.所以我们需要解决乱码的问题,<code>iconv-lite</code>模块就可以解决这一问题.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">homeBody = iconv.decode(homeBody,<span class="string">"GBK"</span>); <span class="comment">//进行gbk解码</span></span><br></pre></td></tr></table></figure>
<p>如果有乱码就在 <code>cheerio.load()</code>之前进行解码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span> /&gt; <span class="comment">//这里是utf-8,就不需要解码</span></span><br></pre></td></tr></table></figure>
<p>如果是静态页面上面的操作基本上就已经完成了，但是现实中毕竟都是spa 大行其道很多都不是静态的，所以不能用 cheerio 模块来解析。</p>
<h3 id="动态页面爬取"><a href="#动态页面爬取" class="headerlink" title="动态页面爬取"></a>动态页面爬取</h3><ul>
<li><p><strong>手动复制body,用IDE或者node起服务进行爬取，人力成本比较高</strong></p>
</li>
<li><p><strong>找到数据接口,直接爬去</strong>，有的网页打开控制台全部是debug,并不能高效的找到对应的数据接口 <a href="https://blog.csdn.net/zhang6223284/article/details/80152368" target="_blank" rel="noopener">csdn</a></p>
</li>
<li><p><strong>最近刚看到的，<a href="https://github.com/puppeteer/puppeteer" target="_blank" rel="noopener">puppeteer</a></strong> <a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#?product=Puppeteer&version=v3.0.1&show=api-class-puppeteer" target="_blank" rel="noopener">文档链接</a></p>
</li>
<li><p><strong>phantomjs 跟上面的类似</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Server</category>
        <category>NodeJS</category>
        <category>NodeJs 插件拓展</category>
      </categories>
  </entry>
  <entry>
    <title>Koa2</title>
    <url>/2019/02/15/workspace/Server/node/node-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Koa2</strong></p>
<p>[[toc]]</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p><strong>__filename</strong> 全局值，当前文件绝对路径 module.filename === <strong>filename 等价 <br/><br>**</strong>dirname** 全局值，当前文件夹绝对路径。等效于path.resolve(__filename, ‘..’)<br/><br><strong>path.join([…paths])</strong> 相当于把所传入的任意多的参数 按照顺序 进行命令行般的推进<br/><br><strong>path.resolve([…paths])</strong> 以当前文件的路径为起点，返回绝对路径。可以理解为每次都是新建cd命令<br/><br><strong>path.dirname(path)</strong> 返回指定路径所在文件夹的路径<br/><br><strong>path.basename(path)</strong> 返回指定Path路径所在文件的名字<br/><br><strong>path.extname(path)</strong> 获取指定字符串或者文件路径名字的后缀名，带.比如.txt<br/><br><strong>path.isAbsolute(path)</strong> 是否是绝对路径,返回boolean值<br/><br><strong>process.cwd()</strong>   返回运行当前脚本的工作目录的路径 <br/><br><strong>process.chdir()</strong> 改变工作目录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path.join(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'../c/lolo'</span>) <span class="comment">// a/c/lolo</span></span><br><span class="line"></span><br><span class="line">path.resolve(<span class="string">'/a'</span>, <span class="string">'/b'</span>) <span class="comment">// '/b'</span></span><br><span class="line">path.resolve(<span class="string">'./a'</span>, <span class="string">'./b'</span>) <span class="comment">// '/User/../a/b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filePath = <span class="string">'./bar/baz/asdf/quux.html'</span></span><br><span class="line">path.basename(filePath) <span class="comment">// quux.html</span></span><br><span class="line">path.dirname(filePath) <span class="comment">// ./bar/baz/asdf</span></span><br><span class="line">path.extname(filePath) <span class="comment">// .html</span></span><br><span class="line">path.isAbsolute(filePath) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>例子，文件路径有如下结构：</p>
<p>newapp &gt; demo &gt; hello.js</p>
<p>在hello.js文件中编写如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line"><span class="built_in">console</span>.log(__filename);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.filename===__filename);</span><br><span class="line"><span class="built_in">console</span>.log(process.cwd());</span><br><span class="line">process.chdir(<span class="string">'/Users/jerry'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(process.cwd());</span><br></pre></td></tr></table></figure>

<p>然后定位在newapp目录下，执行命令 node demo/hello.js，输出结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/Users/jerry/<span class="number">51</span>talk/newapp/demo</span><br><span class="line">/Users/jerry/<span class="number">51</span>talk/newapp/demo/hello.js</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">/Users/jerry/<span class="number">51</span>talk/newapp</span><br><span class="line">/Users/jerry</span><br></pre></td></tr></table></figure>

<h4 id="启动HTTP服务"><a href="#启动HTTP服务" class="headerlink" title="启动HTTP服务"></a>启动HTTP服务</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.listen(...)  <span class="comment">//方法是如下的一个语法糖。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const http = require('http')</span></span><br><span class="line"><span class="comment">// http.createServer(app.callback()).listen(3000)</span></span><br></pre></td></tr></table></figure>

<h4 id="开启import"><a href="#开启import" class="headerlink" title="开启import"></a>开启import</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'@babel/register'</span>)(&#123;</span><br><span class="line">    babelrc: <span class="literal">false</span>,</span><br><span class="line">    presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">    plugins: [<span class="string">"@babel/plugin-transform-runtime"</span>]</span><br><span class="line">&#125;);</span><br><span class="line"> <span class="comment">//package.json</span></span><br><span class="line">devDependencies: &#123;</span><br><span class="line">    <span class="string">"@babel/core"</span>: <span class="string">"^7.4.5"</span>,</span><br><span class="line">    <span class="string">"@babel/plugin-transform-runtime"</span>: <span class="string">"^7.4.4"</span>,</span><br><span class="line">    <span class="string">"@babel/preset-env"</span>: <span class="string">"^7.4.5"</span>,</span><br><span class="line">    <span class="string">"@babel/register"</span>: <span class="string">"^7.4.4"</span>,</span><br><span class="line">    <span class="string">"@babel/runtime"</span>: <span class="string">"^7.4.5"</span>,</span><br><span class="line">    <span class="string">"nodemon"</span>: <span class="string">"^1.19.1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Context对象"><a href="#Context对象" class="headerlink" title="Context对象"></a>Context对象</h4><p>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容</p>
<p><code>Context.response.body</code>属性就是发送给用户的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123; <span class="comment">//处理请求的中间件</span></span><br><span class="line">    ctx.response.body = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p><code>ctx.response</code>代表 <code>HTTP Response</code>。同样地，<code>ctx.request</code>代表 <code>HTTP Request</code></p>
<h4 id="HTTP-Response-的类型"><a href="#HTTP-Response-的类型" class="headerlink" title="HTTP Response 的类型"></a>HTTP Response 的类型</h4><p>Koa 默认的返回类型是<code>text/plain</code>，如果想返回其他类型的内容，可以先用<code>ctx.request.accepts</code>判断一下，客户端希望接受什么数据，然后使用<code>ctx.response.type</code>指定返回类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&quot;koa&quot;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line"></span><br><span class="line">app.use(ctx &#x3D;&gt; &#123;</span><br><span class="line">    if (ctx.request.accepts(&#39;xml&#39;)) &#123;</span><br><span class="line">        ctx.response.type &#x3D; &#39;xml&#39;;</span><br><span class="line">        ctx.response.body &#x3D; &#39;&lt;data&gt;Hello World&lt;&#x2F;data&gt;&#39;;</span><br><span class="line">    &#125; else if (ctx.request.accepts(&#39;json&#39;)) &#123;</span><br><span class="line">        ctx.response.type &#x3D; &#39;json&#39;;</span><br><span class="line">        ctx.response.body &#x3D; &#123; data: &#39;Hello World&#39; &#125;;</span><br><span class="line">    &#125; else if (ctx.request.accepts(&#39;html&#39;)) &#123;</span><br><span class="line">        ctx.response.type &#x3D; &#39;html&#39;;</span><br><span class="line">        ctx.response.body &#x3D; &#39;&lt;p&gt;Hello World&lt;&#x2F;p&gt;&#39;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ctx.response.type &#x3D; &#39;text&#39;;</span><br><span class="line">        ctx.response.body &#x3D; &#39;Hello World&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(3000);</span><br></pre></td></tr></table></figure>

<h4 id="设置响应头和请求头"><a href="#设置响应头和请求头" class="headerlink" title="设置响应头和请求头"></a>设置响应头和请求头</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置响应头</span></span><br><span class="line">ctx.set(<span class="string">'Content-Type'</span>, <span class="string">'application/zip'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求头</span></span><br><span class="line">ctx.append(<span class="string">'userName'</span>,<span class="string">'hzf'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="网页模板"><a href="#网页模板" class="headerlink" title="网页模板"></a>网页模板</h4><p>实际开发中，返回给用户的网页往往都写成模板文件。我们可以让 Koa 先读取模板文件，然后将这个模板返回给用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&quot;koa&quot;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">app.use(ctx &#x3D;&gt; &#123;</span><br><span class="line">    ctx.response.type &#x3D; &#39;html&#39;;</span><br><span class="line">    ctx.response.body &#x3D; fs.createReadStream(&#39;.&#x2F;public&#x2F;template.html&#39;);</span><br><span class="line">&#125;).listen(3000);</span><br></pre></td></tr></table></figure>

<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>网站一般都有多个页面。通过<code>ctx.request.path</code>可以获取用户请求的路径，由此实现简单的路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&quot;koa&quot;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">app.use(ctx &#x3D;&gt; &#123;</span><br><span class="line">    if (ctx.request.path !&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">        ctx.response.type &#x3D; &#39;html&#39;;</span><br><span class="line">        ctx.response.body &#x3D; &#39;&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;Index Page1&lt;&#x2F;a&gt;&#39;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ctx.response.body &#x3D; &#39;Hello World&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(3000);</span><br></pre></td></tr></table></figure>

<h4 id="koa-router-模块"><a href="#koa-router-模块" class="headerlink" title="koa-router 模块"></a>koa-router 模块</h4><p>原生路由用起来不太方便，我们可以使用封装好的<code>koa-router</code>模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&quot;koa&quot;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const route &#x3D; require(&#39;koa-router&#39;)();</span><br><span class="line"></span><br><span class="line">route.get(&quot;&#x2F;&quot;, ctx &#x3D;&gt; &#123;</span><br><span class="line">    ctx.response.type &#x3D; &#39;html&#39;;</span><br><span class="line">    ctx.response.body &#x3D; &#39;&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;Index Page1&lt;&#x2F;a&gt;&#39;;</span><br><span class="line">&#125;)</span><br><span class="line">route.get(&quot;&#x2F;about&quot;, ctx &#x3D;&gt; &#123;</span><br><span class="line">    ctx.response.body &#x3D; &#39;Hello World&#39;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes()); &#x2F;&#x2F;作用：启动路由</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line">&#x2F;* 作用： 这是官方文档的推荐用法,我们可以看到router.allowedMethods()用在了路由匹配</span><br><span class="line">router.routes()之后,目的在于：根据ctx.status 设置response 响应头</span><br><span class="line">*&#x2F;</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>


<h4 id="路由传值"><a href="#路由传值" class="headerlink" title="路由传值"></a>路由传值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://localhost:3000/api/1?type=123</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.query) <span class="comment">// &#123; type: '123' &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.path) <span class="comment">// /api/1</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.params) <span class="comment">// 动态路由 -&gt;类似于 '/api/:_id'</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.body) <span class="comment">// 通常是 post method</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.cookies) <span class="comment">// need  cookie-parser middleware</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// extend http.IncomingMessage</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.url) <span class="comment">// /api/1?type=123</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.headers) <span class="comment">// header object</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.method) <span class="comment">// GET</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><p>如果网站提供静态资源（图片、字体、样式表、脚本……），为它们一个个写路由就很麻烦，也没必要。koa-static模块封装了这部分的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 访问 http:&#x2F;&#x2F;localhost:3000&#x2F;index.html</span><br><span class="line">const Koa &#x3D; require(&quot;koa&quot;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const serve &#x3D; require(&#39;koa-static&#39;);</span><br><span class="line"></span><br><span class="line">app.use(serve(process.cwd() + &#39;&#x2F;public&#39;));</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>有些场合，服务器需要重定向（<code>redirect</code>）访问请求。比如，用户登陆以后，将他重定向到登陆前的页面。<code>ctx.response.redirect()</code>方法可以发出一个<code>302</code>跳转(临时性重定向)，将用户导向另一个路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&quot;koa&quot;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line">const route &#x3D; require(&quot;koa-router&quot;)();</span><br><span class="line"></span><br><span class="line">route.get(&quot;&#x2F;orderList&quot;, ctx &#x3D;&gt; &#123;</span><br><span class="line">    ctx.response.redirect(&#39;&#x2F;&#39;);</span><br><span class="line">    ctx.response.body &#x3D; &#39;&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;Index Page&lt;&#x2F;a&gt;&#39;;</span><br><span class="line">&#125;)</span><br><span class="line">route.get(&quot;&#x2F;&quot;, ctx &#x3D;&gt; &#123;</span><br><span class="line">    ctx.response.body &#x3D; &quot;hello world&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h4 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h4><p>Koa 的最大特色，也是最重要的一个设计，就是<code>中间件</code>（middleware）</p>
<ul>
<li>基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的routes()也是中间件</li>
<li>每个中间件默认接受两个参数，<code>第一个参数是 Context 对象，第二个参数是next函数</code>。只要调用next函数，就可以把执行权转交给下一个中间件，如果中间件内部没有调用next函数，那么执行权就不会传递下去</li>
</ul>
<p>多个中间件会形成一个<code>栈结构（middle stack</code>），以<code>”先进后出”（first-in-last-out）</code>的顺序执行,看下面的洋葱模型</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H4242d98115564b91a0f007f2c15125e24.jpg" alt=""></p>
<ul>
<li>最外层的中间件首先执行。</li>
<li>调用next函数，把执行权交给下一个中间件。</li>
<li>…</li>
<li>最内层的中间件最后执行。</li>
<li>执行结束后，把执行权交回上一层的中间件。</li>
<li>…</li>
<li>最外层的中间件收回执行权之后，执行next函数后面的代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx,next)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"3"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"4"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印结果是：1,2,4,3</span></span><br></pre></td></tr></table></figure>


<h4 id="异步中间件"><a href="#异步中间件" class="headerlink" title="异步中间件"></a>异步中间件</h4><p>如果有异步操作（比如读取数据库），中间件就必须写成 <strong>async</strong> 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">&#123;data, msg, status, code = <span class="number">200</span>,...option&#125;</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status || <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">this</span>.set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">        <span class="keyword">this</span>.body = &#123;</span><br><span class="line">            code: code,</span><br><span class="line">            msg,</span><br><span class="line">            data,</span><br><span class="line">            is_login: <span class="keyword">this</span>[<span class="string">'is_login'</span>],</span><br><span class="line">            ...option</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        ctx.send = render.bind(ctx);</span><br><span class="line">        <span class="keyword">await</span> next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> response</span><br></pre></td></tr></table></figure>

<h4 id="中间件的合成"><a href="#中间件的合成" class="headerlink" title="中间件的合成"></a>中间件的合成</h4><p>koa-compose模块可以将多个中间件合成为一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const compose &#x3D; require(&#39;koa-compose&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line"></span><br><span class="line">const logger &#x3D; (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;&#96;);</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const main &#x3D; ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.response.body &#x3D; &#39;Hello World&#39;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const middlewares &#x3D; compose([logger, main]);</span><br><span class="line"></span><br><span class="line">app.use(middlewares);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="500-错误"><a href="#500-错误" class="headerlink" title="500 错误"></a>500 错误</h4><p>如果代码运行过程中发生错误，我们需要把错误信息返回给用户。HTTP 协定约定这时要返回500状态码</p>
<p>Koa提供了<code>ctx.throw()</code>方法，用来抛出错误，<code>ctx.throw(500)</code>就是抛出500错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line"></span><br><span class="line">const main &#x3D; ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.throw(500);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<p><code>ctx.response.status</code>设置成404，就相当于<code>ctx.throw(404)</code>，返回404错误</p>
<h4 id="处理错误的中间件"><a href="#处理错误的中间件" class="headerlink" title="处理错误的中间件"></a>处理错误的中间件</h4><p>为了方便处理错误，最好使用<code>try...catch</code>将其捕获。但是，为每个中间件都写<code>try...catch</code>太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const catchErr &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return async (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            await next();</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">            ctx.status &#x3D; err.statusCode || err.status || 500;</span><br><span class="line">            ctx.body &#x3D; &#123;</span><br><span class="line">                msg: &quot;服务器错误&quot;,</span><br><span class="line">                code: -1,</span><br><span class="line">                data:[]</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default catchErr</span><br><span class="line">app.use(catchErr);</span><br></pre></td></tr></table></figure>

<h4 id="error-事件的监听"><a href="#error-事件的监听" class="headerlink" title="error 事件的监听"></a>error 事件的监听</h4><p>运行过程中一旦出错，Koa 会触发一个error事件。监听这个事件，也可以处理错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line"></span><br><span class="line">const main &#x3D; ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.throw(500);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.on(&#39;error&#39;, (err, ctx) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#39;server error&#39;, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<h3 id="Web-的功能"><a href="#Web-的功能" class="headerlink" title="Web 的功能"></a>Web 的功能</h3><h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>ctx.cookies用来读写 Cookie</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.cookies.set(name, value, [options])</span><br></pre></td></tr></table></figure>

<p>访问 <a href="http://127.0.0.1:3000" target="_blank" rel="noopener">http://127.0.0.1:3000</a> ，你会看到1 views。刷新一次页面，就变成了2 views。再刷新，每次都会计数增加1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line"></span><br><span class="line">const main &#x3D; function(ctx) &#123;</span><br><span class="line">    const n &#x3D; Number(ctx.cookies.get(&#39;view&#39;) || 0) + 1;</span><br><span class="line">    ctx.cookies.set(&#39;view&#39;, n);</span><br><span class="line">    ctx.response.body &#x3D; n + &#39; views&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hc7a6ea6122f941e6875c29f19ed65996F.png" alt=""></p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p><code>session</code> 是另一种记录客户状态的机制，不同的是 <code>Cookie</code> 保存在客户端浏览器中，而 <code>session</code> 保存在服务器上</p>
<p><strong>Session 的工作流程</strong></p>
<p>当浏览器访问服务器并发送第一次请求时，服务器端会创建一个 <code>session</code> 对象，生 成一个类似于 <code>key,value</code> 的键值对， 然后将<code>key(cookie)</code>返回到浏览器(客户)端，浏览 器下次再访问时，携带 <code>key(cookie)</code>，找到对应的 <code>session(value)</code>.</p>
<p><strong>koa-session 的使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'koa-session'</span>);</span><br><span class="line"><span class="comment">// 通过任意字符串为基准进行加密算法的字符串  base64</span></span><br><span class="line"><span class="comment">// keys 作用在cookie 的value值时加密后的内容 </span></span><br><span class="line">app.keys = [<span class="string">'some secret hurr'</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> CONFIG = &#123;</span><br><span class="line">  key: <span class="string">'koa:sess'</span>,  <span class="comment">// 设置 session的名字 也是cookie中key</span></span><br><span class="line">  maxAge: <span class="number">86400000</span>,</span><br><span class="line">  autoCommit: <span class="literal">true</span>,</span><br><span class="line">  overwrite: <span class="literal">true</span>, </span><br><span class="line">  httpOnly: <span class="literal">true</span>, <span class="comment">// 是否允许客户端操作cookies true:不允许 false 允许</span></span><br><span class="line">  signed: <span class="literal">true</span>, <span class="comment">// 数字签名，保证数据不被修改</span></span><br><span class="line">  rolling: <span class="literal">false</span>, <span class="comment">// 过期时间访问顺延，指的是数据存储过期后；时候否继续加时间 false 不顺延  true 顺延</span></span><br><span class="line">  renew: <span class="literal">false</span>, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(session(CONFIG, app));</span><br></pre></td></tr></table></figure>
<p><strong>使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置值 </span></span><br><span class="line">ctx.session.username = <span class="string">"张三"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值 </span></span><br><span class="line">ctx.session.username</span><br></pre></td></tr></table></figure>
<p><strong>Cookie 和 Session 关系</strong></p>
<p>coolies 的value 为session 存的内容，过程经过了请求与响应<br>通过cookies 与session存储数据；可以知道当前登录的是哪个用户</p>
<p><strong>Cookie 和 Session 区别</strong></p>
<ul>
<li>cookie 数据存放在客户的浏览器上，session 数据放在服务器上</li>
<li>cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗 考虑到安全应当使用 session</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用 COOKIE</li>
<li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie</li>
</ul>
<h4 id="JWT-Json-Web-Token"><a href="#JWT-Json-Web-Token" class="headerlink" title="JWT(Json Web Token)"></a>JWT(Json Web Token)</h4><p><a href="https://www.npmjs.com/package/jsonwebtoken" target="_blank" rel="noopener">JWT</a> 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点：</p>
<ul>
<li>简洁(Compact)可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快</li>
<li>自包含(Self-contained) 负载中包含了所有用户所需要的信息，避免了多次查询数据库</li>
<li>JWT的主要作用在于<ul>
<li>可附带用户信息，后端直接通过JWT获取相关信息。</li>
<li>使用本地保存，通过HTTP Header中的<code>Authorization</code>位提交验证。</li>
</ul>
</li>
</ul>
<p><strong>koa-jwt的工作流程</strong></p>
<ul>
<li>用户通过登录Api获取当前用户在有效期内的token</li>
<li>需要身份验证的API则都需要携带此前认证过的token发送至服务端</li>
<li><code>koa2</code>会利用<code>koa-jwt</code>中间件的默认验证方式进行身份验证，中间件会进行验证成功和验证失败的分流。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// koa-jwt的默认验证方式: </span></span><br><span class="line">&#123;<span class="string">'authorization'</span>: <span class="string">"Bearer "</span> + token&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在项目中使用</strong></p>
<ol>
<li>安装依赖</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add jsonwebtoken koa-jwt</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>中间件 请求验证token<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中间件对token进行验证</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 不用</span></span><br><span class="line">    <span class="comment">// let token = ctx.header.authorization;  // 解密操作</span></span><br><span class="line">    <span class="comment">// let payload = await jwt.verify(token, customConfig.passportJwt);</span></span><br><span class="line">    <span class="keyword">return</span> next().catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err.status === <span class="number">401</span>) &#123;</span><br><span class="line">            ctx.status = <span class="number">401</span>;</span><br><span class="line">            ctx.body = &#123;</span><br><span class="line">                code: <span class="number">401</span>,</span><br><span class="line">                msg: err.message</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>排除不验证的请求<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(koajwt(&#123; <span class="attr">secret</span>: SECRET &#125;).unless(&#123;</span><br><span class="line">    path: [<span class="regexp">/^\/api\/login/</span>,/^\/api\/register/]   <span class="comment">// 登录注册接口不需要验证</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li>
<li>登陆签发token</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> customConfig = &#123;</span><br><span class="line">    passportJwt: <span class="string">'xxxxxxxxxx'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> token = jwt.sign(&#123;</span><br><span class="line">         username:<span class="string">'xx'</span>,</span><br><span class="line">         password:<span class="string">'xx'</span>,</span><br><span class="line">         admin: <span class="literal">true</span>,</span><br><span class="line">         exp: <span class="built_in">Math</span>.floor(<span class="built_in">Date</span>.now() / <span class="number">1000</span>) + (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>), <span class="comment">// 过期时间秒,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    customConfig.passportJwt, <span class="comment">// 加密</span></span><br><span class="line">    <span class="comment">// &#123;expiresIn: '1h'&#125;  也可以这么设置过期时间</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ctx.body = &#123;</span><br><span class="line">    code: <span class="number">200</span>,</span><br><span class="line">    msg: <span class="string">'登录成功'</span>,</span><br><span class="line">    token: token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表单-POST"><a href="#表单-POST" class="headerlink" title="表单 (POST)"></a>表单 (POST)</h4><p>Web应用离不开处理表单。本质上，表单就是<code>POST</code>方法发送到服务器的键值对。<code>koa-bodyparser</code>模块可以用来从 POST 请求的数据体里面提取键值对</p>
<p><strong>原生 Nodejs 获取 post 提交数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parsePostData(ctx)&#123;</span><br><span class="line">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            let postdata&#x3D;&quot;&quot;;</span><br><span class="line">            ctx.req.on(&#39;data&#39;,(data)&#x3D;&gt;&#123;</span><br><span class="line">                postdata +&#x3D; data</span><br><span class="line">            &#125;)</span><br><span class="line">            ctx.req.on(&quot;end&quot;,function()&#123;</span><br><span class="line">                resolve(postdata);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;catch(error)&#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Koa 中 koa-bodyparser 中间件的使用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">import bodyParser from &quot;koa-bodyparser&quot;;</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line"></span><br><span class="line">const main &#x3D; async function(ctx) &#123;</span><br><span class="line">  const body &#x3D; ctx.request.body;</span><br><span class="line">  if (!body.name) ctx.throw(400, &#39;.name required&#39;);</span><br><span class="line">  ctx.body &#x3D; &#123; name: body.name &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(bodyParser(&#123;</span><br><span class="line">    enableTypes: [&#39;json&#39;, &#39;form&#39;, &#39;text&#39;]</span><br><span class="line">&#125;));</span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<p>打开命令行窗口，运行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST --data &quot;name&#x3D;Jack&quot; 127.0.0.1:3000</span><br><span class="line">&#123;&quot;name&quot;:&quot;Jack&quot;&#125;</span><br><span class="line"></span><br><span class="line">$ curl -X POST --data &quot;name&quot; 127.0.0.1:3000</span><br><span class="line">name required</span><br></pre></td></tr></table></figure>

<p><strong>Koa-body模块</strong></p>
<p>Koa2中利用<code>Koa-body</code>代替<code>koa-bodyparser</code>和<code>koa-multer</code>。原来通过<code>koa-bodyparser</code>来打包<code>Post</code>请求的数据，通过<code>koa-multe</code>r来处理<code>multipar</code>t的文件;使用<code>koa-body</code>后，<code>ctx.request.files</code>获得Post中的文件信息。<code>ctx.request.body</code>获得Post上传的表单信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加koaBody中间件</span><br><span class="line">app.use(</span><br><span class="line">  koaBody(&#123;</span><br><span class="line">    &#x2F;&#x2F; 如果需要上传文件,multipart: true</span><br><span class="line">    &#x2F;&#x2F;　不设置无法传递文件</span><br><span class="line">    multipart: true,</span><br><span class="line">    formidable: &#123;</span><br><span class="line">      maxFileSize: 10 * 1024 * 1024  &#x2F;&#x2F; 设置上传文件大小最大限制，默认2M</span><br><span class="line">    &#125;,</span><br><span class="line">    patchKoa: true</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>实现文件上传的中间件有3个</p>
<ul>
<li>koa-body </li>
<li>busboy </li>
<li>koa-multer </li>
</ul>
<p>因为上面POST用了 <code>koa-body</code> ，这里还继续用<code>koa-body</code>，使用方式跟上面的一样，这里就不在写了</p>
<p>使用koa-body中间件后，即可通过<code>ctx.request.files</code>获取上传的文件</p>
<p><strong>提醒：</strong> <br/><br>新版本的koa-body通过ctx.request.files获取上传的文件 <br/><br>旧版本的koa-body通过ctx.request.body.files获取上传的文件 <br/></p>
<p><strong>上传单个文件</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">'/uploadfile'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> file = ctx.request.files.file; <span class="comment">// 获取上传文件</span></span><br><span class="line">   <span class="comment">// 获取上传文件扩展名</span></span><br><span class="line">  <span class="keyword">let</span> filePath = path.join(__dirname, <span class="string">'public/upload/'</span>) + <span class="string">`/<span class="subst">$&#123;file.name&#125;</span>`</span>;</span><br><span class="line">  <span class="comment">// 创建可读流</span></span><br><span class="line">  <span class="keyword">const</span> reader = fs.createReadStream(file.path);</span><br><span class="line">  <span class="comment">// 创建可写流</span></span><br><span class="line">  <span class="keyword">const</span> upStream = fs.createWriteStream(filePath);</span><br><span class="line">  <span class="comment">// 可读流通过管道写入可写流</span></span><br><span class="line">  reader.pipe(upStream);</span><br><span class="line">  <span class="keyword">return</span> ctx.body = <span class="string">"上传成功！"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>上传多个文件</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">'/uploadfiles'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> filePaths = [];</span><br><span class="line">  <span class="comment">// 上传多个文件</span></span><br><span class="line">  <span class="keyword">const</span> files = ctx.request.files.file; <span class="comment">// 获取上传文件</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    <span class="comment">// 获取上传文件扩展名</span></span><br><span class="line">    <span class="keyword">let</span> filePath = path.join(__dirname, <span class="string">'public/upload/'</span>) + <span class="string">`/<span class="subst">$&#123;file.name&#125;</span>`</span>;</span><br><span class="line">    <span class="comment">// 创建可读流</span></span><br><span class="line">    <span class="keyword">const</span> reader = fs.createReadStream(file.path);</span><br><span class="line">    <span class="comment">// 创建可写流</span></span><br><span class="line">    <span class="keyword">const</span> upStream = fs.createWriteStream(filePath);</span><br><span class="line">    <span class="comment">// 可读流通过管道写入可写流</span></span><br><span class="line">    reader.pipe(upStream);</span><br><span class="line">    filePaths.push(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">return</span> ctx.body = filePaths</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="nodemailer"><a href="#nodemailer" class="headerlink" title="nodemailer"></a>nodemailer</h4><p><strong>发送邮件</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> transporter = nodemailer.createTransport(&#123;</span><br><span class="line">    host: <span class="string">'smtp.163.com'</span>,</span><br><span class="line">    service: <span class="string">'smtp.163.com'</span>, <span class="comment">// 使用了内置传输发送邮件 查看支持列表：https://nodemailer.com/smtp/well-known/</span></span><br><span class="line">    port: <span class="number">465</span>, <span class="comment">// SMTP 端口</span></span><br><span class="line">    secureConnection: <span class="literal">true</span>, <span class="comment">// 使用了 SSL</span></span><br><span class="line">    auth: &#123; <span class="comment">//用户信息</span></span><br><span class="line">        user: <span class="string">'xxxxxx@163.com'</span>,</span><br><span class="line">        pass: <span class="string">'xxxxxx'</span>, <span class="comment">// smtp授权码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = <span class="string">'标题'</span>;</span><br><span class="line"><span class="keyword">let</span> mailOptions = &#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="string">`&lt;feng960106@163.com&gt;`</span>,</span><br><span class="line">    to: <span class="string">`feng960106@163.com`</span>, <span class="comment">// `1 | 2 | 3` 多个邮箱</span></span><br><span class="line">    subject: title || <span class="string">'自动发邮件'</span>,</span><br><span class="line">    text: <span class="built_in">JSON</span>.stringify(params),</span><br><span class="line">    html: <span class="string">'html模板'</span>,</span><br><span class="line">    <span class="comment">//附件信息</span></span><br><span class="line">    attachments:[</span><br><span class="line">      &#123;</span><br><span class="line">        filename:<span class="string">''</span>,</span><br><span class="line">        path:<span class="string">''</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    transporter.sendMail(mailOptions, (error, info) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">        resolve(info)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">info</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.send(&#123;</span><br><span class="line">        msg: info,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.send(&#123;</span><br><span class="line">        msg: err,</span><br><span class="line">        code: <span class="number">-1</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="koa-compress"><a href="#koa-compress" class="headerlink" title="koa-compress"></a>koa-compress</h4><p><strong>压缩数据</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> compress = <span class="built_in">require</span>(<span class="string">'koa-compress'</span>);</span><br><span class="line"> </span><br><span class="line">app.use(compress(&#123;</span><br><span class="line">    <span class="comment">//只有在请求的content-type中有gzip类型，我们才会考虑压缩</span></span><br><span class="line">    filter: <span class="function"><span class="keyword">function</span> (<span class="params">content_type</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/text/i</span>.test(content_type);</span><br><span class="line">    &#125;,</span><br><span class="line">    threshold: <span class="number">1024</span>*<span class="number">2</span>, <span class="comment">//阀值，当数据超过2kb的时候，可以压缩</span></span><br><span class="line">    flush: <span class="built_in">require</span>(<span class="string">'zlib'</span>).Z_SYNC_FLUSH</span><br><span class="line">&#125;));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.compress = <span class="literal">true</span>; <span class="comment">//是否压缩数据</span></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="async-await后ctx-body失效"><a href="#async-await后ctx-body失效" class="headerlink" title="async/await后ctx.body失效"></a>async/await后ctx.body失效</h4><p><strong>事由</strong></p>
<p>在做ssr的时候，在Promise.all()里面返回的ctx.body没有值，但是能打印出来</p>
<p><strong>原因</strong></p>
<p>中间件在调用next()的时候 并没有把next当作一个异步函数使用。因此你在promise中异步赋值了ctx.body，但是由于next函数没有等你，在你赋值之前这一网络请求就已经完成了。</p>
<p><strong>解决办法</strong></p>
<ol>
<li>使用异步的中间件<code>async/await和promise</code></li>
<li>检查你的中间件的next函数是否等待了。</li>
</ol>
]]></content>
      <categories>
        <category>Server</category>
        <category>NodeJS</category>
        <category>Koa2</category>
      </categories>
      <tags>
        <tag>Koa2</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongodb安装</title>
    <url>/2019/05/10/workspace/Server/sql/mongodb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Mongodb安装</strong></p>
<p>[[toc]]</p>
<h3 id="本地安装mongodb"><a href="#本地安装mongodb" class="headerlink" title="本地安装mongodb"></a>本地安装mongodb</h3><p><a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">安装地址</a></p>
<p>打开安装的目录，默认没有data,etc ,log 文件的</p>
<p>sudo mkdir -p /data/db</p>
<p>sudo chown -R zhf /data</p>
<p>./mongod 就可以启动了，但是全局不能使用，需要配置下</p>
<p>设置全局路径 ： echo ‘export PATH=/Users/zhenfeng/mongodb/bin:$PATH’&gt;&gt;~/.bash_profile </p>
<p>在根路径source .bash_profile就生效了，查看是否成功</p>
<p>$PATH/ /是否有当前db 的目录</p>
<p>which mongod  //是否路径</p>
<p>问题：整好之后发现配置的环境变量（mongod）不起作用了，执行source .bash_profile后，mongod可以用了，但是终端全部关闭后，再输入mongod，就不起作用了。</p>
<p><strong>解决方法</strong></p>
<p>执行vi ~/.zshrc打开.zshrc,将 source .bash_profile 粘贴到最下面，保存即可。或者直接open .bash_profile把里面的内容粘贴到.zshrc里面,保存重启即可。</p>
<p>接下来就是启动mongodb了,cmd+T 新建命令窗口，使用命令 <code>mongod</code> 启动mongoDB server，启动成功后最后一行应该是端口号27017</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2019/5/24/16ae8fe807c8c514?w=636&h=266&f=png&s=111571" alt=""></p>
<p>mongodb 启动成功，正等待着被连接。</p>
<p>cmd+T 新建命令窗口，执行 <code>mongo</code>，进入 mongodb 命令行模式：</p>
<h3 id="阿里云服务器安装mongodb"><a href="#阿里云服务器安装mongodb" class="headerlink" title="阿里云服务器安装mongodb"></a>阿里云服务器安装mongodb</h3><p>1.下载mongodb</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 兼容性好</span></span><br><span class="line"><span class="attribute">curl</span> -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.2.9.tgz</span><br><span class="line"></span><br><span class="line">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.13.tgz</span><br></pre></td></tr></table></figure>

<p>2.解压</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> zxvf mongodb-linux-x86_64-<span class="number">3</span>.<span class="number">2</span>.<span class="number">9</span>.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># copy到usr目录下【使用规范】</span></span><br><span class="line">cp -r mongodb-macos-x86_64-<span class="number">4</span>.<span class="number">0</span>.<span class="number">13</span>   /usr/mongodb</span><br></pre></td></tr></table></figure>

<p>3.创建数据文件夹和日志文件等</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mkdir</span> -p  /usr/local/mongodb/data</span><br><span class="line">touch /usr/local/mongodb/mongodb.log</span><br><span class="line">touch /usr/local/mongodb/mongodb.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># mongodb.conf配置文件如下</span></span><br><span class="line">dbpath=/usr/local/mongodb/data</span><br><span class="line">logpath=/usr/local/mongodb/mongodb.log</span><br><span class="line">logappend = <span class="literal">true</span> </span><br><span class="line">port = <span class="number">27017</span> </span><br><span class="line">fork = <span class="literal">true</span> </span><br><span class="line">auth = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>4.启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置全局变量</span><br><span class="line">export PATH&#x3D;$(pwd)&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line"># 跳转到</span><br><span class="line">&#x2F;usr&#x2F;mongodb&#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line"># 开启数据库</span><br><span class="line">.&#x2F;mongod --config &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;mongodb.conf</span><br><span class="line">.&#x2F;mongod --dbpath&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data --logpath&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;mongodb.log --logappend  --port&#x3D;27017 --fork</span><br><span class="line"></span><br><span class="line"># 关闭数据库</span><br><span class="line">.&#x2F;mongod -shutdown -dbpath&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data</span><br><span class="line"></span><br><span class="line"># 查看是否开启</span><br><span class="line">netstat -lanp | grep &quot;27017&quot;</span><br><span class="line">ps -ef|grep mongod</span><br><span class="line"></span><br><span class="line"># 不能使用kill -9 杀死mongo</span><br><span class="line"></span><br><span class="line"># 补救</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data&#x2F;</span><br><span class="line">rm -rf *.lock</span><br><span class="line">.&#x2F;mongod  --repair</span><br><span class="line"></span><br><span class="line"># 从0~65535全部是标准端口，但是从0~1024号端口是系统端口，用户无法修改</span><br><span class="line"># 从1025~65534端口是系统为用户预留的端口，而65535号端口为系统保留</span><br></pre></td></tr></table></figure>

<p>5.创建完成后需要在阿里云控制台配置防火墙才能连接</p>
<h3 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h3><ul>
<li><p>导出数据库<br>./mongoexport –port [port] –db test –collection users –out export.json</p>
</li>
<li><p>导入数据库<br>./mongoimport -h 120.79.229.197:27-17 -d test -c scenics –file=./export.json</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Server</category>
        <category>Mongodb</category>
      </categories>
  </entry>
  <entry>
    <title>终端实现console输出不同颜色</title>
    <url>/2019/08/15/workspace/Server/node/node-console/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>终端实现console输出不同颜色</strong></p>
<p>[[toc]]</p>
<p><strong>在浏览器的控制塔也适用</strong></p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'\x1B[31m%s\x1B[0m'</span>, <span class="string">'这是红色'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'\x1B[36m%s\x1B[0m'</span>, <span class="string">'这是青色'</span>)</span><br></pre></td></tr></table></figure>



<h4 id="规则说明"><a href="#规则说明" class="headerlink" title="规则说明"></a>规则说明</h4><ul>
<li><strong><code>\x1B[31m</code> 是一个转义序列，它将被您的终端拦截并指示它切换到红色。<code>\x1B</code>是不可打印控制字符 的代码escape。仅处理颜色和样式的转义序列也称为 <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors" target="_blank" rel="noopener">ANSI转义码</a> 并且是标准化的，因此它们（应该）可以在任何平台上工作。这里可以指定多种样式<code>\x1B[31m\x1B[42m</code>；</strong></li>
<li><strong><code>%s</code> 是字符串（第二个参数）被注入的位置；上述代码还可以这样写：</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'\x1B[31m这是红色\x1B[0m'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'\x1B[36m这是青色\x1B[0m'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>\x1B[0m</code> 表示重置终端颜色，使其在此之后不再继续成为所选颜色；</strong>「推荐种用法」</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 颜色参考</span></span><br><span class="line"><span class="keyword">const</span> styles = &#123;</span><br><span class="line">    <span class="string">'reset'</span>: <span class="string">'\x1B[0m'</span>,</span><br><span class="line">    <span class="string">'bright'</span>    : <span class="string">'\x1B[1m'</span>, <span class="comment">// 亮色</span></span><br><span class="line">    <span class="string">'grey'</span>      : <span class="string">'\x1B[2m'</span>, <span class="comment">// 灰色</span></span><br><span class="line">    <span class="string">'italic'</span>    : <span class="string">'\x1B[3m'</span>, <span class="comment">// 斜体</span></span><br><span class="line">    <span class="string">'underline'</span> : <span class="string">'\x1B[4m'</span>, <span class="comment">// 下划线</span></span><br><span class="line">    <span class="string">'reverse'</span>   : <span class="string">'\x1B[7m'</span>, <span class="comment">// 反向</span></span><br><span class="line">    <span class="string">'hidden'</span>    : <span class="string">'\x1B[8m'</span>, <span class="comment">// 隐藏</span></span><br><span class="line">    <span class="string">'black'</span>     : <span class="string">'\x1B[30m'</span>, <span class="comment">// 黑色</span></span><br><span class="line">    <span class="string">'red'</span>       : <span class="string">'\x1B[31m'</span>, <span class="comment">// 红色</span></span><br><span class="line">    <span class="string">'green'</span>     : <span class="string">'\x1B[32m'</span>, <span class="comment">// 绿色</span></span><br><span class="line">    <span class="string">'yellow'</span>    : <span class="string">'\x1B[33m'</span>, <span class="comment">// 黄色</span></span><br><span class="line">    <span class="string">'blue'</span>      : <span class="string">'\x1B[34m'</span>, <span class="comment">// 蓝色</span></span><br><span class="line">    <span class="string">'magenta'</span>   : <span class="string">'\x1B[35m'</span>, <span class="comment">// 品红</span></span><br><span class="line">    <span class="string">'cyan'</span>      : <span class="string">'\x1B[36m'</span>, <span class="comment">// 青色</span></span><br><span class="line">    <span class="string">'white'</span>     : <span class="string">'\x1B[37m'</span>, <span class="comment">// 白色</span></span><br><span class="line">    <span class="string">'blackBG'</span>   : <span class="string">'\x1B[40m'</span>, <span class="comment">// 背景色为黑色</span></span><br><span class="line">    <span class="string">'redBG'</span>     : <span class="string">'\x1B[41m'</span>, <span class="comment">// 背景色为红色</span></span><br><span class="line">    <span class="string">'greenBG'</span>   : <span class="string">'\x1B[42m'</span>, <span class="comment">// 背景色为绿色</span></span><br><span class="line">    <span class="string">'yellowBG'</span>  : <span class="string">'\x1B[43m'</span>, <span class="comment">// 背景色为黄色</span></span><br><span class="line">    <span class="string">'blueBG'</span>    : <span class="string">'\x1B[44m'</span>, <span class="comment">// 背景色为蓝色</span></span><br><span class="line">    <span class="string">'magentaBG'</span> : <span class="string">'\x1B[45m'</span>, <span class="comment">// 背景色为品红</span></span><br><span class="line">    <span class="string">'cyanBG'</span>    : <span class="string">'\x1B[46m'</span>, <span class="comment">// 背景色为青色</span></span><br><span class="line">    <span class="string">'whiteBG'</span>   : <span class="string">'\x1B[47m'</span> <span class="comment">// 背景色为白色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">colors</span>(<span class="params">keys, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> keys === <span class="string">'string'</span>)&#123;</span><br><span class="line">        values = styles[keys]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            values += styles[key]</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values + source + styles[<span class="string">'reset'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">console</span>.log(colors([<span class="string">'red'</span>,<span class="string">'greenBG'</span>,<span class="string">'underline'</span>], <span class="string">'这是红色、绿色背景、下划线'</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Server</category>
        <category>NodeJS</category>
      </categories>
  </entry>
  <entry>
    <title>Mongoose使用</title>
    <url>/2019/06/10/workspace/Server/sql/mongoose/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>Mongoose使用</strong></p>
<p>[[toc]]</p>
<h3 id="链接mongo"><a href="#链接mongo" class="headerlink" title="链接mongo"></a>链接mongo</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @ use 数据库连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../../config/common'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dbConfig = config[process.env.NODE_ENV || <span class="string">'development'</span>];</span><br><span class="line"></span><br><span class="line">mongoose.connect(dbConfig.mongo.url, &#123;<span class="attr">useNewUrlParser</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">mongoose.set(<span class="string">'useCreateIndex'</span>, <span class="literal">true</span>); <span class="comment">//加上这个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接成功</span></span><br><span class="line">mongoose.connection.on(<span class="string">'connected'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//console.log('连接成功 ' + dbConfig.mongo.url);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接失败</span></span><br><span class="line">mongoose.connection.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'连接失败 '</span> + err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开连接</span></span><br><span class="line">mongoose.connection.on(<span class="string">'disconnected'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'断开连接'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="定义Schema"><a href="#定义Schema" class="headerlink" title="定义Schema"></a>定义Schema</h3><h4 id="Schema-Type"><a href="#Schema-Type" class="headerlink" title="Schema.Type"></a>Schema.Type</h4><ul>
<li>String</li>
<li>Number</li>
<li>Date</li>
<li>Buffer</li>
<li>Boolean</li>
<li>Mixed</li>
<li>Objectid</li>
<li>Array</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">var</span> Schema   = mongoose.Schema;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> UserSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name  : &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">unique</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    posts : [&#123; <span class="attr">type</span>: Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">'Post'</span> &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> User = mongoose.model(<span class="string">'User'</span>, UserSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> PostSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    poster   : &#123; <span class="attr">type</span>: Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">'User'</span> &#125;,</span><br><span class="line">    comments : [&#123; <span class="attr">type</span>: Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">'Comment'</span> &#125;],</span><br><span class="line">    title    : <span class="built_in">String</span>,</span><br><span class="line">    content  : <span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> Post = mongoose.model(<span class="string">'Post'</span>, PostSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> CommentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    post      : &#123; <span class="attr">type</span>: Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">"Post"</span> &#125;,</span><br><span class="line">    commenter : &#123; <span class="attr">type</span>: Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">'User'</span> &#125;,</span><br><span class="line">    content   : &#123;</span><br><span class="line">        main: <span class="built_in">String</span>,</span><br><span class="line">        label: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    points: [</span><br><span class="line">        point: [&#123;<span class="attr">type</span>: Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">'Point'</span>&#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> Comment = mongoose.model(<span class="string">'Comment'</span>, CommentSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> PointSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  parent: &#123;<span class="attr">type</span>: Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">'point'</span>&#125;,</span><br><span class="line">  children: [&#123;<span class="attr">type</span>: Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">'point'</span>&#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> Point = mongoose.model(<span class="string">'Point'</span>, PointSchema);</span><br></pre></td></tr></table></figure>

<h3 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$or　　　　或关系</span><br><span class="line">$nor　　　 或关系取反</span><br><span class="line">$gt　　　　大于</span><br><span class="line">$gte　　　 大于等于</span><br><span class="line">$lt　　　　 小于</span><br><span class="line">$lte　　　  小于等于</span><br><span class="line">$ne            不等于</span><br><span class="line">$in             在多个值范围内</span><br><span class="line">$nin           不在多个值范围内</span><br><span class="line">$all            匹配数组中多个值</span><br><span class="line">$regex　　正则，用于模糊查询</span><br><span class="line">$size　　　匹配数组大小</span><br><span class="line">$maxDistance　　范围查询，距离（基于LBS）</span><br><span class="line">$mod　　   取模运算</span><br><span class="line">$near　　　邻域查询，查询附近的位置（基于LBS）</span><br><span class="line">$exists　　  字段是否存在</span><br><span class="line">$elemMatch　　匹配内数组内的元素</span><br><span class="line">$within　　范围查询（基于LBS）</span><br><span class="line">$box　　　 范围查询，矩形范围（基于LBS）</span><br><span class="line">$center       范围醒询，圆形范围（基于LBS）</span><br><span class="line">$centerSphere　　范围查询，球形范围（基于LBS）</span><br><span class="line">$slice　　　　查询字段集合中的元素（比如从第几个之后，第N到第M个元素）</span><br></pre></td></tr></table></figure>

<h3 id="mongodb对数组中的所有元素进行一次性修改方法"><a href="#mongodb对数组中的所有元素进行一次性修改方法" class="headerlink" title="mongodb对数组中的所有元素进行一次性修改方法"></a>mongodb对数组中的所有元素进行一次性修改方法</h3><p><strong>$[]</strong></p>
<p>可以通过$[element] 配合 $cond 条件操作符等，来达到对数组的符合条件的元素统一更新。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="number">4</span>,</span><br><span class="line">    list: [&#123;</span><br><span class="line">        id: <span class="string">"a"</span>,</span><br><span class="line">        date: <span class="number">1504195200000</span>,</span><br><span class="line">        other: <span class="string">"c"</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        id: <span class="string">"b"</span>,</span><br><span class="line">        date: <span class="number">1504195200000</span>,</span><br><span class="line">        other: <span class="string">"c"</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在要把other全部更新为”a”,方法如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.getCollection(<span class="string">'test'</span>).update(&#123;<span class="string">'name'</span>: <span class="number">4</span>&#125;, &#123;<span class="attr">$set</span>: &#123;<span class="string">'list.$[].other'</span>: <span class="string">'a'</span>&#125;&#125;, &#123;<span class="attr">multi</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="总结中…"><a href="#总结中…" class="headerlink" title="总结中…"></a>总结中…</h3>]]></content>
      <categories>
        <category>Server</category>
        <category>Mongodb</category>
      </categories>
      <tags>
        <tag>Mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3.o源码分析</title>
    <url>/2020/03/17/workspace/Frame/vue/next/reactivity/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>vue3.o源码分析</strong></p>
<p>[[toc]]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>调研的预览版本，很多api还没完善，但大致架构已经成形, 暂时还不能用于生产。</p>
<p><strong>优势</strong></p>
<ul>
<li>函数式编程，函数对ts兼容性好【react-hooks】</li>
<li>static tree hoisting 功能 （检测静态语法，进行提升）  【diff】</li>
<li>基于 Proxy 实现的数据变更检测  【不需要递归了，节省内存】</li>
<li>支持 Fragments  【 react 空标签，当根元素用】</li>
<li>支持 Portals  【react 允许在DOM的其它位置进行渲染】</li>
<li>同时支持 Composition API 和 Options API  【单文件兼容vue2.o】</li>
<li>Custom Renderer API  【自定义渲染器API】</li>
</ul>
<h2 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── packages</span><br><span class="line">│   ├── compiler-core # 所有平台的编译器(weex也是基于这个)</span><br><span class="line">│   ├── compiler-dom # 针对浏览器的编译器</span><br><span class="line">│   ├── compiler-ssr # ssr</span><br><span class="line">│   ├── compiler-sfc # 针对单文件</span><br><span class="line">│   ├── reactivity # 数据响应式系统</span><br><span class="line">│   ├── runtime-core # 渲染器，一些核心的api</span><br><span class="line">│   ├── runtime-dom # 针对浏览器的runtime,包括处理原生DOM </span><br><span class="line">│   ├── runtime-test # 专门为测试写的runtime</span><br><span class="line">│   ├── server-renderer # 用于SSR</span><br><span class="line">│   ├── shared # 帮助方法</span><br><span class="line">│   ├── template-explorer</span><br><span class="line">│   └── vue # 构建vue</span><br></pre></td></tr></table></figure>

<h2 id="composition-api"><a href="#composition-api" class="headerlink" title="composition-api"></a>composition-api</h2><p>Composition API纯粹是添加的，不会影响/弃用任何现有的2.x API，它是可以单独导入到项目中的</p>
<p><strong>动机</strong></p>
<ul>
<li>Vue 3 使用ts实现了类型推断，新版api全部采用普通函数，在编写代码时可以享受完整的类型推断（避免使用装饰器）</li>
<li>解决了多组件间<strong>逻辑重用</strong>问题 （解决：高阶组件、mixin、作用域插槽）<ul>
<li>如果项目过于复杂的时候，mixin中的代码和外部组件的代码存在命名冲突的时候会被覆盖，而且如果有相同的生命周期函数也会被覆盖，所以会导致代码难以维护，容易出现bug</li>
<li>代码分散</li>
</ul>
</li>
</ul>
<blockquote>
<p>// 安装<br/><br>yarn add @vue/composition-api<br/><br>// 使用<br/><br>import Vue from ‘vue’;<br/><br>import VueCompositionApi from ‘@vue/composition-api’;<br/><br>Vue.use(VueCompositionApi);<br/></p>
</blockquote>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldProtoMehtods = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">let</span> proto = <span class="built_in">Object</span>.create(oldProtoMehtods);</span><br><span class="line"><span class="comment">// 针对数组</span></span><br><span class="line">[<span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'sort'</span>, <span class="string">'reverse'</span>, <span class="string">'splice'</span>].forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    proto[method] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 函数劫持，把内部的函数重写，数组方法还是继续调用老的方法</span></span><br><span class="line">        updateView();</span><br><span class="line">        observer(...arguments);</span><br><span class="line">        oldProtoMehtods[method].call(<span class="keyword">this</span>, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(target)) <span class="keyword">return</span> target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target)) &#123;</span><br><span class="line">        target.__proto__ = proto;  <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给数组中的每一项进行observer</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; target.length; i++) &#123;</span><br><span class="line">            observer(target[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        defineReactive(target, key, target[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">    observer(value); <span class="comment">// 有可能对象类型是多层，递归劫持</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="comment">// 在get 方法中收集依赖</span></span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'set方法'</span>, newVal);</span><br><span class="line">            <span class="keyword">if</span> (newVal !== value) &#123;</span><br><span class="line">                updateView(); <span class="comment">// 在set方法中触发更新</span></span><br><span class="line">                observer(newVal); <span class="comment">// 防止传进来是一个二级对象，不能对以后的数据监测</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">ary</span>: [<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">age</span>: <span class="number">22</span>&#125;]&#125;;</span><br><span class="line"><span class="keyword">let</span> result = observer(data);</span><br><span class="line"></span><br><span class="line">data.ary.push(&#123;<span class="attr">age</span>: <span class="number">33</span>&#125;);</span><br><span class="line">data.ary.push([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">data.ary[<span class="number">4</span>].push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">data.ary[<span class="number">4</span>].splice(<span class="number">1</span>, <span class="number">1</span>, <span class="number">22222</span>);</span><br><span class="line"><span class="comment">// data.ary[4][1] = 2222;  不会触发更新，值会改变</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data.ary);</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong></p>
<ul>
<li>无法监听数组的变化</li>
<li>需要递归深度遍历，浪费内存</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无法响应式</span></span><br><span class="line">vm.items[indexOfItem] = newValue</span><br><span class="line">vm.items.length = newLength</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法</span></span><br><span class="line">vm.$<span class="keyword">set</span>(vm.items, indexOfItem, newValue)</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br><span class="line"></span><br><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>

<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h3><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>下面是自己提炼的的核心代码，<a href="/workspace/Frame/vue/next/ref">源码分析看这</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ref</span></span><br><span class="line"><span class="keyword">const</span> convert = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> isObject(val) ? reactive(val) : val</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">rawValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = convert(rawValue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = &#123;</span><br><span class="line">    __v_isRef: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span> value() &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> value(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'视图更新'</span>);</span><br><span class="line">      value = convert(newVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">// toRefs</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toRefs</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ret = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    ret[key] = toRef(object, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toRef</span>(<span class="params">object, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    __v_isRef: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span> value() &#123;</span><br><span class="line">      <span class="keyword">return</span> object[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> value(newVal) &#123;</span><br><span class="line">      object[key] = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><h2 id="Beta升级使用"><a href="#Beta升级使用" class="headerlink" title="Beta升级使用"></a>Beta升级使用</h2><p><code>写demo可以，公司正式项目不建议，后期少不了小改动</code></p>
<h2 id="安装3-o新版本"><a href="#安装3-o新版本" class="headerlink" title="安装3.o新版本"></a>安装3.o新版本</h2><blockquote>
<p>yarn add vue@next  vue-router@next vuex@next<br>yarn add @vue/compiler-sfc@next eslint-plugin-vue@next vue-cli-plugin-vue-next -D</p>
</blockquote>
<h2 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onMounted, onUnmounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useMousePosition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = ref(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> y = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    x.value = e.pageX</span><br><span class="line">    y.value = e.pageY</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, update)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, update)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在组件中使用：</span></span><br><span class="line"><span class="keyword">import</span> &#123; useMousePosition &#125; <span class="keyword">from</span> <span class="string">'./mouse'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ...useMousePosition() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/vuejs/vue-next" target="_blank" rel="noopener">vue-next</a><br><a href="https://github.com/vuejs/vue-cli-plugin-vue-next" target="_blank" rel="noopener">vue-cli-plugin-vue-nex</a><br><a href="https://vue-composition-api-rfc.netlify.app/#summary" target="_blank" rel="noopener">vue-composition-api文档</a><br><a href="https://vue-next-template-explorer.netlify.app/" target="_blank" rel="noopener">vue3的编译工具</a><br><a href="https://juejin.im/post/5e9f6b3251882573a855cd52" target="_blank" rel="noopener">尤雨溪在Vue3.0Beta直播里聊到了这些</a><br><a href="https://juejin.im/post/5eaead656fb9a0438d4060be" target="_blank" rel="noopener">juejin</a><br><a href="https://segmentfault.com/a/1190000020709962?utm_source=tag-newest" target="_blank" rel="noopener">segmentfault</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>源码分析</category>
      </categories>
  </entry>
  <entry>
    <title>keep-alive源码分析</title>
    <url>/2020/06/02/workspace/Frame/vue/source-code/keep-alive/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>keep-alive源码分析</strong></p>
<p>[[toc]]</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>想看具体用法看我上一篇文章 <a href="/2020/05/25/workspace/Frame/vue/keep-alive/">这大概是最全乎的keep-alive的踩坑指南</a></p>
<h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js#L53" target="_blank" rel="noopener">源码地址</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /src/core/components/keep-alive.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;isRegExp, remove&#125; <span class="keyword">from</span> <span class="string">'shared/util'</span></span><br><span class="line"><span class="keyword">import</span> &#123;getFirstComponentChild&#125; <span class="keyword">from</span> <span class="string">'core/vdom/helpers/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取组件的name值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponentName</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> opts &amp;&amp; (opts.Ctor.options.name || opts.tag)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应着includes那三种格式（数组、正则、和字符串），判断是否有当前的name</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matches</span>(<span class="params">pattern, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(pattern)) &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.indexOf(name) &gt; <span class="number">-1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> pattern === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.split(<span class="string">','</span>).indexOf(name) &gt; <span class="number">-1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRegExp(pattern)) &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.test(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传进来当前的this和一个判断是否有当前name的函数</span></span><br><span class="line"><span class="comment">// pruneCache函数的核心是调用pruneCacheEntry</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCache</span>(<span class="params">keepAliveInstance, filter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;cache, keys, _vnode&#125; = keepAliveInstance</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">    <span class="keyword">const</span> cachedNode = cache[key]</span><br><span class="line">    <span class="keyword">if</span> (cachedNode) &#123;</span><br><span class="line">      <span class="keyword">const</span> name = getComponentName(cachedNode.componentOptions)</span><br><span class="line">      <span class="keyword">if</span> (name &amp;&amp; !filter(name)) &#123;</span><br><span class="line">        <span class="comment">// 如果当前组件没有缓存，直接删除</span></span><br><span class="line">        pruneCacheEntry(cache, key, keys, _vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCacheEntry</span>(<span class="params">cache, key, keys, current</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cached = cache[key]</span><br><span class="line">  <span class="keyword">if</span> (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123;</span><br><span class="line">    cached.componentInstance.$destroy() <span class="comment">// 销毁当前组件</span></span><br><span class="line">  &#125;</span><br><span class="line">  cache[key] = <span class="literal">null</span></span><br><span class="line">  remove(keys, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> patternTypes = [<span class="built_in">String</span>, <span class="built_in">RegExp</span>, <span class="built_in">Array</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'keep-alive'</span>,</span><br><span class="line">  <span class="comment">// 抽象组件没有真实的节点，在组件渲染的时候不会解析渲染成真实的dom节点，而只是作为中间的数据过度层处理，在keep-alive中是对组件缓存做处理</span></span><br><span class="line">  abstract: <span class="literal">true</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes, <span class="comment">// 要缓存的组件</span></span><br><span class="line">    exclude: patternTypes, <span class="comment">// 不缓存的组件</span></span><br><span class="line">    max: [<span class="built_in">String</span>, <span class="built_in">Number</span>] <span class="comment">// 缓存的个数</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)  <span class="comment">// 缓存虚拟dom &#123;key:vnode&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.keys = [] <span class="comment">// 缓存的虚拟dom的键集合</span></span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="keyword">this</span>.cache) &#123;</span><br><span class="line">      <span class="comment">// 删除所有的缓存，所以 &lt;keep-alive&gt; 外面盒子尽可能的不要去使用v-if </span></span><br><span class="line">      pruneCacheEntry(<span class="keyword">this</span>.cache, key, <span class="keyword">this</span>.keys)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      this.$watch('a', val =&gt; &#123;</span></span><br><span class="line"><span class="comment">          console.log(val, 'balabala');</span></span><br><span class="line"><span class="comment">      &#125;)</span></span><br><span class="line"><span class="comment">      watch:&#123;</span></span><br><span class="line"><span class="comment">          a：（newVal,oldVal)=&gt;&#123;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      都是监听值的变化的,方式一是监听不到对象的变化，第一个参数必须是字符串格式的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 监控缓存的变化</span></span><br><span class="line">    <span class="keyword">this</span>.$watch(<span class="string">'include'</span>, val =&gt; &#123;</span><br><span class="line">      pruneCache(<span class="keyword">this</span>, name =&gt; matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.$watch(<span class="string">'exclude'</span>, val =&gt; &#123;</span><br><span class="line">      pruneCache(<span class="keyword">this</span>, name =&gt; !matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 获取第一个子**组件**</span></span><br><span class="line">    <span class="keyword">const</span> slot = <span class="keyword">this</span>.$slots.default</span><br><span class="line">    <span class="comment">// 找到第一个子组件对象</span></span><br><span class="line">    <span class="keyword">const</span> vnode = getFirstComponentChild(slot)</span><br><span class="line">    <span class="keyword">const</span> componentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line">    <span class="comment">// 是否存在组件参数</span></span><br><span class="line">    <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">      <span class="keyword">const</span> name = getComponentName(componentOptions)<span class="comment">// 获取组件名字</span></span><br><span class="line">      <span class="keyword">const</span> &#123;include, exclude&#125; = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// 判断如果include没有当前的name或者exclude有不需要缓存的name  就返回vnode</span></span><br><span class="line">      <span class="keyword">if</span> ((include &amp;&amp; (!name || !matches(include, name))) || (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))) &#123;</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123;cache, keys&#125; = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// 根据组件ID和tag生成缓存Key，会出现一个问题，就是在开发的时候，热加载后可能是空页面。</span></span><br><span class="line">      <span class="keyword">const</span> key = vnode.key == <span class="literal">null</span> ?</span><br><span class="line">        componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">''</span>) :</span><br><span class="line">        vnode.key</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">        <span class="comment">// 如果有缓存的话，直接赋值给vnode</span></span><br><span class="line">        vnode.componentInstance = cache[key].componentInstance</span><br><span class="line">        remove(keys, key)  <span class="comment">// 删除当前的键</span></span><br><span class="line">        keys.push(key)  <span class="comment">// 然后把这个键追加到最后一位，目的就是排序，防止后面max的干扰</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有缓存的话，直接都存储起来</span></span><br><span class="line">        cache[key] = vnode</span><br><span class="line">        keys.push(key)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="keyword">this</span>.max)) &#123;</span><br><span class="line">          <span class="comment">// 超过缓存数限制，将第一个删除</span></span><br><span class="line">          <span class="comment">// 从这个看出动态改变max的数值，并不能控制缓存的个数，因为上面并没有watch监控max的改变。</span></span><br><span class="line">          pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="keyword">this</span>._vnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      vnode.data.keepAlive = <span class="literal">true</span>  <span class="comment">// 这个决定外面生命周期函数执行，很重要</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实大致可以分为这几步：</p>
<ol>
<li>在要缓存的组件上使用keep-alive标签</li>
<li>根据传递的参数，看是否要添加缓存和限制的个数，不缓存直接返回你当前的vnode，若需要缓存就根据生成的key进行对象存储</li>
<li>存储的过程要注意 max 和存储的位置，如果大于max就要把索引是1的key删除， 实现置换位置。</li>
<li>将该组件实例的keepAlive属性值设置为true(this.$vnode.data.keepAlive 可以获取到，多的两个声明周期都是通过这个判断) </li>
</ol>
<h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><h4 id="只执行一次的钩子"><a href="#只执行一次的钩子" class="headerlink" title="只执行一次的钩子"></a>只执行一次的钩子</h4><p><code>keep-alive</code>是使用你之前存储的vnode，然后直接转换成真实dom，是发生在diff之后 patch阶段,所以缓存的组件是没有 <code>created,mounted</code> 这些生命周期的，具体看下面的代码分析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/create-component.js</span></span><br><span class="line"><span class="keyword">const</span> componentVNodeHooks = &#123;</span><br><span class="line">  init (vnode: VNodeWithData, <span class="attr">hydrating</span>: boolean): ?boolean &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      vnode.componentInstance &amp;&amp;</span><br><span class="line">      !vnode.componentInstance._isDestroyed &amp;&amp;</span><br><span class="line">      vnode.data.keepAlive  <span class="comment">// 这里是判断是否使用了 keepAlive</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> mountedNode: any = vnode</span><br><span class="line">      componentVNodeHooks.prepatch(mountedNode, mountedNode) <span class="comment">// 直接到了patch阶段</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> child = vnode.componentInstance = createComponentInstanceForVnode(</span><br><span class="line">        vnode,</span><br><span class="line">        activeInstance</span><br><span class="line">      )</span><br><span class="line">      child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  prepatch (oldVnode: MountedComponentVNode, <span class="attr">vnode</span>: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> options = vnode.componentOptions</span><br><span class="line">    <span class="keyword">const</span> child = vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">    updateChildComponent(</span><br><span class="line">      child, <span class="comment">// child.$scopedSlots</span></span><br><span class="line">      options.propsData, <span class="comment">// updated props</span></span><br><span class="line">      options.listeners, <span class="comment">// updated listeners</span></span><br><span class="line">      vnode, <span class="comment">// vnode.data.scopedSlots </span></span><br><span class="line">      options.children <span class="comment">// new children</span></span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  insert (vnode) &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</span><br><span class="line">   <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</span><br><span class="line">     componentInstance._isMounted = <span class="literal">true</span></span><br><span class="line">     callHook(componentInstance, <span class="string">'mounted'</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (vnode.data.keepAlive) &#123;</span><br><span class="line">     <span class="keyword">if</span> (context._isMounted) &#123;</span><br><span class="line">       queueActivatedComponent(componentInstance)</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       activateChildComponent(componentInstance, <span class="literal">true</span>) <span class="comment">// 这个就是新增的那个activate生命周期函数</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">destroy (vnode) &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123; componentInstance &#125; = vnode</span><br><span class="line"> <span class="keyword">if</span> (!componentInstance._isDestroyed) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!vnode.data.keepAlive) &#123;</span><br><span class="line">     componentInstance.$destroy()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     deactivateChildComponent(componentInstance, <span class="literal">true</span>) <span class="comment">// 新增的deactivate生命周期函数</span></span><br><span class="line">   &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line"> <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，当vnode.componentInstance(第一次进来是空的)和keepAlive同时为true时，不再进入$mount过程，那mounted之前的所有钩子函数（beforeCreate、created、mounted）都不再执行。</p>
<h4 id="调用activated"><a href="#调用activated" class="headerlink" title="调用activated"></a>调用activated</h4><p>在patch的阶段，最后会执行invokeInsertHook函数，而这个函数就是去调用组件实例（VNode）自身的<code>insert</code>钩子，就是上面的那段代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeInsertHook</span> (<span class="params">vnode, queue, initial</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// delay insert hooks for component root nodes, invoke them after the</span></span><br><span class="line">  <span class="comment">// element is really inserted</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(initial) &amp;&amp; isDef(vnode.parent)) &#123;</span><br><span class="line">    vnode.parent.data.pendingInsert = queue</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; ++i) &#123;</span><br><span class="line">      queue[i].data.hook.insert(queue[i]) <span class="comment">// 调取insert方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>就是上面componentVNodeHooks的insert的方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> insert (vnode) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</span><br><span class="line">  <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</span><br><span class="line">    componentInstance._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(componentInstance, <span class="string">'mounted'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vnode.data.keepAlive) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context._isMounted) &#123;</span><br><span class="line">      queueActivatedComponent(componentInstance)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      activateChildComponent(componentInstance, <span class="literal">true</span>) <span class="comment">// 这个就是新增的那个activate生命周期函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>看下activateChildComponent函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deactivateChildComponent</span> (<span class="params">vm, direct</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm._inactive) &#123;</span><br><span class="line">    vm._inactive = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vm.$children.length; i++) &#123;</span><br><span class="line">      deactivateChildComponent(vm.$children[i])</span><br><span class="line">    &#125;</span><br><span class="line">    callHook(vm, <span class="string">'deactivated'</span>) <span class="comment">//添加钩子方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>deactivated</code>钩子函数也是一样的原理，在组件实例（VNode）的destroy钩子函数中调用<code>deactivateChildComponent</code>函数。</p>
<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p><strong>keep-alive组件的渲染</strong></p>
<p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/lifecycle.js#L32-L42" target="_blank" rel="noopener">/src/core/instance/lifecycle.js</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line">   <span class="comment">// 找到第一个非abstract父组件实例</span></span><br><span class="line">  <span class="keyword">let</span> parent = options.parent</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    parent.$children.push(vm)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="comment">// 实例上的一些参数赋值</span></span><br></pre></td></tr></table></figure>

<p><strong>keep-alive包裹的组件是如何使用缓存的？</strong></p>
<p>在patch阶段，会执行createComponent函数：</p>
<p><a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js#L210-L230" target="_blank" rel="noopener">/src/core/vdom/patch.js</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /src/core/vdom/patch.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">    <span class="comment">// 第一次进来是没有这个的 （vnode.componentInstance），是在keep-alive里面赋值的</span></span><br><span class="line">    <span class="keyword">const</span> isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive</span><br><span class="line">    <span class="keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">      i(vnode, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">      initComponent(vnode, insertedVnodeQueue)</span><br><span class="line">      insert(parentElm, vnode.elm, refElm) <span class="comment">// 直接塞给父级</span></span><br><span class="line">      <span class="keyword">if</span> (isTrue(isReactivated)) &#123; <span class="comment">// 判断是不是空的</span></span><br><span class="line">        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) <span class="comment">// 然后在进行响应式</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>源码分析</category>
        <category>keep-alive源码分析</category>
      </categories>
  </entry>
  <entry>
    <title>全局挂载组件之Vue.extend</title>
    <url>/2020/06/13/workspace/Frame/vue/source-code/vue-extend/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong class='old-blog'>全局挂载组件之Vue.extend</strong></p>
<p>[[toc]]</p>
<p><code>Vue.extend</code> 属于Vue的全局 api，在实际业务开发中我们很少使用，因为相比常用的 <code>Vue.component</code> 写法使用 <code>extend</code> 步骤要更加繁琐一些。但是在一些独立组件开发场景中（例如：ElementUI库），所以<code>Vue.extend</code> + <code>$mount</code> 这对组合非常有必要需要我们了解下。</p>
<h3 id="Vue-component"><a href="#Vue-component" class="headerlink" title="Vue.component"></a>Vue.component</h3><p><a href="https://cn.vuejs.org/v2/api/index.html#Vue-componen" target="_blank" rel="noopener">文档</a></p>
<p><strong>官网用法</strong>：</p>
<p>注册或获取全局组件。注册还会自动使用给定的 <code>id</code> 设置组件的名称</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册组件，传入一个扩展过的构造器</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, Vue.extend(&#123; <span class="comment">/* ... */</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取注册的组件 (始终返回构造器)</span></span><br><span class="line"><span class="keyword">var</span> MyComponent = Vue.component(<span class="string">'my-component'</span>)</span><br><span class="line"><span class="keyword">let</span> ElInput = Vue.component(<span class="string">'ElInput'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> ElInput);  <span class="comment">// 就是Inout的实例</span></span><br></pre></td></tr></table></figure>

<p>用法也特别的简单，你写好的组件，直接在main.js里面导入然后使用<code>Vue.component(&#39;xx-xxx&#39;,xxx)</code>就可以全局通用了。</p>
<ul>
<li><strong>好处</strong><ul>
<li>这样的<code>好处</code>就是所有页面基本上都是通过 router 来管理可以直接注册，组件的创建我们不需要去关注，相比 <code>extend</code> 要更省心一点</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>组件的名称都是自定义的，如果我要从接口动态渲染怎么办。【extend不用必须在初始化的时候完成，下面有实例】</li>
<li>有内容都是在 <code>#app</code> 下渲染，注册组件都是在当前位置渲染。如果我要实现一个模态框的提示组件，就比较鸡肋了。</li>
</ul>
</li>
</ul>
<p>这时候，<code>Vue.extend + vm.$mount</code> 组合就派上用场了。</p>
<h3 id="Vue-extend"><a href="#Vue-extend" class="headerlink" title="Vue.extend"></a>Vue.extend</h3><p><a href="https://cn.vuejs.org/v2/api/index.html#Vue-extend" target="_blank" rel="noopener">文档</a></p>
<p><strong>官网用法:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mount-point"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建构造器</span></span><br><span class="line"><span class="keyword">var</span> Profile = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      firstName: <span class="string">'Walter'</span>,</span><br><span class="line">      lastName: <span class="string">'White'</span>,</span><br><span class="line">      alias: <span class="string">'Heisenberg'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 创建 Profile 实例，并挂载到一个元素上。</span></span><br><span class="line"><span class="keyword">new</span> Profile().$mount(<span class="string">'#mount-point'</span>)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Walter White aka Heisenberg<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以发现<code>Id</code>为<code>mount-point</code>的div ,是直接被替代了，没有在内部填充，在我们 <code>main.js</code> 初始化的时候用发其实也是一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);  <span class="comment">// 此处都是替换，不是填充</span></span><br></pre></td></tr></table></figure>

<p><strong>下面简单的分析下<code>$mount</code>的源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/platforms/web/entry-runtime-with-compiler.js</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'core/config'</span></span><br><span class="line"><span class="keyword">import</span> &#123;warn, cached&#125; <span class="keyword">from</span> <span class="string">'core/util/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123;mark, measure&#125; <span class="keyword">from</span> <span class="string">'core/util/perf'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./runtime/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123;query&#125; <span class="keyword">from</span> <span class="string">'./util/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123;compileToFunctions&#125; <span class="keyword">from</span> <span class="string">'./compiler/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123;shouldDecodeNewlines, shouldDecodeNewlinesForHref&#125; <span class="keyword">from</span> <span class="string">'./util/compat'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> idToTemplate = cached(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> el = query(id)</span><br><span class="line">  <span class="keyword">return</span> el &amp;&amp; el.innerHTML</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount;  <span class="comment">// 缓存了原型上的 $mount 方法</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params">el, hydrating</span>) </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)  <span class="comment">// 通过 query函数 就是获取真实的DOM元素</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断获取的真实 dom元素是否为 body 或 documentElement 报警告</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">  <span class="comment">// 判断有么有render , 咱们一般都是用 template 写的vue，需要编译</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="keyword">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      template = getOuterHTML(el)  <span class="comment">// 即获取 el 的 outerHTML</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">// 然后通过compileToFunctions将 template 转化为 render 函数，options.render = render</span></span><br><span class="line">      <span class="comment">// 所有 Vue 的组件的渲染最终都需要 render 方法，无论是用单页面 .vue 方式开发，还是写了 el 或者 template 属性，</span></span><br><span class="line">      <span class="comment">// 最终都要被转成 render 方法，那么这个过程是 Vue 的一个 “在线编译” 的过程， 它是调用 compileToFunctions 方法实现的，最后调用原型上的 $mount 方法挂载。</span></span><br><span class="line">      <span class="keyword">const</span> &#123;render, staticRenderFns&#125; = compileToFunctions(template, &#123;</span><br><span class="line">        outputSourceRange: process.env.NODE_ENV !== <span class="string">'production'</span>,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, <span class="keyword">this</span>)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有传el的话，会直接执行这步，会把组件在内存中渲染完毕</span></span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 及时获取HTML 兼容IE</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOuterHTML</span>(<span class="params">el</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.outerHTML) &#123;</span><br><span class="line">    <span class="keyword">return</span> el.outerHTML</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    container.appendChild(el.cloneNode(<span class="literal">true</span>))</span><br><span class="line">    <span class="keyword">return</span> container.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Vue.compile = compileToFunctions</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>$mount</code>方法支持传入 2 个参数，第一个是 el，它表示挂载的元素，可以是字符串，也可以是 DOM 对象，如果是字符串在浏览器环境下会调用 query 方法转换成 DOM 对象的。第二个参数是和服务端渲染相关，在浏览器环境下不需要传第二个参数。</p>
</li>
<li><p><code>$mount</code>方法实际上会调用<code>mountComponent</code> 方法，方法定义在 <code>src/core/instance/lifecycle.js</code>中</p>
</li>
</ul>
<h3 id="实现一个弹框组件"><a href="#实现一个弹框组件" class="headerlink" title="实现一个弹框组件"></a>实现一个弹框组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// message/src/index.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"wrap"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"message"</span> :<span class="class"><span class="keyword">class</span></span>=<span class="string">"item.type"</span> v-<span class="keyword">for</span>=<span class="string">"item in notices"</span> :key=<span class="string">"item._name"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;&#123;&#123;item.content&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 默认选项</span></span><br><span class="line">  <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">    duration: <span class="number">1500</span>,</span><br><span class="line">    type: <span class="string">'info'</span>,</span><br><span class="line">    content: <span class="string">'这是一条提示信息！'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> mid = <span class="number">0</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">'MyMessage'</span>, <span class="comment">// 建议添加方便外面直接取值</span></span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        notices: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      addMessage(notice = &#123;&#125;) &#123;</span><br><span class="line">        <span class="comment">// name标识 用于移除弹窗</span></span><br><span class="line">        <span class="keyword">let</span> _name = <span class="keyword">this</span>.getName()</span><br><span class="line">        <span class="comment">// 合并选项</span></span><br><span class="line">        notice = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">          _name</span><br><span class="line">        &#125;, defaultOptions, notice)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.notices.push(notice)</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.removeNotice(_name)</span><br><span class="line">        &#125;, notice.duration) </span><br><span class="line">      &#125;,</span><br><span class="line">      getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'msg_'</span> + (mid++)  <span class="comment">//创建一个唯一的值 </span></span><br><span class="line">      &#125;,</span><br><span class="line">      removeNotice(_name) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="keyword">this</span>.notices.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item._name === _name)</span><br><span class="line">        <span class="keyword">this</span>.notices.splice(index, <span class="number">1</span>)  <span class="comment">// 删除当前超时的dom</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">    .wrap &#123;</span></span><br><span class="line"><span class="regexp">        position: fixed;</span></span><br><span class="line"><span class="regexp">        top: 50px;</span></span><br><span class="line"><span class="regexp">        left: 50%;</span></span><br><span class="line"><span class="regexp">        display: flex;</span></span><br><span class="line"><span class="regexp">        flex-direction: column;</span></span><br><span class="line"><span class="regexp">        align-items: center;</span></span><br><span class="line"><span class="regexp">        transform: translateX(-50%);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    .message &#123;</span></span><br><span class="line"><span class="regexp">        --borderWidth: 3px;</span></span><br><span class="line"><span class="regexp">        min-width: 240px;</span></span><br><span class="line"><span class="regexp">        max-width: 500px;</span></span><br><span class="line"><span class="regexp">        margin-bottom: 10px;</span></span><br><span class="line"><span class="regexp">        border-radius: 3px;</span></span><br><span class="line"><span class="regexp">        box-shadow: 0 0 8px #ddd;</span></span><br><span class="line"><span class="regexp">        overflow: hidden;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    .content &#123;</span></span><br><span class="line"><span class="regexp">        padding: 8px;</span></span><br><span class="line"><span class="regexp">        line-height: 1.3;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 对应的集中状态 </span></span><br><span class="line"><span class="regexp">    .message.info &#123;</span></span><br><span class="line"><span class="regexp">        border-left: var(--borderWidth) solid #909399;</span></span><br><span class="line"><span class="regexp">        background: #F4F4F5;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    .message.success &#123;</span></span><br><span class="line"><span class="regexp">        border-left: var(--borderWidth) solid #67C23A;</span></span><br><span class="line"><span class="regexp">        background: #F0F9EB;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    .message.error &#123;</span></span><br><span class="line"><span class="regexp">        border-left: var(--borderWidth) solid #F56C6C;</span></span><br><span class="line"><span class="regexp">        background: #FEF0F0;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    .message.warning &#123;</span></span><br><span class="line"><span class="regexp">        border-left: var(--borderWidth) solid #E6A23C;</span></span><br><span class="line"><span class="regexp">        background: #FDF6EC;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// message/index.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Message <span class="keyword">from</span> <span class="string">'./src/index.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> messageInstance = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> TempMessage = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟异步请求</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  TempMessage = Message</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> init = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> MessageConstructor = TempMessage &amp;&amp; Vue.extend(TempMessage)</span><br><span class="line"></span><br><span class="line">  messageInstance = <span class="keyword">new</span> MessageConstructor(&#123;&#125;)<span class="comment">// 构造函数可以接传值，data、methods.....</span></span><br><span class="line">  <span class="comment">// console.log(messageInstance);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// $mount()不带参数，会把组件在内存中渲染完毕</span></span><br><span class="line">  messageInstance.$mount()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// messageInstance.$el 拿到的就是组件对应的dom元素,可以直接操作dom</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(messageInstance.$el)</span><br><span class="line">  messageInstance.$el.style.zIndex = <span class="number">9999</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> caller = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!messageInstance) &#123;</span><br><span class="line">    <span class="comment">// 进页面初始化</span></span><br><span class="line">    init(options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// addMessage 是组件内部声明的方法，也可以通过构造函数传对应的方法</span></span><br><span class="line">  messageInstance.addMessage(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install(vue) &#123;</span><br><span class="line">    vue.prototype.$mymessage = caller</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Message <span class="keyword">from</span> <span class="string">'@/components/Message/index.js'</span></span><br><span class="line">Vue.use(Message)</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$mymessage(&#123;</span><br><span class="line">  type: <span class="string">'warning'</span>,</span><br><span class="line">  content: <span class="string">'你好坏啊，我好喜欢'</span>,</span><br><span class="line">  duration: <span class="number">6000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/weixin_44867717/article/details/104954173" target="_blank" rel="noopener">JavaScript 方式调用的组件</a></p>
]]></content>
      <categories>
        <category>FE框架</category>
        <category>Vue</category>
        <category>源码分析</category>
        <category>Vue.extend</category>
      </categories>
  </entry>
</search>
