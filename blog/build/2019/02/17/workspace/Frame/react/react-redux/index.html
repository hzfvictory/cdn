<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redux源码解析 | hfzvictory</title><meta name="description" content="Redux源码解析 [[toc]] Redux三大原则 唯一数据源 整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中   保持只读状态 state是只读的，唯一改变state的方法就是触发action，action是一个用于描述以发生时间的普通对象 store里面保存的都是普通Object，可直接修改他的值，官方文档说的“只有通过action才能修改状态”更"><meta name="keywords" content="和振峰博客，web前端，node全栈工程师，hzfvictory"><meta name="author" content="hfzvictory,feng960106@163.com"><meta name="copyright" content="hfzvictory"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Redux源码解析"><meta name="twitter:description" content="Redux源码解析 [[toc]] Redux三大原则 唯一数据源 整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中   保持只读状态 state是只读的，唯一改变state的方法就是触发action，action是一个用于描述以发生时间的普通对象 store里面保存的都是普通Object，可直接修改他的值，官方文档说的“只有通过action才能修改状态”更"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Redux源码解析"><meta property="og:url" content="http://file.jing999.cn/2019/02/17/workspace/Frame/react/react-redux/"><meta property="og:site_name" content="hfzvictory"><meta property="og:description" content="Redux源码解析 [[toc]] Redux三大原则 唯一数据源 整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中   保持只读状态 state是只读的，唯一改变state的方法就是触发action，action是一个用于描述以发生时间的普通对象 store里面保存的都是普通Object，可直接修改他的值，官方文档说的“只有通过action才能修改状态”更"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="article:published_time" content="2019-02-17T00:00:00.000Z"><meta property="article:modified_time" content="2020-09-09T03:09:10.885Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://file.jing999.cn/2019/02/17/workspace/Frame/react/react-redux/"><link rel="prev" title="NodeJs的原生方法" href="http://file.jing999.cn/2019/03/15/workspace/Server/node/base/"><link rel="next" title="Koa2" href="http://file.jing999.cn/2019/02/15/workspace/Server/node/node-1/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: hfzvictory","link":"链接: ","source":"来源: hfzvictory","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ae01.alicdn.com/kf/H9ae3136bf5e440239fa2c611632fbd09H.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">104</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">99</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/todos"><i class="fa-fw fa fa-battery-three-quarters"></i><span> Todos</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bicycle" aria-hidden="true"></i><span> 喜好</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redux三大原则"><span class="toc-number">1.</span> <span class="toc-text">Redux三大原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Action-amp-store-dispatch"><span class="toc-number">2.</span> <span class="toc-text">Action &amp; store.dispatch( )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reducer"><span class="toc-number">3.</span> <span class="toc-text">Reducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Store"><span class="toc-number">4.</span> <span class="toc-text">Store</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redux源码"><span class="toc-number">5.</span> <span class="toc-text">Redux源码 *</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Redux"><span class="toc-number">6.</span> <span class="toc-text">React-Redux</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Provider"><span class="toc-number">6.1.</span> <span class="toc-text">Provider</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Connect"><span class="toc-number">6.2.</span> <span class="toc-text">Connect</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步处理"><span class="toc-number">7.</span> <span class="toc-text">异步处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redux-thunk"><span class="toc-number">7.1.</span> <span class="toc-text">redux-thunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redux-saga"><span class="toc-number">7.2.</span> <span class="toc-text">redux-saga</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux-middleware-源码分析"><span class="toc-number">8.</span> <span class="toc-text">redux middleware 源码分析</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div class="post-bg" id="nav" style="background-image: url(https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">hfzvictory</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/todos"><i class="fa-fw fa fa-battery-three-quarters"></i><span> Todos</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bicycle" aria-hidden="true"></i><span> 喜好</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Redux源码解析</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-02-17 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-02-17</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-09-09 03:09:10"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-09-09</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/FE%E6%A1%86%E6%9E%B6/">FE框架</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/FE%E6%A1%86%E6%9E%B6/React/">React</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/FE%E6%A1%86%E6%9E%B6/React/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Redux源码解析</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">3.4k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 14 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><strong class='old-blog'>Redux源码解析</strong></p>
<p>[[toc]]</p>
<h3 id="Redux三大原则"><a href="#Redux三大原则" class="headerlink" title="Redux三大原则"></a>Redux三大原则</h3><ul>
<li><strong>唯一数据源</strong><ul>
<li>整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中</li>
</ul>
</li>
<li><strong>保持只读状态</strong><ul>
<li>state是只读的，唯一改变state的方法就是触发action，action是一个用于描述以发生时间的普通对象<ul>
<li>store里面保存的都是普通Object，可直接修改他的值，官方文档说的“只有通过action才能修改状态”更多的是一种规则/约束，目的是使数据的流动过程变得清晰且可预测，而不是说通过其他方式（比如直接修改对象属性）会报错。当然这种方式是 <strong>无法触发props更新的</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>数据改变只能通过纯函数来执行</strong><ul>
<li>使用纯函数来执行修改，为了描述action如何改变state的，你需要编写reducers</li>
</ul>
</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H70eea0923b414f78a4a4d805e374147aX.gif" alt=""></p>
<h3 id="Action-amp-store-dispatch"><a href="#Action-amp-store-dispatch" class="headerlink" title="Action &amp; store.dispatch( )"></a>Action &amp; store.dispatch( )</h3><p><code>Action</code>是把数据从应用传到store的有效载荷。它是store数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。</p>
<ul>
<li>首先用户请求或者页面默认请求执行一个函数 例：myBoardList</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBoardList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dispatch,getState</span>)</span>&#123;<span class="comment">//这里是中间件穿进去的</span></span><br><span class="line">    request.get(<span class="string">`<span class="subst">$&#123;route.myBoard&#125;</span><span class="subst">$&#123;getState().loginReducer.user_id&#125;</span>`</span>).then(<span class="function">(<span class="params">&#123;data&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> my_list = data; <span class="comment">//这里一整理数据格式</span></span><br><span class="line">        <span class="comment">//Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置</span></span><br><span class="line">        <span class="keyword">const</span> action =&#123;</span><br><span class="line">              type:TYPES.BOARD_MY,</span><br><span class="line">              payload:&#123;</span><br><span class="line">                 my_list</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//store.dispatch()是页面发出Action的唯一方法。</span></span><br><span class="line">        dispatch(action)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面使用</span></span><br><span class="line"><span class="keyword">this</span>.props.dispatch(myBoardList())</span><br></pre></td></tr></table></figure>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p><code>Reducers</code>指定了应用状态的变化<code>如何响应</code>actions并发送到store的，actions只是描述了有事情发生了这一事实，并没有描述应用如何更新state。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> TYPES <span class="keyword">from</span> <span class="string">'actionTypes'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  my_list:[]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> tabBarReducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">     <span class="keyword">case</span> TYPES.BOARD_MY :</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, action.payload)</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> tabBarReducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer = combineReducers(&#123; <span class="comment">//合并所有的reducer导出，然后当做createStore的参数</span></span><br><span class="line">   tabBarReducer,</span><br><span class="line">   ....</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p><code>store</code>就是redux里面的一个容器，store本质上是一个状态树，保存了所有对象的状态。任何UI组件都可以直接从store访问特定对象的状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> reduxThunk <span class="keyword">from</span> <span class="string">"redux-thunk"</span></span><br><span class="line"><span class="keyword">import</span> reduxPromise <span class="keyword">from</span> <span class="string">"redux-promise"</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore, applyMiddleware&#125; <span class="keyword">from</span> <span class="string">"redux"</span></span><br><span class="line"><span class="keyword">import</span> &#123; composeWithDevTools &#125; <span class="keyword">from</span> <span class="string">'redux-devtools-extension'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">"./reducer"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = composeWithDevTools(createStore(reducer,applyMiddleware(reduxThunk, reduxPromise)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<h3 id="Redux源码"><a href="#Redux源码" class="headerlink" title="Redux源码 *"></a>Redux源码 *</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let combineReducers&#x3D;(renducers)&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;传入一个renducers管理组，返回的是一个renducer</span><br><span class="line">    return function(state&#x3D;&#123;&#125;,action&#x3D;&#123;&#125;)&#123;</span><br><span class="line">        let newState&#x3D;&#123;&#125;;</span><br><span class="line">        for(var attr in renducers)&#123;</span><br><span class="line">            newState[attr]&#x3D;renducers[attr](state[attr],action)</span><br><span class="line">        &#125;</span><br><span class="line">        return newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let createStore &#x3D; (reducer) &#x3D;&gt; &#123;</span><br><span class="line">    let state;</span><br><span class="line">    &#x2F;&#x2F;获取状态对象</span><br><span class="line">    &#x2F;&#x2F;存放所有的监听函数</span><br><span class="line">    let listeners &#x3D; [];</span><br><span class="line">    let getState &#x3D; () &#x3D;&gt; state;</span><br><span class="line">    &#x2F;&#x2F;提供一个方法供外部调用派发action</span><br><span class="line">    let dispath &#x3D; (action) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;调用管理员reducer得到新的state</span><br><span class="line">        state &#x3D; reducer(state, action);</span><br><span class="line">        &#x2F;&#x2F;执行所有的监听函数，相当于发布</span><br><span class="line">        listeners.forEach((l) &#x3D;&gt; l())</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;订阅状态变化事件，当状态改变发生之后执行监听函数</span><br><span class="line">    let subscribe &#x3D; (listener) &#x3D;&gt; &#123;</span><br><span class="line">        listeners.push(listener);</span><br><span class="line">       &#x2F;&#x2F;store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</span><br><span class="line">        return function unsubscribe() &#123;</span><br><span class="line">             const index &#x3D; listeners.indexOf(listener)</span><br><span class="line">             listeners.splice(index, 1)</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dispath();</span><br><span class="line">    return &#123;</span><br><span class="line">        getState,  &#x2F;&#x2F;获取当前的容器的状态</span><br><span class="line">        subscribe, &#x2F;&#x2F;当你对数据库发出一个指令，而且数据库根据这个指令已经计算得到新的状态以后需要执行的回调函数</span><br><span class="line">        dispath,   &#x2F;&#x2F;发出一个Action，告诉数据库你要干嘛。数据库会根据当前的状态以及你的命令类型计算得到新的状态。计算完成以后，我们要执行subscribe添加的所有的回调函数.</span><br><span class="line">        replaceReducer &#x2F;&#x2F;用一个新的store替换掉我们当前的store用来计算我们的新的state。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const store &#x3D; createStore(reducer);</span><br><span class="line">store.getState(); &#x2F;&#x2F; 获取数据</span><br><span class="line">store.dispatch(&#123;type: &#39;ADD_TODO&#39;&#125;); &#x2F;&#x2F; 更新数据</span><br><span class="line">store.subscribe(() &#x3D;&gt;  document.querySelector(&#39;#counter&#39;).innerHTML &#x3D; store.getState()); &#x2F;&#x2F; 注册订阅函数</span><br></pre></td></tr></table></figure>

<p>我们可以在应用初始化的时候，创建一个<code>window.store = createStore(reducer)</code>，<br>然后在需要的地方通过<code>store.getState()去获取数据</code>，<br>通过<code>store.dispatch去更新数据</code>，<br>通过<code>store.subscribe去订阅数据变化然后进行setState</code>…如果很多地方都这样做一遍，实在是不堪其重，而且，还是没有避免掉全局变量的不优雅。所以就需要<strong>react-redux</strong>了</p>
<h3 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h3><h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h4><p>由于全局变量有诸多的缺点，所有就需要用到Provider优化</p>
<p><code>Provider</code>其实就只是一个外层容器，它的作用就是通过配合<code>connect</code>来达到跨层级传递数据。使用时只需将Provider定义为整个项目最外层的组件，并设置好store。<br>那么整个项目都可以直接获取这个store。它的原理其实是通过React中的Context来实现的。它的核心代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"><span class="keyword">import</span> &#123;ReactReduxContext&#125; <span class="keyword">from</span> <span class="string">'./Context'</span>   <span class="comment">//就是利用上下文来达到跨层级传递数据</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">const</span> &#123;store&#125; = props</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            storeState: store.getState(),</span><br><span class="line">            store</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">this</span>._isMounted = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">this</span>.subscribe()</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.unsubscribe) <span class="keyword">this</span>.unsubscribe()  <span class="comment">//取消订阅</span></span><br><span class="line">        <span class="keyword">this</span>._isMounted = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.props.store !== prevProps.store) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.unsubscribe) <span class="keyword">this</span>.unsubscribe()</span><br><span class="line">            <span class="keyword">this</span>.subscribe()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    subscribe() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;store&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="comment">//store.subscribe返回的是取消订阅的方法</span></span><br><span class="line">        <span class="comment">//Store 允许使用store.subscribe方法设置监听函数，每次dispatch后，执行完reducer改变新的store后，都会重新发布这个含函数</span></span><br><span class="line">        <span class="keyword">this</span>.unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> newStoreState = store.getState()</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>._isMounted) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.setState(<span class="function"><span class="params">providerState</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 如果值相同，则跳过不必要的状态更新</span></span><br><span class="line">                <span class="keyword">if</span> (providerState.storeState === newStoreState) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">storeState</span>: newStoreState&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 可能在呈现和装载之间调度了操作-处理那些</span></span><br><span class="line">        <span class="keyword">const</span> postMountStoreState = store.getState()</span><br><span class="line">        <span class="keyword">if</span> (postMountStoreState !== <span class="keyword">this</span>.state.storeState) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;<span class="attr">storeState</span>: postMountStoreState&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> Context = <span class="keyword">this</span>.props.context || ReactReduxContext</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Context.Provider value=&#123;<span class="keyword">this</span>.state&#125;&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">Provider.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">    store: PropTypes.shape(&#123;</span></span><br><span class="line"><span class="regexp">        subscribe: PropTypes.func.isRequired,</span></span><br><span class="line"><span class="regexp">        dispatch: PropTypes.func.isRequired,</span></span><br><span class="line"><span class="regexp">        getState: PropTypes.func.isRequired</span></span><br><span class="line"><span class="regexp">    &#125;),</span></span><br><span class="line"><span class="regexp">    context: PropTypes.object,</span></span><br><span class="line"><span class="regexp">    children: PropTypes.any</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Provider</span></span><br></pre></td></tr></table></figure>
<h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><p><code>connect</code>的作用是连接React组件与Store，它包在我们的容器组件的外一层，它接收上面Provider提供的store里面的<code>state</code>和<code>dispatch</code>，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件。</p>
<p>它共有四个参数 <strong>mapStateToProps, mapDispatchToProps, mergeProps以及options</strong>。</p>
<p><code>mapStateToProps</code> 的作用是将store里的state（数据源）绑定到指定组件的props中</p>
<p><code>mapDispatchToProps</code> 的作用是将store里的action（操作数据的方法）绑定到指定组件的props中</p>
<p>其实就是利用上下文获取所有的store,然后执行store.getState()保证能获取最新的数据，然后在利用mapStateToProps，mapDispatchToProps 把需要用到的解构出来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mapStateToProps = <span class="function">(<span class="params">&#123;loginReducer,loading&#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">    userInfo: &#123;...loginReducer, ...loading&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> mapDispatchToProps =  <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> actions = bindActionCreators(&#123;...globalActions&#125;, dispatch);</span><br><span class="line">   <span class="keyword">return</span> &#123;...actions&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapDispatchToProps)(Index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过props获取用户信息</span></span><br><span class="line"><span class="keyword">this</span>.props.userInfo</span><br></pre></td></tr></table></figure>

<p>connect部分源码</p>
<p>新版的太复杂，看下老版本的，便于理解</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> connect = <span class="function">(<span class="params">mapStateToProps, mapDispatchToProps</span>) =&gt;</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">      store: PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">      <span class="keyword">super</span>()</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      <span class="comment">//使用subscribe，会实时检测store的变化</span></span><br><span class="line">      <span class="keyword">this</span>.unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setProps())</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnMount () &#123;</span><br><span class="line">        <span class="keyword">this</span>.unsubscribe()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setProps () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      <span class="keyword">let</span> stateProps = mapStateToProps</span><br><span class="line">        ? mapStateToProps(store.storeState(), <span class="keyword">this</span>.props)</span><br><span class="line">        : &#123;&#125;; <span class="comment">// 不传为空</span></span><br><span class="line">        </span><br><span class="line">      <span class="keyword">let</span> dispatchProps = mapDispatchToProps</span><br><span class="line">        ? mapDispatchToProps(store.dispatch,<span class="keyword">this</span>.props)</span><br><span class="line">        : mapDispatchToProps(<span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123; dispatch &#125;)); <span class="comment">// 默认传进去dispatch</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//mapDispatchToProps里面还可能会有bindActionCreators这个方法；bindActionCreators的作用是将一个或多个action和dispatch组合起来生成</span></span><br><span class="line">        <span class="comment">//通过dispatch将action包裹起来，这样可以通过bindActionCreators创建的方法，直接调用dispatch(action)(隐式调用），相当于直接组合成</span></span><br><span class="line">        <span class="comment">//dispatch(&#123;type:type.ADD_ITEM, text&#125;) </span></span><br><span class="line">        <span class="comment">//export function whenMapDispatchToPropsIsObject(mapDispatchToProps) &#123;</span></span><br><span class="line">        <span class="comment">//    return wrapMapToPropsConstant(dispatch =&gt;</span></span><br><span class="line">        <span class="comment">//        bindActionCreators(mapDispatchToProps, dispatch)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          ...stateProps,</span><br><span class="line">          ...dispatchProps,</span><br><span class="line">          ...this.props</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.state</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Connect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><h4 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h4><p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;  <span class="comment">//判别action的类型，如果action是函数，就调用这个函数</span></span><br><span class="line">        <span class="comment">//发现实参为dispatch和getState，因此我们在定义action为thunk函数是，一般形参为dispatch和getState。</span></span><br><span class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk;</span><br></pre></td></tr></table></figure>
<p> 上面的dispatch其实是中间件执行之后通过其他方法把store自带的dispatch覆盖，<br> 所以我们平时使用的store.dispatch(action)其实就是中间件执行之后的dispatch,<br> 而这里的next其实是store自带的dispatch，<strong>虽然最终还是通过store自带的dispatch实现的，</strong><br> 但是调用的确是中间件的方法，虽然都叫做dispatch。</p>
<p><strong>使用方式</strong></p>
<p>可以传入对象或者函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBoardList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dispatch,getState</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">const</span> action =&#123;</span><br><span class="line">            type:TYPES.BOARD_MY,</span><br><span class="line">            payload:&#123;</span><br><span class="line">               my_list</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     dispatch(action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong></p>
<p>thunk的缺点也是很明显的，thunk<code>仅仅做了执行</code>这个函数，<code>并不在乎函数主体内是什么</code><br/><br>thunk使得redux可以接受函数作为action,这就会使得异步操作<code>太为分散</code>【往往需要promise或者async/wait的支持才可以】</p>
<p>action的形式不统一</p>
<h4 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h4><p><strong>流程:</strong></p>
<p>异步操作——&gt;Effect函数——&gt;纯文本对象——&gt;saga-middleware——&gt;执行异步操作</p>
<p><strong>配置sage</strong></p>
<p><strong>effect.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  * <span class="keyword">as</span> Api <span class="keyword">from</span> <span class="string">"../services"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; call, put, takeEvery &#125; <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 副作用处理 effects：</span></span><br><span class="line"><span class="comment"> *  用于异步处理请求</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> effects = &#123;</span><br><span class="line">  <span class="comment">// 获取话题列表</span></span><br><span class="line">  *fetchTopics(&#123; payload &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">yield</span> call(Api.topics, payload);</span><br><span class="line">    <span class="keyword">if</span> (res.success) &#123;</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">'topics'</span>,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          topics: res.data,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  异步 action 监听： 所有的effect整合到了一块</span></span><br><span class="line"><span class="comment"> *  dispatch 对应的action时，调用对应的异步处理方法</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">watcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">'fetchTopics'</span>, effects.fetchTopics);</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">'aaa'</span>, effects.aaa);</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">'bbb'</span>, effects.bbb);</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>reducers.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个reducer 需要用到combineReducers合并</span></span><br><span class="line"><span class="comment">// 初始化State</span></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  topics: [],</span><br><span class="line">  topic: &#123;&#125;,</span><br><span class="line">  collected: [],</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纯函数 reducer：</span></span><br><span class="line"><span class="comment"> * 传入旧 state 和 action，从而返回一个信息state</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reducers = <span class="function">(<span class="params">state = initState, &#123; type, payload &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'topics'</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        topics: payload.topics,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的写法和redux-thunk中reducers写法一样</p>
<p><strong>index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统一导出reducers和effects</span></span><br><span class="line"><span class="keyword">import</span> &#123; reducers &#125; <span class="keyword">from</span> <span class="string">'./reducers'</span>; </span><br><span class="line"><span class="keyword">import</span> &#123; watcher &#125; <span class="keyword">from</span> <span class="string">"./effects"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  reducers,</span><br><span class="line">  watcher,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123; Provider &#125; from &#39;react-redux&#39;;</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &#39;redux&#39;;</span><br><span class="line">import createSagaMiddleware from &#39;redux-saga&#39;;</span><br><span class="line">import &#123;reducers,watcher&#125; from &#39;.&#x2F;redux&#39;;</span><br><span class="line"></span><br><span class="line">const sagaMiddleware &#x3D; createSagaMiddleware();</span><br><span class="line">const store &#x3D; createStore(</span><br><span class="line">    reducers,  &#x2F;&#x2F;这里是所有的reducer</span><br><span class="line">  applyMiddleware(sagaMiddleware), &#x2F;&#x2F;执行saga的中间件</span><br><span class="line">);</span><br><span class="line">sagaMiddleware.run(watcher); </span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">  &lt;&#x2F;Provider&gt;,</span><br><span class="line">  document.getElementById(&#39;app&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里的sagaMiddleware.run() 方法，主要是启动saga，<strong>用于监听actions请求</strong>，待匹配到定义的effects type时，转发调用effects方法，从而处理异步请求，然后再调用redux中的dispatch来触发新的action，来更新store！</p>
<p><strong>页面使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@connect(<span class="function">(<span class="params">&#123; topics, loading &#125;</span>) =&gt;</span> (&#123;  <span class="comment">//type的值</span></span><br><span class="line">  topics,</span><br><span class="line">  loading,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.props.dispatch(&#123;</span><br><span class="line">    type: <span class="string">'fetchTopics'</span>, <span class="comment">//effect的函数</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>处理步骤：</strong></p>
<ol>
<li><p>用户dispatch执行一个异步函数</p>
</li>
<li><p>调用redux-saga/effects中的方法 call，访问接口获取数据；</p>
</li>
<li><p>接口访问成功，使用redux-saga/effects中的方法put，发起action，这里的put方法和dispatch一样，都是用于发起action；</p>
</li>
<li><p>put发起action后，redux的reducers会收到action，从而更新state。</p>
</li>
</ol>
<p>集中处理了所有的异步操作，异步接口部分一目了然</p>
<p>异步操作的流程是可以控制的，可以随时取消相应的异步操作。</p>
<h3 id="redux-middleware-源码分析"><a href="#redux-middleware-源码分析" class="headerlink" title="redux middleware 源码分析"></a>redux middleware 源码分析</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以 redux-thunk、logger 中间件为例介绍中间件的使用</span></span><br><span class="line"><span class="keyword">const</span> enhancer = applyMiddleware(thunk, logger),  </span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, enhancer)</span><br></pre></td></tr></table></figure>
<p><strong>applyMiddleware 调用入口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过下面代码可以发现，如果 createStore 传入 2 个参数，第二个参数相当于就是 enhancer</span><br><span class="line">  if (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">    enhancer &#x3D; preloadedState</span><br><span class="line">    preloadedState &#x3D; undefined</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof enhancer !&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">    return enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述 createStore 源码发现，applyMiddleware 会进行 <code>applyMiddleware(thunk, logger)(createStore)(reducer, preloadedState)</code> 的调用。</p>
<p><strong>applyMiddleware 源码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function applyMiddleware(...middlewares) &#123;</span><br><span class="line">    &#x2F;&#x2F; 柯理化  ()&#x3D;&gt;()&#x3D;&gt;&#123;&#125;</span><br><span class="line">  return createStore &#x3D;&gt; (...args) &#x3D;&gt; &#123;</span><br><span class="line">    const store &#x3D; createStore(...args)  &#x2F;&#x2F;store  &#x3D;  &#123;getState,dispatch.....&#125;</span><br><span class="line">    let dispatch &#x3D; store.dispatch</span><br><span class="line">    let chain &#x3D; []</span><br><span class="line"></span><br><span class="line">    const middlewareAPI &#x3D; &#123;</span><br><span class="line">      getState: store.getState,                &#x2F;&#x2F; 调用 redux 原生方法，获取状态</span><br><span class="line">      dispatch: (...args) &#x3D;&gt; dispatch(...args) &#x2F;&#x2F; 调用 redux 原生 dispatch 方法</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 串行 middleware</span><br><span class="line">    chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI)) &#x2F;&#x2F; thunk的参数参数正是 (&#123; dispatch, getState &#125;)</span><br><span class="line">    dispatch &#x3D; compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch &#x2F;&#x2F; 返回加工过的 dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  &#x2F;&#x2F;然后 &lt;Provider store&#x3D;&#123;store&#125; &#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dispatch 是如何被加工的</strong></p>
<p>compose 的源码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; dispatch, getState &#125;) =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 经 compose 源码分析，此处 next 为 Store.dispatch</span></span><br><span class="line">   <span class="comment">// action  为 this.props.dispatch(`action`)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action(dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其 middleware 的内部串行调用方式如下，从而完成了 dispatch 功能的增强(支持如 this.props.dispatch(action) 的调用以及日志功能)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">action =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action(dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> store.dispatch(action)</span><br><span class="line">  &#125;)(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>applyMiddleware的核心就是 执行的createStore,在dispatch里面添加一些方法,最后返回加工过的 dispatch,这个dispatch 有中间价的一些处理</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:feng960106@163.com">hfzvictory</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://file.jing999.cn/2019/02/17/workspace/Frame/react/react-redux/">http://file.jing999.cn/2019/02/17/workspace/Frame/react/react-redux/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://file.jing999.cn" target="_blank">hfzvictory</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.png" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/03/15/workspace/Server/node/base/"><img class="prev_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">NodeJs的原生方法</div></div></a></div><div class="next-post pull_right"><a href="/2019/02/15/workspace/Server/node/node-1/"><img class="next_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Koa2</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: '37fl65GwM0Ub4TbovXtyyFl7-gzGzoHsz',
  appKey: 'ASnnLHANk3heLWLCBK6zbfiw',
  notify: false,
  verify: false,
  placeholder: '输入评论...',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '20',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2021 By hfzvictory</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>京ICP备18059340号-1</span></a></div></div></footer><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.5" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script></body></html>