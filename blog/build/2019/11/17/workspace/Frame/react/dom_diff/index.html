<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>VirtualDOM | hfzvictory</title><meta name="description" content="VirtualDOM [[toc]] React 的核心思想 给我一个数据，我根据这个数据生成一个全新的Virtual DOM，然后跟我上一次生成的Virtual DOM去 diff，得到一个Patch，然后把这个Patch打到浏览器的DOM上去。完事,并且这里的patch显然不是完整的虚拟DOM，而是新的虚拟DOM和上一次的虚拟DOM经过diff后的差异化的部分。 JSX和createEleme"><meta name="keywords" content="和振峰博客，web前端，node全栈工程师，hzfvictory"><meta name="author" content="hfzvictory,feng960106@163.com"><meta name="copyright" content="hfzvictory"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="VirtualDOM"><meta name="twitter:description" content="VirtualDOM [[toc]] React 的核心思想 给我一个数据，我根据这个数据生成一个全新的Virtual DOM，然后跟我上一次生成的Virtual DOM去 diff，得到一个Patch，然后把这个Patch打到浏览器的DOM上去。完事,并且这里的patch显然不是完整的虚拟DOM，而是新的虚拟DOM和上一次的虚拟DOM经过diff后的差异化的部分。 JSX和createEleme"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="og:type" content="article"><meta property="og:title" content="VirtualDOM"><meta property="og:url" content="http://file.jing999.cn/2019/11/17/workspace/Frame/react/dom_diff/"><meta property="og:site_name" content="hfzvictory"><meta property="og:description" content="VirtualDOM [[toc]] React 的核心思想 给我一个数据，我根据这个数据生成一个全新的Virtual DOM，然后跟我上一次生成的Virtual DOM去 diff，得到一个Patch，然后把这个Patch打到浏览器的DOM上去。完事,并且这里的patch显然不是完整的虚拟DOM，而是新的虚拟DOM和上一次的虚拟DOM经过diff后的差异化的部分。 JSX和createEleme"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="article:published_time" content="2019-11-17T00:00:00.000Z"><meta property="article:modified_time" content="2020-06-04T08:45:18.102Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://file.jing999.cn/2019/11/17/workspace/Frame/react/dom_diff/"><link rel="prev" title="react事件委托机制" href="http://file.jing999.cn/2019/11/17/workspace/Frame/react/event/"><link rel="next" title="RN IOS环境搭建" href="http://file.jing999.cn/2019/11/17/workspace/Frame/react-native/base/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: hfzvictory","link":"链接: ","source":"来源: hfzvictory","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ae01.alicdn.com/kf/H9ae3136bf5e440239fa2c611632fbd09H.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">104</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">99</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/todos"><i class="fa-fw fa fa-battery-three-quarters"></i><span> Todos</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bicycle" aria-hidden="true"></i><span> 喜好</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSX和createElement"><span class="toc-number">1.</span> <span class="toc-text">JSX和createElement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Virtual-DOM"><span class="toc-number">2.</span> <span class="toc-text">Virtual DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Virtual-DOM的存在的意义"><span class="toc-number">2.1.</span> <span class="toc-text">Virtual DOM的存在的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Virtual-DOM-基本步骤"><span class="toc-number">2.2.</span> <span class="toc-text">Virtual DOM 基本步骤:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单实现-vdom"><span class="toc-number">2.3.</span> <span class="toc-text">简单实现 vdom</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diff"><span class="toc-number">3.</span> <span class="toc-text">diff</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#传统diff-对比-react-diff"><span class="toc-number">3.1.</span> <span class="toc-text">传统diff 对比 react diff</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-diff-三大策略"><span class="toc-number">3.2.</span> <span class="toc-text">React diff 三大策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟DOM树分层比较（tree-diff）"><span class="toc-number">3.3.</span> <span class="toc-text">虚拟DOM树分层比较（tree diff）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组件间的比较（component-diff）"><span class="toc-number">3.4.</span> <span class="toc-text">组件间的比较（component diff）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#元素间的比较（element-diff）"><span class="toc-number">3.5.</span> <span class="toc-text">元素间的比较（element diff）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Key的作用"><span class="toc-number">3.6.</span> <span class="toc-text">Key的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三句箴言"><span class="toc-number">3.7.</span> <span class="toc-text">三句箴言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么不推荐使用index作为Key"><span class="toc-number">3.8.</span> <span class="toc-text">为什么不推荐使用index作为Key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#diff-源码"><span class="toc-number">3.9.</span> <span class="toc-text">diff 源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patch"><span class="toc-number">4.</span> <span class="toc-text">patch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考文档"><span class="toc-number">6.</span> <span class="toc-text">参考文档</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div class="post-bg" id="nav" style="background-image: url(https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">hfzvictory</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/todos"><i class="fa-fw fa fa-battery-three-quarters"></i><span> Todos</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bicycle" aria-hidden="true"></i><span> 喜好</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">VirtualDOM</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-11-17 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-17</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-04 08:45:18"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-04</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/FE%E6%A1%86%E6%9E%B6/">FE框架</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/FE%E6%A1%86%E6%9E%B6/React/">React</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/FE%E6%A1%86%E6%9E%B6/React/VirtualDOM/">VirtualDOM</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 18 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><strong class='old-blog'>VirtualDOM</strong></p>
<p>[[toc]]</p>
<p><strong>React 的核心思想</strong></p>
<p>给我一个数据，我根据这个数据生成一个全新的<code>Virtual DOM</code>，然后跟我上一次生成的Virtual DOM去 <code>diff</code>，得到一个<code>Patch</code>，<br>然后把这个Patch打到浏览器的DOM上去。完事,并且这里的patch显然<code>不是完整的虚拟DOM</code>，<br>而是新的虚拟DOM和上一次的虚拟DOM经过<code>diff</code>后的<code>差异化</code>的部分。</p>
<h3 id="JSX和createElement"><a href="#JSX和createElement" class="headerlink" title="JSX和createElement"></a>JSX和createElement</h3><p>我们在实现一个React组件时可以选择两种编码方式，第一种是使用<code>JSX</code>编写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello hzf<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种是直接使用<code>React.createElement</code>编写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="string">'div'</span>, <span class="literal">null</span>, <span class="string">`Hello hzf`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，上面两种写法是等价的，<code>JSX只是为 React.createElement(component, props, ...children)</code>方法提供的语法糖。也就是说所有的JSX代码最后都会转换成<code>React.createElement(...)</code>，<code>Babel</code>帮助我们完成了这个转换的过程。</p>
<p><strong>注意</strong>：babel在编译时会判断JSX中组件的首字母，当<code>首字母为小写时</code>，其被认定为<code>原生DOM标签</code>，createElement的第一个变量被编译为字符串；当<code>首字母为大写时</code>，其被认定为自定义<code>组件</code>，createElement的第一个变量被<code>编译为对象</code>,所以组件首字母要大写</p>
<h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/%E8%99%9A%E6%8B%9Fdom.png" alt=""></p>
<p>冷静对待虚拟dom，他不是一定能够提升页面的性能，如果是首次渲染，Vitrua lDom不具有任何优势，甚至它要进行更多的计算，消耗更多的内存，是因为有diff他才会展现它的优势</p>
<h4 id="Virtual-DOM的存在的意义"><a href="#Virtual-DOM的存在的意义" class="headerlink" title="Virtual DOM的存在的意义"></a>Virtual DOM的存在的意义</h4><ul>
<li>Vitrua Dom为React带来了跨平台渲染的能力。以React Native为例子;React根据Vitrual Dom画出相应平台的ui层，只不过不同平台画的姿势不同而已</li>
<li>服务端渲染</li>
<li>函数式编程</li>
</ul>
<h4 id="Virtual-DOM-基本步骤"><a href="#Virtual-DOM-基本步骤" class="headerlink" title="Virtual DOM 基本步骤:"></a>Virtual DOM 基本步骤:</h4><ol>
<li>用<code>js对象来表示DOM树的结构</code>； 然后用这个树构建一个真正的DOM树，插入到文档中。</li>
<li>当状态变更的时候，<code>重新构造一个新的对象</code>，然后用这个新的树和旧的树作对比，记录<code>两个树的差异</code>。 </li>
<li>把2所记录的差异应用在步骤1所构建的真正的DOM树上，视图就更新了。</li>
</ol>
<p>看看虚拟DOM的真实模样</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H66008463790e4f8d9feaa1f12800ee9cm.png" alt=""></p>
<ul>
<li><code>type</code>：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或class）</li>
<li><code>key</code>：组件的唯一标识，用于Diff算法</li>
<li><code>ref</code>：用于访问原生dom节点</li>
<li><code>props</code>：传入组件的props</li>
<li><code>owner</code>：当前正在构建的Component所属的Component</li>
<li><code>$$typeof</code>：防止xss攻击，如果你的服务器有一个漏洞，允许用户存储任意JSON对象， 而客户端代码需要一个字符串，这可能为你的应用程序带来风险。JSON中不能存储Symbol类型的变量，而React渲染时会把没有<code>$$typeof</code>标识的组件过滤掉。</li>
<li><code>self</code>指定当前位于哪个组件实例。</li>
<li><code>_source</code>指定调试代码来自的文件(fileName)和代码行数(lineNumber)。</li>
</ul>
<h4 id="简单实现-vdom"><a href="#简单实现-vdom" class="headerlink" title="简单实现 vdom"></a>简单实现 vdom</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./createElement.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">React</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建虚拟dom用的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>type 标签的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>options props</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param  <span class="type">&#123;...any&#125;</span> </span>arg 子代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> createElement(type, options, ...arg) &#123;</span><br><span class="line">        <span class="comment">// options肯定是一个对象，不管传还是不传</span></span><br><span class="line">        options = options || <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//arg是存储上下的参数，即使没有其他的参数，arg也是一个空数组，</span></span><br><span class="line">        <span class="keyword">let</span> obj = &#123;</span><br><span class="line">            type,</span><br><span class="line">            key: <span class="literal">null</span>,</span><br><span class="line">            ref: <span class="literal">null</span>,</span><br><span class="line">            props: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//key ref</span></span><br><span class="line">        [<span class="string">"key"</span>, <span class="string">"ref"</span>].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (item <span class="keyword">in</span> options) &#123;</span><br><span class="line">                obj[item] = options[item];</span><br><span class="line">                <span class="keyword">delete</span> options[item]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//处理props</span></span><br><span class="line">        obj.props = &#123; ...options &#125;;</span><br><span class="line">        <span class="comment">//因为我这用的es6语法，下面的判断没什么作用，用es5的话需要加上</span></span><br><span class="line">        <span class="keyword">let</span> len = arg.length;</span><br><span class="line">        <span class="keyword">switch</span> (len) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                obj.props.children = arg[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 拥有多个子节点</span></span><br><span class="line">                obj.props.children = arg</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactDom</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将虚拟节点转换成真实的dom节点，最后插入到container容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>objJSX 编译后的虚拟节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>container 要渲染到那个容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>callback 回调函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> render(objJSX, container, callback) &#123;</span><br><span class="line">        <span class="keyword">let</span> newEle = ReactDom.createDomElementFromVnode(objJSX)</span><br><span class="line">        container.appendChild(newEle);</span><br><span class="line">        callback &amp;&amp; callback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> createDomElementFromVnode(objJSX)&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; type, props &#125; = objJSX;</span><br><span class="line">        objJSX.newEle = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">        <span class="comment">//设置属性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!props.hasOwnProperty(key)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//className</span></span><br><span class="line">            <span class="keyword">if</span> (key === <span class="string">"className"</span>) &#123;</span><br><span class="line">                objJSX.newEle.setAttribute(<span class="string">"class"</span>, props[<span class="string">"className"</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//style设置</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"style"</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props[<span class="string">'style'</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (props[<span class="string">"style"</span>].hasOwnProperty(key)) &#123;</span><br><span class="line">                        objJSX.newEle[<span class="string">"style"</span>][key] = props[<span class="string">"style"</span>][key]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//children</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"children"</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> children = props[<span class="string">'children'</span>];</span><br><span class="line">                <span class="keyword">if</span> (children <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">                    children.forEach(<span class="function"><span class="params">itemChildren</span> =&gt;</span> &#123;</span><br><span class="line">                        ReactDom.handChildren(itemChildren, objJSX.newEle)</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ReactDom.handChildren(children, objJSX.newEle);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                objJSX.newEle.setAttribute(key, props[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objJSX.newEle</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> handChildren(children, newEle) &#123;</span><br><span class="line">        <span class="comment">//只有一个子节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> children === <span class="string">"object"</span>) &#123;</span><br><span class="line">            <span class="comment">//当前唯一的新对象</span></span><br><span class="line">            ReactDom.render(children, newEle)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newEle.appendChild(<span class="built_in">document</span>.createTextNode(children))</span><br><span class="line">            <span class="built_in">console</span>.log(newEle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> styleObj = &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125;;</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">    React.createElement(<span class="string">"div"</span>, &#123;</span><br><span class="line">        id: <span class="string">"box"</span>,</span><br><span class="line">        className: <span class="string">"box"</span>,</span><br><span class="line">        style: styleObj</span><br><span class="line">      &#125;, React.createElement(<span class="string">"h2"</span>, &#123;</span><br><span class="line">        className: <span class="string">"title"</span></span><br><span class="line">      &#125;, <span class="string">"\u8FD9\u91CC\u662F\u5934\u90E8"</span>), React.createElement(<span class="string">"ul"</span>, &#123;</span><br><span class="line">        className: <span class="string">"newsItem"</span></span><br><span class="line">      &#125;, React.createElement(<span class="string">"li"</span>, &#123;</span><br><span class="line">        key: <span class="string">"1"</span>,</span><br><span class="line">        style: &#123;</span><br><span class="line">          color: <span class="string">"#ccc"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="string">"\u54C8\u54C8\u54C8"</span>), React.createElement(<span class="string">"li"</span>, &#123;</span><br><span class="line">        key: <span class="string">"2"</span></span><br><span class="line">      &#125;, <span class="string">"\u5475\u5475\u5475"</span>)), <span class="string">"1221"</span>), </span><br><span class="line">    <span class="built_in">window</span>.app</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然后根据不同的情况，来进行树上节点的增删改的操作。这个过程是分为diff和patch：</p>
<ul>
<li><strong>diff</strong>：递归对比两棵 VDom 树的、对应位置的节点差异</li>
<li><strong>patch</strong>：根据不同的差异，进行节点的更新</li>
</ul>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>其实React的 virtual dom的性能好也离不开它本身特殊的diff算法。传统的diff算法时间复杂度达到O(n3)，而react的diff算法时间复杂度只是o(n)，react的diff能减少到o(n)依靠的是react diff的三大策略。</p>
<h4 id="传统diff-对比-react-diff"><a href="#传统diff-对比-react-diff" class="headerlink" title="传统diff 对比 react diff"></a>传统diff 对比 react diff</h4><p>传统的diff算法追求的是“<code>完全</code>”以及“<code>最小</code>”，而react diff则是放弃了这两种追求：<br>在传统的diff算法下，对比前后两个节点，<code>如果发现节点改变了，会继续去比较节点的子节点，一层一层去对比</code>。就这样循环递归去进行对比，复杂度就达到了O(n3)，n是树的节点数，想象一下如果这棵树有1000个节点，我们得执行上十亿次比较，这种量级的对比次数，时间基本要用秒来做计数单位了。</p>
<h4 id="React-diff-三大策略"><a href="#React-diff-三大策略" class="headerlink" title="React diff 三大策略"></a>React diff 三大策略</h4><ul>
<li><strong>tree diff</strong>：Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。<code>（DOM结构发生改变-----直接卸载并重新creat）</code></li>
<li><strong>component diff</strong>：组件的DOM结构一样—–不会卸载,但是会update</li>
<li><strong>element diff</strong>：所有同一层级的子节点.他们都可以通过key来区分—–同时遵循1.2两点</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H9b1d122f787048f7afc393265e732d28D.png" alt=""></p>
<h4 id="虚拟DOM树分层比较（tree-diff）"><a href="#虚拟DOM树分层比较（tree-diff）" class="headerlink" title="虚拟DOM树分层比较（tree diff）"></a>虚拟DOM树分层比较（<code>tree diff</code>）</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H087b9d785877406b94078d9b6a07c15av.png" alt=""></p>
<p>上图中，<strong>div只会和同一层级的div对比，第二层级的只会和第二层级对比。 这样算法复杂度就可以达到O(n)</strong>。</p>
<p>但是如果DOM节点出现了跨层级操作，diff会如何处理？</p>
<p>React是不会机智的判断出子树仅仅是发生了移动，而是<strong>会直接销毁</strong>，并重新创建这个子树，然后再挂在到目标DOM上;<br/><br>实际上，React官方也并不推荐我们做出跨层级的骚操作。所以我们可以从中悟出一个道理：就是我们自己在实现组件的时候，一个稳定的DOM结构是有助于我们的性能提升的。</p>
<h4 id="组件间的比较（component-diff）"><a href="#组件间的比较（component-diff）" class="headerlink" title="组件间的比较（component diff）"></a>组件间的比较（<code>component diff</code>）</h4><p>核心的策略还是看结构是否发生改变。React是基于组件构建应用的，对于组件间的比较所采用的策略也是非常简洁和高效的。</p>
<p><strong>如果是同一个类型的组件</strong>，则按照原策略进行Virtual DOM比较。<br/><br><strong>如果不是同一类型的组件</strong>，则将其判断为dirty component，从而替换整个组价下的所有子节点。<br/><br><strong>如果是同一个类型的组件，有可能经过一轮Virtual DOM比较下来，并没有发生变化</strong>。如果我们能够提前确切知道这一点，那么就可以省下大量的diff运算时间。因此，React允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对比自定义组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffComponent</span>(<span class="params">oldNode, newNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldNode._component &amp;&amp; (oldNode._component.constructor !== newNode.nodeName)) &#123; <span class="comment">// 如果新老组件不同, 则直接将新组件替换老组件</span></span><br><span class="line">    <span class="keyword">const</span> newDom = vdomToDom(newNode)</span><br><span class="line">    oldNode._component.parentNode.insertBefore(newDom, oldNode._component)</span><br><span class="line">    oldNode._component.parentNode.removeChild(oldNode._component)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setProps(oldNode._component, newNode.attributes) <span class="comment">// 如果新老组件相同, 则将新组件的 props 赋到老组件上</span></span><br><span class="line">    renderComponent(oldNode._component)              <span class="comment">// 对获得新 props 前后的老组件做 diff 比较（renderComponent 中调用了 diff）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="元素间的比较（element-diff）"><a href="#元素间的比较（element-diff）" class="headerlink" title="元素间的比较（element diff）"></a>元素间的比较（<code>element diff</code>）</h4><p>当节点处于同一层级的时候，react diff 提供了三种节点操作：<strong>插入、删除、移动</strong>。</p>
<p><span style='display: block;text-align: left;'> 操作</span>|<span style='display: block;text-align: left;'> 描述</span>|<br>–|:–:|:–:|–|<br>插入|新节点不存在于老集合当中，即全新的节点，就会执行插入操作|<br>移动|新节点在老集合中存在，并且只做了位置上的更新，就会复用之前的节点，做移动操作（依赖于Key）|<br>删除|新节点在老集合中存在，但节点做出了更改不能直接复用，做出删除操作|</p>
<h4 id="Key的作用"><a href="#Key的作用" class="headerlink" title="Key的作用"></a>Key的作用</h4><p><strong>react利用key来识别组件，它是一种身份标识标识，就像我们的身份证用来辨识一个人一样</strong>。每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。</p>
<p><strong>key的使用场景</strong></p>
<ul>
<li>数组动态创建的子组件</li>
<li>为一个有复杂繁琐逻辑的组件添加key后，后续操作可以改变该组件的key属性值，从而达到先销毁之前的组件，再重新创建该组件。</li>
</ul>
<p>我们在循环渲染列表时候(map)时候忘记标记key值报的警告,既然是警告,就说明即使没有key的情况下也不会影响程序执行的正确性,其实这个key的存在只会<code>影响diff算法的复杂度</code>(不是一定会提高性能),也就是说你不加上Key就会暴力渲染，加了Key之后，React就可以做出移动的操作了，看例子：</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H1f3780ed47c947c8b8b9c9a5092a06507.png" alt=""></p>
<p>每个节点都加上了唯一的key值，通过这个<strong>Key值发现新老集合里面其实全部都是相同的元素</strong>，只不过位置发生了改变。因此就无需进行节点的插入、删除等操作了，只需要将老集合当中节点的位置进行移动就可以了。React给出的diff结果为：<code>B、D不做操作，A、C进行移动操作</code>。react是如何判断谁该移动，谁该不动的呢？</p>
<p>react会去循环整个新的集合：</p>
<p>① 从新集合中取到<code>B</code>，然后去旧集合中判断是否存在相同的<code>B</code>，确认<code>B</code>存在后，再去判断是否要移动：<br><code>B</code>在旧集合中的<code>index = 1</code>，有一个游标叫做<code>lastindex</code>。默认<code>lastindex = 0</code>，然后会把旧集合的<code>index和游标作</code>对比来判断是否需要移动，如果<strong>index &lt; lastindex ，那么就做移动操作</strong>，在这里<code>B的index = 1</code>，不满足于 <code>index &lt; lastindex</code>,所以就不做移动操作，然后游标lastindex更新，<code>取(index, lastindex) 的较大值</code>，这里就是<code>lastindex = 1</code></p>
<p>② 然后遍历到<code>A</code>，<code>A</code>在老集合中的<code>index = 0</code>，此时的游标<code>lastindex = 1</code>，满足<code>index &lt; lastinde</code>x，所以对A需要移动到对应的位置，此时<code>lastindex = max(index, lastindex) = 1</code></p>
<p>③ 然后遍历到<code>D</code>，<code>D</code>在老集合中的<code>index = 3</code>，此时游标<code>lastindex = 1</code>，不满足<code>index &lt; lastindex</code>，所以D保持不动。<code>lastindex = max(index, lastindex) = 3</code></p>
<p>④ 然后遍历到<code>C</code>，<code>C</code>在老集合中的<code>index = 2</code>，此时游标<code>lastindex = 3</code>，满足 <code>index &lt; lastindex</code>，所以C移动到对应位置。C之后没有节点了，diff就结束了</p>
<p>以上主要分析新老集合中<code>节点相同但位置不同</code>的情景，仅对节点进行位置移动的情况，如果新集合中有新加入的节点且老集合存在需要删除的节点，那么 React diff 又是如何对比运作的呢？</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Haafdd54eefeb47e1ad5fbb10e7f8ba9bE.png" alt=""></p>
<p>和第一种情景基本是一致的，react还是去循环整个新的集合：<br>① 不赘述了，和上面的第一步是一样的，<code>B不做移动，lastindex = 1</code></p>
<p>② 新集合取得<code>E</code>，发现旧集合中不存在，则创建E并放在新集合对应的位置，<code>lastindex = 1</code></p>
<p>③ 遍历到<code>C</code>，不满足<code>index &lt; lastindex</code>，<code>C</code>不动，<code>lastindex = 2</code></p>
<p>④ 遍历到<code>A</code>，满足<code>index &lt; lastindex</code>，<code>A</code>移动到对应位置，<code>lastindex = 2</code></p>
<p>⑤ 当完成新集合中所有节点 <code>diff</code> 时，最后还需要对老集合进行循环遍历，判断是否存在新集合中没有但老集合中仍存在的节点，发现存在这样的节点 <code>D</code>，因此<code>删除节点 D</code>，到此 diff 全部完成</p>
<p>但是 react diff也存在一些问题，和需要优化的地方，看下面的例子：</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hc94d1ce042be45a5b6e694b0b034817cU.png" alt=""></p>
<p>在上面的这个例子，<strong>A、B、C、D</strong>都没有变化，仅仅是<code>D</code>的位置发生了改变。看上面的图我们就知道react并没有把D的位置移动到头部，而是把 <strong>A、B、C</strong>分别移动到<code>D</code>的后面了，通过前面的两个例子，我们也大概知道，为什么会发生这样的情况了：</p>
<p>因为<code>D</code>节点在老集合里面的<code>index</code> 是最大的，使得<strong>A、B、C</strong>三个节点都会 <code>index &lt; lastindex</code>，从而导致<strong>A、B、C</strong>都会去做移动操作。所以在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</p>
<h4 id="三句箴言"><a href="#三句箴言" class="headerlink" title="三句箴言"></a>三句箴言</h4><p>所以经过这么一分析<code>react diff</code>的三大策略，我们能够在开发中更加进一步的提高react的渲染效率。</p>
<ul>
<li>在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；</li>
<li>使用 <code>shouldComponentUpdate()</code>方法节省diff的开销</li>
<li>在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</li>
</ul>
<h4 id="为什么不推荐使用index作为Key"><a href="#为什么不推荐使用index作为Key" class="headerlink" title="为什么不推荐使用index作为Key"></a>为什么不推荐使用index作为Key</h4><p>看下面这个示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   state = &#123;</span><br><span class="line">      list: [&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">val</span>: <span class="string">'A'</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">val</span>: <span class="string">'B'</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">val</span>: <span class="string">'C'</span> &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">  click = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; list &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      list:list.reverse()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">this</span>.state.list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">              &lt;li key=&#123;index&#125; &gt;</span><br><span class="line">                &#123;item.val&#125;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span>&gt;&lt;<span class="regexp">/input&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>li&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.click&#125;&gt;Reverse&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在三个输入框里面，依次输入1，2，3，点击Reverse按钮，按照我们的预期，这时候页面应该渲染成3，2，1，但是实际上，顺序依然还是1，2，3，证明数据确实是更新了的。那么为什么会发生这种事情，我们可以分析一下：</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H3ecb41d8764e4834b940428652f66478s.png" alt=""></p>
<p>出现这种情况，使用key是用来表示唯一的标识组件，当发现setState前后key的值没有发生变化 ，react就会认为你setState前后是同一个组件，进而只会对内部的属性进行修改：</p>
<ul>
<li>检测key值发现都是0，判定组件为同一个。</li>
<li>检测item.val部分，发现有变化重新渲染这部分</li>
<li>检测input，发现不依赖props，所以不进行重新渲染</li>
</ul>
<h4 id="diff-源码"><a href="#diff-源码" class="headerlink" title="diff 源码"></a>diff 源码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; diff函数，对比两颗树</span><br><span class="line">function diff(oldTree, newTree) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前的节点的标志。因为在深度优先遍历的过程中，每个节点都有一个index。</span><br><span class="line">    var index &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 在遍历到每个节点的时候，都需要进行对比，找到差异，并记录在下面的对象中。</span><br><span class="line">    var pathches &#x3D; &#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F; 开始进行深度优先遍历</span><br><span class="line">    dfsWalk(oldTree, newTree, index, pathches);</span><br><span class="line">    &#x2F;&#x2F; 最终diff算法返回的是一个两棵树的差异。</span><br><span class="line">    return pathches;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对两棵树进行深度优先遍历。</span><br><span class="line">function dfsWalk(oldNode, newNode, index, pathches) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对比oldNode和newNode的不同，记录下来</span><br><span class="line">    pathches[index] &#x3D; [...];</span><br><span class="line">  if (_.isString(newNode)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对比文本 dom 节点</span><br><span class="line">    return diffTextDom(oldNode, newNode, index, pathches)   </span><br><span class="line">  &#125;</span><br><span class="line">  if (oldNode.nodeName.toLowerCase() !&#x3D;&#x3D; newNode.nodeName) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对比非文本 dom 节点</span><br><span class="line">    diffNotTextDom(oldNode, newNode, index, pathches)     </span><br><span class="line">  &#125;</span><br><span class="line">  if (_.isFunction(newNode.nodeName)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对比自定义组件</span><br><span class="line">    return diffComponent(oldNode, newNode, index, pathches) </span><br><span class="line">  &#125;</span><br><span class="line">  if (</span><br><span class="line">     &#x2F;&#x2F; 值对比标签的类型和key值是否一致</span><br><span class="line">      oldNode.type &#x3D;&#x3D;&#x3D; newNode.type &amp;&amp;</span><br><span class="line">      oldNode.key &#x3D;&#x3D;&#x3D; newNode.key</span><br><span class="line">    ) &#123;</span><br><span class="line">      var propsPatches &#x3D; diffProps(oldNode, newNode) &#x2F;&#x2F; 对比属性</span><br><span class="line">      if (propsPatches) &#123;</span><br><span class="line">        pathches.push(&#123; type: patch.PROPS, props: propsPatches &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">     if (newVdom.children.length &gt; 0) &#123;</span><br><span class="line">       &#x2F;&#x2F; 遍历对比子节点</span><br><span class="line">       diffChildren(oldNode.children, newNode.children, index, pathches);  </span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历子节点</span><br><span class="line">function diffChildren(oldChildren, newChildren, index, pathches) &#123;  </span><br><span class="line">    var leftNode &#x3D; null;</span><br><span class="line">    var currentNodeIndex &#x3D; index;</span><br><span class="line">    oldChildren.forEach(function (child, i) &#123;</span><br><span class="line">    var newChild &#x3D; newChildren[i];</span><br><span class="line">    currentNodeIndex &#x3D; (leftNode &amp;&amp; leftNode.count)</span><br><span class="line">    ? currentNodeIndex + leftNode.count + 1</span><br><span class="line">    : currentNodeIndex + 1</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 深度遍历子节点</span><br><span class="line">    dfsWalk(child, newChild, currentNodeIndex, pathches);</span><br><span class="line">    leftNode &#x3D; child;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/diff.js#L5" target="_blank" rel="noopener">详细diff跳转</a></p>
<h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>因为步骤一所构建的 JavaScript 对象树和render出来真正的DOM树的信息、结构是一样的。<br>所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作。</p>
<p><strong>差异类型</strong></p>
<p>DOM操作可能会：</p>
<ul>
<li>替换原来的节点，如把上面的div换成了section。 </li>
<li>移动、删除、新增子节点， 例如上面div的子节点，把p和ul顺序互换。</li>
<li>修改了节点的属性。 </li>
<li>对于文本节点，文本内容可能会改变。<br>所以，我们可以定义下面的几种类型：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> REPLACE = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">var</span> REORDER = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> PROPS = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> TEXT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//patches里面存储着差异的dom,是个数组</span></span><br><span class="line">patches[<span class="number">0</span>] = [</span><br><span class="line">  &#123;</span><br><span class="line">   type:  TEXT,</span><br><span class="line">   content: <span class="string">'word'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; </span><br><span class="line">    type: PROPS,</span><br><span class="line">    props: &#123;</span><br><span class="line">      id: <span class="string">'container'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>patch 源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">node, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> walker = &#123;<span class="attr">index</span>: <span class="number">0</span>&#125;</span><br><span class="line">  dfsWalk(node, walker, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span> (<span class="params">node, walker, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentPatches = patches[walker.index] <span class="comment">// 从patches拿出当前节点的差异</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> len = node.childNodes</span><br><span class="line">    ? node.childNodes.length</span><br><span class="line">    : <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 深度遍历子节点</span></span><br><span class="line">    <span class="keyword">var</span> child = node.childNodes[i]</span><br><span class="line">    walker.index++</span><br><span class="line">    dfsWalk(child, walker, patches)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentPatches) &#123;</span><br><span class="line">    applyPatches(node, currentPatches) <span class="comment">// 对当前节点进行DOM操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>applyPatches，根据不同类型的差异对当前节点进行 DOM 操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatches</span> (<span class="params">node, currentPatches</span>) </span>&#123;</span><br><span class="line">  currentPatches.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">currentPatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> REPLACE:</span><br><span class="line">        node.parentNode.replaceChild(currentPatch.node.render(), node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> REORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> PROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TEXT:</span><br><span class="line">        node.textContent = currentPatch.content</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unknown patch type '</span> + currentPatch.type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/patch.js#L8" target="_blank" rel="noopener">详细patch跳转</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>virtual DOM算法主要实现上面步骤的三个函数： <code>react.createElement</code>、<code>diff</code>、<code>patch</code>，然后就可以实际的进行使用了。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 构建虚拟DOM</span></span><br><span class="line"><span class="keyword">let</span> tree = React.createElement(<span class="string">"div"</span>, &#123;</span><br><span class="line">  id: <span class="string">"box"</span>,</span><br><span class="line">  className: <span class="string">"box"</span>,</span><br><span class="line">  style: &#123;</span><br><span class="line">    color: <span class="string">"#ccc"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, </span><br><span class="line">React.createElement(<span class="string">"h2"</span>, &#123;</span><br><span class="line">   className: <span class="string">"title"</span></span><br><span class="line"> &#125;, <span class="string">"hhhh222"</span>),</span><br><span class="line"><span class="string">"divdivdiv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过虚拟DOM构建真正的DOM</span></span><br><span class="line"><span class="keyword">var</span> root = tree.render()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 生成新的虚拟DOM</span></span><br><span class="line"><span class="keyword">var</span> newTree = React.createElement(<span class="string">"div"</span>, &#123;</span><br><span class="line">  id: <span class="string">"box"</span>,</span><br><span class="line">  className: <span class="string">"box"</span>,</span><br><span class="line">  style: &#123;</span><br><span class="line">    color: <span class="string">"#ccc"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, </span><br><span class="line">React.createElement(<span class="string">"h2"</span>, &#123;</span><br><span class="line">   className: <span class="string">"title"</span></span><br><span class="line"> &#125;, <span class="string">"--hhhh222"</span>),</span><br><span class="line"><span class="string">"--divdivdiv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 比较两棵虚拟DOM树的不同</span></span><br><span class="line"><span class="keyword">var</span> patches = diff(tree, newTree)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 在真正的DOM元素上应用变更</span></span><br><span class="line">patch(root, patches)</span><br></pre></td></tr></table></figure>
<p>当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的ReactJS了。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://juejin.im/post/5cb66fdaf265da0384128445" target="_blank" rel="noopener">https://juejin.im/post/5cb66fdaf265da0384128445</a><br/><br><a href="https://blog.csdn.net/qq_36407875/article/details/84965311" target="_blank" rel="noopener">https://blog.csdn.net/qq_36407875/article/details/84965311</a><br/><br><a href="https://www.cnblogs.com/zhuzhenwei918/p/7271305.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuzhenwei918/p/7271305.html</a><br/><br><a href="http://react-china.org/t/react-react/26788" target="_blank" rel="noopener">http://react-china.org/t/react-react/26788</a><br/><br><a href="https://github.com/MuYunyun/blog/blob/master/React/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React/4.diff%E7%AE%97%E6%B3%95.md" target="_blank" rel="noopener">https://github.com/MuYunyun/blog/blob/master/React/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React/4.diff%E7%AE%97%E6%B3%95.md</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:feng960106@163.com">hfzvictory</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://file.jing999.cn/2019/11/17/workspace/Frame/react/dom_diff/">http://file.jing999.cn/2019/11/17/workspace/Frame/react/dom_diff/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://file.jing999.cn" target="_blank">hfzvictory</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.png" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/17/workspace/Frame/react/event/"><img class="prev_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">react事件委托机制</div></div></a></div><div class="next-post pull_right"><a href="/2019/11/17/workspace/Frame/react-native/base/"><img class="next_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RN IOS环境搭建</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: '37fl65GwM0Ub4TbovXtyyFl7-gzGzoHsz',
  appKey: 'ASnnLHANk3heLWLCBK6zbfiw',
  notify: false,
  verify: false,
  placeholder: '输入评论...',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '20',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2021 By hfzvictory</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>京ICP备18059340号-1</span></a></div></div></footer><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.5" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script></body></html>