<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Hooks | hfzvictory</title><meta name="description" content="Hooks [[toc]] Hook的规则 只在最顶层使用 Hook 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的 顺序 被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。   只在 React 函数中调用 Hook"><meta name="keywords" content="和振峰博客，web前端，node全栈工程师，hzfvictory"><meta name="author" content="hfzvictory,feng960106@163.com"><meta name="copyright" content="hfzvictory"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Hooks"><meta name="twitter:description" content="Hooks [[toc]] Hook的规则 只在最顶层使用 Hook 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的 顺序 被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。   只在 React 函数中调用 Hook"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Hooks"><meta property="og:url" content="http://file.jing999.cn/2019/10/17/workspace/Frame/react/react-hooks/"><meta property="og:site_name" content="hfzvictory"><meta property="og:description" content="Hooks [[toc]] Hook的规则 只在最顶层使用 Hook 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的 顺序 被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。   只在 React 函数中调用 Hook"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="article:published_time" content="2019-10-17T00:00:00.000Z"><meta property="article:modified_time" content="2020-06-04T08:47:09.963Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://file.jing999.cn/2019/10/17/workspace/Frame/react/react-hooks/"><link rel="prev" title="RN基本用法" href="http://file.jing999.cn/2019/11/17/workspace/Frame/react-native/guide/"><link rel="next" title="GraphQL" href="http://file.jing999.cn/2019/10/15/workspace/Server/api/GraphQL/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: hfzvictory","link":"链接: ","source":"来源: hfzvictory","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ae01.alicdn.com/kf/H9ae3136bf5e440239fa2c611632fbd09H.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">104</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">99</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/todos"><i class="fa-fw fa fa-battery-three-quarters"></i><span> Todos</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bicycle" aria-hidden="true"></i><span> 喜好</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook的规则"><span class="toc-number">1.</span> <span class="toc-text">Hook的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Hooks的好处"><span class="toc-number">2.</span> <span class="toc-text">使用Hooks的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hooks的方法"><span class="toc-number">3.</span> <span class="toc-text">Hooks的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useState"><span class="toc-number">4.</span> <span class="toc-text">useState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useEffect"><span class="toc-number">5.</span> <span class="toc-text">useEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useContext"><span class="toc-number">6.</span> <span class="toc-text">useContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useReducer"><span class="toc-number">7.</span> <span class="toc-text">useReducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useCallback"><span class="toc-number">8.</span> <span class="toc-text">useCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useMemo"><span class="toc-number">9.</span> <span class="toc-text">useMemo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useRef"><span class="toc-number">10.</span> <span class="toc-text">useRef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useImperativeHandle"><span class="toc-number">11.</span> <span class="toc-text">useImperativeHandle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useLayoutEffect"><span class="toc-number">12.</span> <span class="toc-text">useLayoutEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useDebugValue"><span class="toc-number">13.</span> <span class="toc-text">useDebugValue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义-Hook-必须以-use-开头吗？"><span class="toc-number">14.</span> <span class="toc-text">自定义 Hook 必须以 use 开头吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题示例"><span class="toc-number">15.</span> <span class="toc-text">面试题示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hooks-FAQ"><span class="toc-number">16.</span> <span class="toc-text">Hooks FAQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#useEffect在外面声明函数"><span class="toc-number">16.1.</span> <span class="toc-text">useEffect在外面声明函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何获取上一轮的-props-或-state"><span class="toc-number">16.2.</span> <span class="toc-text">如何获取上一轮的 props 或 state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么我修改后在别的函数中获取的还是上一次的值"><span class="toc-number">16.3.</span> <span class="toc-text">为什么我修改后在别的函数中获取的还是上一次的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取DOM-节点"><span class="toc-number">16.4.</span> <span class="toc-text">获取DOM 节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useCallback示例何时更新"><span class="toc-number">16.5.</span> <span class="toc-text">useCallback示例何时更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useMemo优化组件"><span class="toc-number">16.6.</span> <span class="toc-text">useMemo优化组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何向下传递回调？"><span class="toc-number">16.7.</span> <span class="toc-text">如何向下传递回调？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义Hooks"><span class="toc-number">17.</span> <span class="toc-text">自定义Hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#useFetch"><span class="toc-number">17.1.</span> <span class="toc-text">useFetch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hooks原理分析"><span class="toc-number">18.</span> <span class="toc-text">Hooks原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简单实现一个useState"><span class="toc-number">18.1.</span> <span class="toc-text">简单实现一个useState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单实现一个useEffect"><span class="toc-number">18.2.</span> <span class="toc-text">简单实现一个useEffect</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考文档"><span class="toc-number">19.</span> <span class="toc-text">参考文档</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div class="post-bg" id="nav" style="background-image: url(https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">hfzvictory</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/todos"><i class="fa-fw fa fa-battery-three-quarters"></i><span> Todos</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bicycle" aria-hidden="true"></i><span> 喜好</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Hooks</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-10-17 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-10-17</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-04 08:47:09"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-04</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/FE%E6%A1%86%E6%9E%B6/">FE框架</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/FE%E6%A1%86%E6%9E%B6/React/">React</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/FE%E6%A1%86%E6%9E%B6/React/Hooks/">Hooks</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">6k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 26 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><strong class='old-blog'>Hooks</strong></p>
<p>[[toc]]</p>
<h3 id="Hook的规则"><a href="#Hook的规则" class="headerlink" title="Hook的规则"></a>Hook的规则</h3><ul>
<li>只在最顶层使用 Hook<ul>
<li>不要在<code>循环</code>，<code>条件</code>或<code>嵌套函数</code>中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的 <strong><code>顺序</code></strong> 被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。</li>
</ul>
</li>
<li>只在 React 函数中调用 Hook     <ul>
<li>在 React 的函数组件中调用 Hook</li>
<li>在自定义 Hook 中调用其他 Hook<ul>
<li><strong>在类中使用报错警告</strong> 「Hooks can only be called inside the body of a function component」</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用Hooks的好处"><a href="#使用Hooks的好处" class="headerlink" title="使用Hooks的好处"></a>使用Hooks的好处</h3><p><strong>1.class 学习成本高</strong><br/><br>生命周期，this指向啥的，hooks只要会usestate   useeffect差不多能解决所有问题<br/><br><strong>2.class业务逻辑分散</strong><br/><br>定时器，dom2事件啥的一定要在componentWillUnMount 去卸载。而是用hooks就非常聚合了，直接返回函数里面清楚就可以了<br/><br><strong>3.class逻辑复用困难</strong><br/><br>hooks最有优势的就数她的逻辑复用能力了<br/><br>在class中一般用Render Props（局限性）和高阶组件（嵌套太深）做逻辑复用<br/><br>比如一个列表渲染，class每次都要写数据请求，下拉加载，上拉刷新重置分页，loading展示，而在hooks里直接自定义一个hooks就可以做到全部的列表加载逻辑公用<br/><br><strong>4.</strong> class 打包时无法对 class 的属性方法进行优化，而使用 hooks 则可以将代码压缩到极致。<br/><br><strong>5.</strong> 最直接的就是业务变更的时候不需要再把函数式组件变成class了</p>
<p><strong>缺点</strong><br/><br>形成太多闭包，容易导致内存泄漏<br/><br>function写太多代码后期不好维护</p>
<p><strong>自定义过的</strong><br/><br>useFetch<br/><br>useMouse<br/><br>useScroll<br/><br>useSize<br/><br>useFrom<br/><br>useTable<br/><br>useStore<br/></p>
<p>真正说服我使用 react hooks 的，是 react blog 里面提到的，使用 class component 打包时无法对 class 的属性方法进行优化，而<strong>使用 hooks 则可以将代码压缩到极致</strong>。<br/><br>有人会说 hooks 是趋势是未来啥的，但是，实际上，hooks 比 class 复杂和难理解多了，而且随着业务逻辑的增长，一个 function 里面将会写出越来越多的代码，<br>越来越复杂，让你无法维护。而实际上，在运行时，两则的差别不是特别大，都没有性能上的优劣。<br/></p>
<h3 id="Hooks的方法"><a href="#Hooks的方法" class="headerlink" title="Hooks的方法"></a>Hooks的方法</h3><table>
<thead>
<tr>
<th align="left"><span style='display: block;text-align: left;'> 钩子名</span></th>
<th align="left"><span style='display: block;text-align: left;'> 作用</span></th>
</tr>
</thead>
<tbody><tr>
<td align="left">useState</td>
<td align="left">初始化和设置状态</td>
</tr>
<tr>
<td align="left">useEffect</td>
<td align="left">componentDidMount，componentDidUpdate和componentWillUnmount和结合体,所以可以监听useState定义值的变化</td>
</tr>
<tr>
<td align="left">useContext</td>
<td align="left">定义一个全局的对象,类似 context</td>
</tr>
<tr>
<td align="left">useReducer</td>
<td align="left">可以增强函数提供类似 Redux 的功能</td>
</tr>
<tr>
<td align="left">useCallback</td>
<td align="left">记忆作用,共有两个参数，第一个参数为一个匿名函数，就是我们想要创建的函数体。第二参数为一个数组，里面的每一项是用来判断是否需要重新创建函数体的变量，如果传入的变量值保持不变，返回记忆结果。如果任何一项改变，则返回新的结果</td>
</tr>
<tr>
<td align="left">useMemo</td>
<td align="left">作用和传入参数与 useCallback 一致,useCallback返回函数,useDemo 返回值</td>
</tr>
<tr>
<td align="left">useRef</td>
<td align="left">获取 ref 属性对应的 dom</td>
</tr>
<tr>
<td align="left">useImperativeMethods</td>
<td align="left">自定义使用ref时公开给父组件的实例值</td>
</tr>
<tr>
<td align="left">useLayoutEffect</td>
<td align="left">作用与useEffect相同，但在所有DOM改变后同步触发</td>
</tr>
<tr>
<td align="left">useDebugValue</td>
<td align="left">useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。</td>
</tr>
</tbody></table>
<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;直接传入初始值</span><br><span class="line">const [state, setState] &#x3D; useState(initialState);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用</span><br><span class="line">const [state, setState] &#x3D; useState(() &#x3D;&gt; &#123;</span><br><span class="line">  const initialState &#x3D; ff(props);</span><br><span class="line">  return initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>官方建议推荐把 state 切分成多个 state 变量，每个变量包含的不同值会在同时发生变化。</p>
<p><strong>好处是</strong></p>
<ul>
<li>后期把一些相关的逻辑抽取到一个自定义 Hook 变得容易<br/></li>
<li>赋值的时候简单，多个需要克隆下，把不变的存储下来</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setState(state+<span class="number">1</span>);  <span class="comment">//直接从初始值里面获取</span></span><br><span class="line">setState(<span class="function"><span class="params">prevState</span>=&gt;</span>prevState+<span class="number">1</span>) <span class="comment">//该函数将接收先前的state,并返回一个更新后的值</span></span><br></pre></td></tr></table></figure>

<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p><code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>：useEffect Hook 可以表达所有这些(包括 不那么 常见 的场景)的组合。</p>
<p>默认情况下，effect 将在每轮<code>渲染结束后执行</code>，但你可以选择让它 在只有<code>某些值改变</code>的时候 才执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    const timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">      setCount(c &#x3D;&gt; c + 1); </span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    return () &#x3D;&gt; clearInterval(timer);</span><br><span class="line">  &#125;, []); </span><br><span class="line">  return &lt;h1&gt;&#123;count&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，<code>上一个 effect 就已被清除</code>。看下个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Fragment, useState, useEffect, useRef&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Example &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(1);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;11&quot;);</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&quot;22&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &#123;console.log(&quot;渲染&quot;)&#125;</span><br><span class="line">            &lt;h1&gt;&#123;count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123;</span><br><span class="line">                setCount(count + 1)</span><br><span class="line">            &#125;&#125;&gt; +</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H66bfd87154314ad49baee2dd855336acT.gif" alt=""></p>
<p>打印的顺序为 <strong>渲染-&gt;22-&gt;11</strong></p>
<p>若多次执行effect，其内部会生成新的函数，（effect还是原函数，或者说指向原地址）这样的话如果我是定义的事件，每次更新都会执行，那么岂不是在事件还没有移除掉又定义了一次，所以useEffect加入了这个功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;useState, useEffect&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Example &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const [width, setWidth] &#x3D; useState(window.innerWidth);</span><br><span class="line">    const [count, setCount] &#x3D; useState(1);</span><br><span class="line">    const resizeHandle &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        setWidth(window.innerWidth);</span><br><span class="line">        console.log(window.innerWidth);</span><br><span class="line">    &#125;;</span><br><span class="line">    const a &#x3D; useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        window.addEventListener(&quot;resize&quot;, resizeHandle);</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; window.removeEventListener(&quot;resize&quot;, resizeHandle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);  &#x2F;&#x2F;或者使用[]</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;h1&gt;&#123;width&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123;</span><br><span class="line">                setCount(count + 1)</span><br><span class="line">            &#125;&#125;&gt;+</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>

<p>看下面图片可以看出来，重复多次执行了<code>resize</code>方法</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H9d109cbe0722447baf4ef132fa24268fE.gif" alt=""></p>
<p><a href="http://file.jing999.cn/workspace/Frame/react/use-hooks.html#useeffect%E5%9C%A8%E5%A4%96%E9%9D%A2%E5%A3%B0%E6%98%8E%E5%87%BD%E6%95%B0'">官方建议effect使用的方法声明在其内部</a></p>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p>React16中更新了Context API，Context主要用于爷孙组件的传值问题，新的Context API使用订阅发布者模式方式实现在爷孙组件中传值</p>
<p>React Hooks出现之后也对Context API出了响应的Hook useContext。同样也是解传值的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const stateContext &#x3D; createContext(&#39;default&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&lt;stateContext.Provider</span><br><span class="line">    value&#x3D;&#123;&quot;Hello React&quot;&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;ContextComponent&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;stateContext.Provider&gt;</span><br><span class="line">&#x2F;&#x2F;子组件 </span><br><span class="line">const ContextComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const value &#x3D; useContext(stateContext);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;h1&gt;&#123;value&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，使用<code>useContext仍然需要在上层组件中使用&lt;MyContext.Provider&gt;</code>来为下层组件提供context。</p>
<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>看到<code>useReducer</code>,肯定会想到Redux，没错它和Redux的工作方式是一样的。useReducer的出现是useState的替代方案，能够让我们更好的管理状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>

<p>在某些场景下，useReducer 会比 useState 更适用，例如 state <code>逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state</code>等。<br>并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，<code>因为你可以向子组件传递 dispatch 而不是回调函数</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const initialState &#x3D; &#123;count: 0&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#39;increment&#39;:</span><br><span class="line">      return &#123;count: state.count + 1&#125;;</span><br><span class="line">    case &#39;decrement&#39;:</span><br><span class="line">      return &#123;count: state.count - 1&#125;;</span><br><span class="line">    default:</span><br><span class="line">      throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const [state, dispatch] &#x3D; useReducer(reducer, initialState);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三个参数(惰性初始化)</strong></p>
<p>useReducer的第三个参数接受一个函数作为参数，并把第二个参数当作函数的参数执行。主要作用是初始值的惰性求值，把一些对状态的逻辑抽离出来，有利于重置state。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Fragment, useState, useEffect, useRef, useCallback, useMemo, useReducer&#125; from &quot;react&quot;;</span><br><span class="line">const initialState &#x3D; &#123;count: 0&#125;;</span><br><span class="line">function init(s) &#123;</span><br><span class="line">    console.log(s);</span><br><span class="line">    return &#123;...s&#125;;</span><br><span class="line">&#125;</span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#39;increment&#39;:</span><br><span class="line">            return &#123;count: state.count + 1&#125;;</span><br><span class="line">        case &#39;decrement&#39;:</span><br><span class="line">            return &#123;count: state.count - 1&#125;;</span><br><span class="line">        case &#39;reset&#39;:</span><br><span class="line">            return init(action.payload);</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, initialState, init);</span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            Count: &#123;state.count&#125;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;reset&#39;, payload: initialState&#125;)&#125;&gt;重置&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default Counter</span><br></pre></td></tr></table></figure>

<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>返回一个memoized回调<code>函数</code>。</p>
<p><a href="http://file.jing999.cn/workspace/Frame/react/use-hooks.html#usecallback%E7%A4%BA%E4%BE%8B%E4%BD%95%E6%97%B6%E6%9B%B4%E6%96%B0">下面介绍的使用方式</a></p>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>返回一个memoized<code>值</code>。</p>
<p>useMemo和useCallback很像，唯一不同的就是</p>
<p>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。</p>
<p>公用的<code>方法</code>用<code>useCallback</code>,若是直接<code>渲染值</code>则用<code>useMemo</code>，用<code>useCallback</code>的话也是每次都要执行的，但是<code>useMemo</code>是直接把值记忆存储了（前面的都是废话，其实都能实现，不过这样更符合习惯）</p>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>本质上<code>useRef</code>就像是可以在其<code>.current</code>属性中保存一个可变值的“盒子”，<code>useRef(null)返回值</code>是不可拓展的属性,<code>.current</code>可以。</p>
<p>下篇文章介绍如何使用而useRef自己最新的值，或者存储上一次props或者state的值；我们直接声明一个值存储当前的值不好吗，为啥要借助useRef()</p>
<p><strong>这是因为它创建的是一个普通Javascript对象。而useRef()和自建一个 {current: …}对象的唯一区别是，useRef会在每次渲染时返回同一个ref对象。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Fragment, useState, useEffect, useRef, useCallback, useMemo, useReducer&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Example &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    let inputRef &#x3D; useRef(null);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        inputRef.current.focus();</span><br><span class="line">    &#125;, []);</span><br><span class="line">    return (</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;inputRef&#125;&#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>


<h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>

<p><code>useImperativeHandle</code>可以让你在使用 ref 时<code>自定义</code>暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <code>forwardRef</code> 一起使用</p>
<p>就是说：当我们使用父组件把ref传递给子组件的时候，这个Hooks允许在子组件中把自定义实例附加到父组件传过来的ref上，有利于父组件控制子组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;</span><br><span class="line">    Fragment,</span><br><span class="line">    useRef,</span><br><span class="line">    useImperativeHandle,</span><br><span class="line">    forwardRef,</span><br><span class="line">    useEffect</span><br><span class="line">&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">function FancyInput(props, ref) &#123;</span><br><span class="line">    const inputRef &#x3D; useRef();</span><br><span class="line">    useImperativeHandle(ref, () &#x3D;&gt; (</span><br><span class="line">        &#123;</span><br><span class="line">            addText: () &#x3D;&gt; &#123;</span><br><span class="line">                inputRef.current.value &#x3D; &quot;我是由父级添加的&quot;;</span><br><span class="line">            &#125;,</span><br><span class="line">            focus: () &#x3D;&gt; &#123;</span><br><span class="line">                inputRef.current.focus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ));</span><br><span class="line">    return &lt;input ref&#x3D;&#123;inputRef&#125;&#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const TempFancyInput &#x3D; forwardRef(FancyInput);</span><br><span class="line"></span><br><span class="line">const Example &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    let ref &#x3D; useRef(null);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(ref);</span><br><span class="line">        ref.current.addText();</span><br><span class="line">        ref.current.focus();</span><br><span class="line">    &#125;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;TempFancyInput ref&#x3D;&#123;ref&#125;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H3eab0df2695d4654a1f9e9a9b1f20edem.png" alt=""></p>
<h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p>这个钩子函数与useEffect相同，但它会在所有的DOM变更之后<code>同步</code>调用effect。可以使用它来读取DOM布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p>
<p>官网建议还是尽可能的是使用标准的useEffec以避免阻塞视觉更新。</p>
<h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3><p>useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。</p>
<h3 id="自定义-Hook-必须以-use-开头吗？"><a href="#自定义-Hook-必须以-use-开头吗？" class="headerlink" title="自定义 Hook 必须以 use 开头吗？"></a>自定义 Hook 必须以 use 开头吗？</h3><p>必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的<a href="https://react.docschina.org/docs/hooks-rules.html" target="_blank" rel="noopener">规则</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useWinResize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> [size, setSize] = useState(&#123;</span><br><span class="line">     width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">     height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">const</span> resize = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     setSize(&#123;</span><br><span class="line">     width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">     height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125;, [])</span><br><span class="line"> useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, resize);</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, resize);</span><br><span class="line"> &#125;, []);</span><br><span class="line"> <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123;width, height&#125; = useWinResize();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>width: &#123;width&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>height: &#123;height&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="面试题示例"><a href="#面试题示例" class="headerlink" title="面试题示例"></a>面试题示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Fragment, useState, useEffect, useRef, useCallback&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">const</span> useInterval = <span class="function">(<span class="params">callback, delay</span>) =&gt;</span> &#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delay !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> id = setInterval(callback, delay);</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [delay]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [diff, setDiff] = useState(<span class="number">500</span>);</span><br><span class="line">    useInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;, diff);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;p&gt; count: &#123;count&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt; diff: &#123;diff&#125;ms &lt;/</span>p&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; setDiff(diff - <span class="number">50</span>)&#125;&gt; 加快<span class="number">50</span>ms&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;() =&gt; setDiff(diff + 50)&#125;&gt; 减慢50ms&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure>

<p>可是这段运行后很奇怪，页面从0到1后，就再也不变了，console.log(count)的输出表明代码并没有卡死，那么问题出在哪儿了？<br/><br>React组件中的props和state是可以改变的，React会重渲染它们且「丢弃」任何关于上一次渲染的结果，它们之间不再有相关性。<br/><br>useEffect()Hook也「丢弃」上一次渲染结果，它会清除上一次effect再建立下一个effect，下一个effect<code>锁住新的props和state</code>，这也是我们第一次尝试简单示例可以正确工作的原因。<br/><br>但setInterval不会「丢弃」。它会一直引用老的props和state直到你把它换掉——不重置时间你是无法做到的。这里就要用到useRef这个hook了，我们把callback存储到ref中，当callback更新时去更新ref.current的值：</p>
<p>两种方法:【一种是把count存起来，一种是把定时器里面的函数存起来】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Fragment, useState, useEffect, useRef, useCallback&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">const</span> useInterval = <span class="function">(<span class="params">callback, delay, val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> saveCallback = useRef();</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        saveCallback.current = val</span><br><span class="line">    &#125;,[val]);</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delay !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> callback(saveCallback.current), delay);</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [delay]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [diff, setDiff] = useState(<span class="number">500</span>);</span><br><span class="line">    useInterval(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        setCount(val + <span class="number">1</span>);</span><br><span class="line">    &#125;, diff, count);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;p&gt; count: &#123;count&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt; diff: &#123;diff&#125;ms &lt;/</span>p&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; setDiff(diff - <span class="number">50</span>)&#125;&gt; 加快<span class="number">50</span>ms&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;() =&gt; setDiff(diff + 50)&#125;&gt; 减慢50ms&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// const useInterval = (callback, delay) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     const saveCallback = useRef();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         // 每次渲染后，保存新的回调到我们的 ref 里</span></span><br><span class="line"><span class="comment">//         saveCallback.current = callback;</span></span><br><span class="line"><span class="comment">//     &#125;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         function tick() &#123;</span></span><br><span class="line"><span class="comment">//             saveCallback.current();  //每次执行最新的callback</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         if (delay !== null) &#123;</span></span><br><span class="line"><span class="comment">//             let id = setInterval(tick, delay);</span></span><br><span class="line"><span class="comment">//             return () =&gt; clearInterval(id);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;, [delay]);</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure>

<h3 id="Hooks-FAQ"><a href="#Hooks-FAQ" class="headerlink" title="Hooks FAQ"></a><code>Hooks FAQ</code></h3><h4 id="useEffect在外面声明函数"><a href="#useEffect在外面声明函数" class="headerlink" title="useEffect在外面声明函数"></a>useEffect在外面声明函数</h4><p><strong>一般来说，不安全</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(someProp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 这样不安全（它调用的 `doSomething` 函数使用了 `someProp`）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要记住 effect 外部的函数使用了哪些 props 和 state 很难。这也是为什么 通常你会想要在 effect 内部 去声明它所需要的函数。 这样就能容易的看出那个 effect 依赖了组件作用域中的哪些值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(someProp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doSomething();</span><br><span class="line">  &#125;, [someProp]); <span class="comment">// ✅ 安全（我们的 effect 仅用到了 `someProp`）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果处于某些原因你无法把一个函数移动到effect内部，还有一些其他办法：</strong></p>
<ul>
<li><p>你可以尝试把那个函数移动到你的组件之外。那样一来，这个函数就肯定不会依赖任何 props,或state并且也不用出现在依赖列表中了。</p>
</li>
<li><p>如果你所调用的方法是一个纯计算，并且可以在渲染时调用，你可以 转而在 effect 之外调用它， 并让 effect 依赖于它的返回值。</p>
</li>
<li><p>万不得已的情况下，你可以把函数加入effect的依赖但 把它的定义包裹 进<code>useCallback Hook</code>。这就确保了它不随渲染而改变，除非 它自身 的依赖发生了改变</p>
</li>
</ul>
<h4 id="如何获取上一轮的-props-或-state"><a href="#如何获取上一轮的-props-或-state" class="headerlink" title="如何获取上一轮的 props 或 state"></a>如何获取上一轮的 props 或 state</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Fragment, useState, useEffect, useRef&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePrevious</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ref = useRef();</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ref.current = value;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ref.current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> prevCount = usePrevious(count);</span><br><span class="line">    <span class="comment">//此时prevCount是上一次的effect的调用，内部已经改变,只是没有重新渲染</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)  <span class="comment">//先渲染后执行这个effect</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Now: &#123;count&#125;, before: &#123;prevCount&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;div onClick=&#123;() =&gt; setCount((val) =&gt; val + 1)&#125;&gt;</span><br><span class="line">            点击加一</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example</span><br></pre></td></tr></table></figure>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/Hd6588fe44428462c90a0d7ee879c5948a.gif" alt=""></p>
<p>考虑到这是一个相对常见的使用场景，很可能在未来 React 会自带一个 usePrevious Hook。</p>
<h4 id="为什么我修改后在别的函数中获取的还是上一次的值"><a href="#为什么我修改后在别的函数中获取的还是上一次的值" class="headerlink" title="为什么我修改后在别的函数中获取的还是上一次的值"></a>为什么我修改后在别的函数中获取的还是上一次的值</h4><p>组件内部的任何函数，包括事件处理函数和 effect，都是从它<code>被创建</code>的那次渲染中拿到的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;useState, useRef&#125; from &quot;react&quot;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0);</span><br><span class="line">    function handleClick() &#123;</span><br><span class="line">        console.log(count,&#39;函数内部&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    const add &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        let val &#x3D; count + 1;</span><br><span class="line">        setCount(val);</span><br><span class="line">        handleClick()</span><br><span class="line">    &#125;;</span><br><span class="line">     console.log(count,&#39;函数外面&#39;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;add&#125;&gt;</span><br><span class="line">                点击我</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;</span><br><span class="line">                获取值</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default Example;</span><br></pre></td></tr></table></figure>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H70f6508f638a4c35bb9d095a2a5fde9cE.gif" alt=""></p>
<p>你发现<code>handleClick</code>每次获取的都是上一次的值，<strong>因为它获取的是创建它的那次值</strong>，此时可以用<code>useRef</code>曲线救国</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;useState, useRef&#125; from &quot;react&quot;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0);</span><br><span class="line">    const ref &#x3D; useRef();</span><br><span class="line">    function handleClick() &#123;</span><br><span class="line">        console.log(count, ref.current);</span><br><span class="line">    &#125;</span><br><span class="line">    const add &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        let val &#x3D; count + 1;</span><br><span class="line">        setCount(val);</span><br><span class="line">        ref.current &#x3D; val;</span><br><span class="line">        handleClick()</span><br><span class="line">    &#125;;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;add&#125;&gt;</span><br><span class="line">                点击我</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;</span><br><span class="line">                获取值</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default Example;</span><br></pre></td></tr></table></figure>

<h4 id="获取DOM-节点"><a href="#获取DOM-节点" class="headerlink" title="获取DOM 节点"></a>获取DOM 节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Fragment,useState, useRef, useCallback&#125; from &quot;react&quot;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    const [width, setWidth] &#x3D; useState(0);</span><br><span class="line">    &#x2F;&#x2F; const inputEl &#x3D; useRef(null)</span><br><span class="line">    &#x2F;&#x2F; useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;      setWidth(inputEl.current.getBoundingClientRect().width);</span><br><span class="line">    &#x2F;&#x2F; &#125;);</span><br><span class="line">          </span><br><span class="line">    let ref &#x3D; useCallback(node &#x3D;&gt; &#123;</span><br><span class="line">        if (node !&#x3D;&#x3D; null) &#123;</span><br><span class="line">            setWidth(node.getBoundingClientRect().width);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, []);</span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;h1 ref&#x3D;&#123;ref&#125;&gt;Hello, world&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;h2&gt;当前屏幕宽度为 &#123;Math.round(width)&#125;px&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>
<p>这里我们没有选择使用<code>useRef</code>，用的ref的回调函数，因为当ref是一个对象时它并不会把当前ref的值的变化通知到我们，最终还是要借助effect来实现「代码如上」</p>
<p><strong>抽离出来</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;useState, useRef, useCallback&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const useClientRect &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const [width, setWidth] &#x3D; useState(0);</span><br><span class="line">    let ref &#x3D; useCallback(node &#x3D;&gt; &#123;</span><br><span class="line">        if (node !&#x3D;&#x3D; null) &#123;</span><br><span class="line">            setWidth(node.getBoundingClientRect().width);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, []);</span><br><span class="line">    return [width, ref]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">    const [width, ref] &#x3D; useClientRect(0);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;h1 ref&#x3D;&#123;ref&#125;&gt;Hello, world&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;h2&gt;当前屏幕宽度为 &#123;Math.round(width)&#125;px&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>

<h4 id="useCallback示例何时更新"><a href="#useCallback示例何时更新" class="headerlink" title="useCallback示例何时更新"></a>useCallback示例何时更新</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Fragment, useState, useEffect, useRef, useCallback&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const set1 &#x3D; new Set();</span><br><span class="line"></span><br><span class="line">let c &#x3D; 21;&#x2F;&#x2F;【2】</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    name: &quot;hzf&quot;</span><br><span class="line">&#125;;&#x2F;&#x2F;【1】如果是对象的话，他会指向一个地址，除非改变地址他才会重新执行useCallback，否则他返回的是上次缓存的函数</span><br><span class="line"></span><br><span class="line">function Form() &#123;</span><br><span class="line">    const [text, updateText] &#x3D; useState(&#39;&#39;);</span><br><span class="line">    const textRef &#x3D; useRef();</span><br><span class="line"></span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        c &#x3D; Math.random(); &#x2F;&#x2F;【2】</span><br><span class="line"></span><br><span class="line">        textRef.current &#x3D; text;</span><br><span class="line"></span><br><span class="line">        obj &#x3D; &#123;...textRef&#125;; &#x2F;&#x2F;【1】</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const handleSubmit &#x3D; useCallback(() &#x3D;&gt; &#123;</span><br><span class="line">        const currentText &#x3D; textRef.current;</span><br><span class="line">        console.log((currentText));</span><br><span class="line">    &#125;, [obj]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    set1.add(handleSubmit);</span><br><span class="line">    console.log(set1.size);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;input value&#x3D;&#123;text&#125; onChange&#x3D;&#123;e &#x3D;&gt; updateText(e.target.value)&#125;&#x2F;&gt;</span><br><span class="line">            &#123;&#x2F;*&lt;div&gt;&#123;textRef.current&#125;&lt;&#x2F;div&gt;*&#x2F;&#125;</span><br><span class="line">            &lt;div&gt;&#123;c&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;handleSubmit&#125;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Form</span><br></pre></td></tr></table></figure>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ae01.alicdn.com/kf/H7410c03e8eab4361b28a18bfce16c4ba9.gif" alt=""></p>
<p>由此可见obj每次执行都要<code>浅克隆</code>，useCallback依赖于<code>obj</code>所以每次都会生成新的函数。</p>
<h4 id="useMemo优化组件"><a href="#useMemo优化组件" class="headerlink" title="useMemo优化组件"></a>useMemo优化组件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Example(&#123; a, b &#125;) &#123;</span><br><span class="line">  &#x2F;&#x2F; Only re-rendered if &#96;a&#96; changes:</span><br><span class="line">  const child1 &#x3D; useMemo(() &#x3D;&gt; &lt;Child1 a&#x3D;&#123;a&#125; &#x2F;&gt;, [a]);</span><br><span class="line">  &#x2F;&#x2F; Only re-rendered if &#96;b&#96; changes:</span><br><span class="line">  const child2 &#x3D; useMemo(() &#x3D;&gt; &lt;Child2 b&#x3D;&#123;b&#125; &#x2F;&gt;, [b]);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;child1&#125;</span><br><span class="line">      &#123;child2&#125;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure>
<p><code>注意这种方式在循环中是无效的</code></p>
<h4 id="如何向下传递回调？"><a href="#如何向下传递回调？" class="headerlink" title="如何向下传递回调？"></a>如何向下传递回调？</h4><p>我们已经发现大部分人并不喜欢在组件树的每一层手动传递回调。尽管这种写法更明确，但这给人感觉像错综复杂的管道工程一样麻烦。</p>
<p>在<code>大型</code>的组件树中建议使用 context 用 useReducer 往下传一个 <code>dispatch</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TodosDispatch &#x3D; React.createContext(null);</span><br><span class="line"></span><br><span class="line">function TodosApp() &#123;</span><br><span class="line">  &#x2F;&#x2F; 提示：&#96;dispatch&#96; 不会在重新渲染之间变化</span><br><span class="line">  const [todos, dispatch] &#x3D; useReducer(todosReducer);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;TodosDispatch.Provider value&#x3D;&#123;dispatch&#125;&gt;</span><br><span class="line">      &lt;DeepTree todos&#x3D;&#123;todos&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;TodosDispatch.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function DeepTree(props) &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。</span><br><span class="line">  const dispatch &#x3D; useContext(TodosDispatch);</span><br><span class="line"></span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    dispatch(&#123; type: &#39;add&#39;, text: &#39;hello&#39; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;Add todo&lt;&#x2F;button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义Hooks"><a href="#自定义Hooks" class="headerlink" title="自定义Hooks"></a>自定义Hooks</h3><h4 id="useFetch"><a href="#useFetch" class="headerlink" title="useFetch"></a>useFetch</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useDataApi = <span class="function">(<span class="params">initialUrl, initialData</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> [data, setData] = useState(initialData);</span><br><span class="line">    <span class="keyword">const</span> [url, setUrl] = useState(initialUrl);</span><br><span class="line">    <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> [isError, setIsError] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">            setIsError(<span class="literal">false</span>);</span><br><span class="line">            setIsLoading(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> result = <span class="keyword">await</span> fetch(url).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json());</span><br><span class="line">                <span class="comment">// const result = await axios.get(url);</span></span><br><span class="line">                setData(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                setIsError(<span class="literal">true</span>);</span><br><span class="line">                setData(initialData);</span><br><span class="line">            &#125;</span><br><span class="line">            setIsLoading(<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    fetchData();</span><br><span class="line">    &#125;, [url]);</span><br><span class="line">    <span class="keyword">return</span> [&#123;data, isLoading, isError&#125;, setUrl];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Hooks原理分析"><a href="#Hooks原理分析" class="headerlink" title="Hooks原理分析"></a>Hooks原理分析</h3><h4 id="简单实现一个useState"><a href="#简单实现一个useState" class="headerlink" title="简单实现一个useState"></a>简单实现一个useState</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _state;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialValue</span>)</span>&#123;</span><br><span class="line">    _state = _state || initialValue;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>)</span>&#123;</span><br><span class="line">        _state = newState;</span><br><span class="line">        render()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [_state,setState]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setState第一个参数可以使函数，当为函数的时候，参数为当前的_state</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _state;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialValue</span>)</span>&#123;</span><br><span class="line">    _state = _state || initialValue;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">fun</span>)</span>&#123;</span><br><span class="line">        _state = fun(_state) || _state</span><br><span class="line">        render()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [_state,setState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCount(<span class="function"><span class="params">state</span>=&gt;</span>state+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">"antd"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./styles.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _state; <span class="comment">// 把 state 存储在外面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  _state = _state | initialValue; <span class="comment">// 如果没有 _state，说明是第一次执行，把 initialValue 复制给它</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>) </span>&#123;</span><br><span class="line">    _state = newState;</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [_state, setState];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;&#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button</span></span><br><span class="line"><span class="regexp">        onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          setCount(count + 1);</span></span><br><span class="line"><span class="regexp">        &#125;&#125;</span></span><br><span class="line"><span class="regexp">      &gt;</span></span><br><span class="line"><span class="regexp">        点击1</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function render() &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(&lt;App /</span>&gt;, rootElement);</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<h4 id="简单实现一个useEffect"><a href="#简单实现一个useEffect" class="headerlink" title="简单实现一个useEffect"></a>简单实现一个useEffect</h4><p>dependencies:依赖关系</p>
<p>Effect有几个特点</p>
<ul>
<li>有两个参数 callback 和 dependencies 数组</li>
<li>如果 dependencies 不存在，那么 callback 每次 render 都会执行</li>
<li>如果 dependencies 存在，只有当它发生了变化， callback 才会执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _deps; <span class="comment">// _deps 记录 useEffect 上一次的 依赖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, depArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hasNoDeps = !depArray; <span class="comment">// 如果 dependencies 不存在</span></span><br><span class="line">  <span class="keyword">const</span> hasChangedDeps = (_deps</span><br><span class="line">    ? !depArray.every(<span class="function">(<span class="params">el, i</span>) =&gt;</span> el === _deps[i]) <span class="comment">// 两次的 dependencies 是否完全相等</span></span><br><span class="line">    : <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">/* 如果 dependencies 不存在，或者 dependencies 有变化*/</span></span><br><span class="line">  <span class="keyword">if</span> (hasNoDeps || hasChangedDeps) &#123;</span><br><span class="line">    callback();</span><br><span class="line">    _deps = depArray;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到现在的话，在页面能正常使用了，但是每次使用只能用一次，因为你声明多次的话，它是公用的一个变量，不能重复使用。</p>
<p>们可以使用数组，来解决 Hooks 的复用问题</p>
<p><strong>代码关键在于：</strong></p>
<p>初次渲染的时候，按照 <code>useState，useEffect</code> 的顺序，把 <code>state，deps</code> 等按顺序塞到 <code>memoizedState</code> 数组中。<br>更新的时候，按照顺序，从 <code>memoizedState</code> 中把上次记录的值拿出来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> memoizedState = []; <span class="comment">// hooks 存放在这个数组</span></span><br><span class="line"><span class="keyword">let</span> cursor = <span class="number">0</span>; <span class="comment">// 当前 memoizedState 下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  memoizedState[cursor] = memoizedState[cursor] || initialValue;</span><br><span class="line">  <span class="keyword">const</span> currentCursor = cursor;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>) </span>&#123;</span><br><span class="line">    memoizedState[currentCursor] = newState;</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [memoizedState[cursor++], setState]; <span class="comment">// 返回当前 state，并把 cursor 加 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, depArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hasNoDeps = !depArray;</span><br><span class="line">  <span class="keyword">const</span> deps = memoizedState[cursor];</span><br><span class="line">  <span class="keyword">const</span> hasChangedDeps = (deps</span><br><span class="line">    ? !depArray.every(<span class="function">(<span class="params">el, i</span>) =&gt;</span> el === deps[i])</span><br><span class="line">    : <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (hasNoDeps || hasChangedDeps) &#123;</span><br><span class="line">    callback();</span><br><span class="line">    memoizedState[cursor] = depArray;</span><br><span class="line">  &#125;</span><br><span class="line">  cursor++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里基本的业务已经满足了，但是有几个需要注意的点：</p>
<ul>
<li>memoizedState 数组是按 hook定义的顺序来放置数据的，如果hooks的顺序变化，memoizedState 并不会感知到所以不要再循环或者判断语句中调用。</li>
<li>自定义的hooks也是共享同一个 memoizedState，共享同一个顺序。</li>
</ul>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://react.docschina.org/docs/hooks-reference.html" target="_blank" rel="noopener">hooks</a></p>
<p><a href="https://www.robinwieruch.de/react-hooks" target="_blank" rel="noopener">react-hooks-fetch</a></p>
<p><a href="https://react.docschina.org/docs/hooks-faq.html" target="_blank" rel="noopener">hooks-faq</a></p>
<p><a href="https://github.com/facebook/react/blob/master/packages/react/src/ReactHooks.js" target="_blank" rel="noopener">ReactHooks源码</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:feng960106@163.com">hfzvictory</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://file.jing999.cn/2019/10/17/workspace/Frame/react/react-hooks/">http://file.jing999.cn/2019/10/17/workspace/Frame/react/react-hooks/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://file.jing999.cn" target="_blank">hfzvictory</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.png" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/17/workspace/Frame/react-native/guide/"><img class="prev_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RN基本用法</div></div></a></div><div class="next-post pull_right"><a href="/2019/10/15/workspace/Server/api/GraphQL/"><img class="next_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GraphQL</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: '37fl65GwM0Ub4TbovXtyyFl7-gzGzoHsz',
  appKey: 'ASnnLHANk3heLWLCBK6zbfiw',
  notify: false,
  verify: false,
  placeholder: '输入评论...',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '20',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2021 By hfzvictory</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>京ICP备18059340号-1</span></a></div></div></footer><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.5" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script></body></html>